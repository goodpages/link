<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?</link>
<title><![CDATA[初探nodejs学习笔记- 如何使用nodejs接收get/post 数据]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Fri, 26 Aug 2016 17:31:49 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?</guid> 
<description>
<![CDATA[ 
	<div>前言：</div><div><br /></div><div>其实很早就对nodejs感兴趣没时间研究，最近做web前端感觉时间还充裕，来看看曾经买的图灵的nodejs书，也记录一下学习学习。防工具盗链抓取 freddon所有&nbsp;</div><div><br /></div><div>其实基于google v8引擎而上的nodejs，服务端写javascript还是优点多多的，尤其是对于我这样一个一直喜欢javascript的人来说真是haliluya！hayaya！ nodejs是单进程（严格意义来讲是无线程概念的）、采取事件轮询、回调等等来达到&lsquo;多任务&rsquo;的效果，好了，我简单就说这么多。上Code！</div><div><br /></div><div>Server服务端&nbsp;</div><div><br /></div><div>为了好代码好看、测试好操作，get、post请求方式全在一个js文件里面写了</div><div><br /></div><div>说明部分也全写在代码里了，也养成一个好习惯</div><div><br /></div><div>app.js</div><div><br /></div><div>/*导入需要用到的nodejs库*/</div><div>var http = require('http');</div><div>var url = require('url');</div><div>var qs = require('querystring');</div><div><br /></div><div>/**</div><div>&nbsp;* 简单配置个路由 用来检测无用的请求 仅符合路由规则的才能被接受</div><div>&nbsp;* 自己可以按照需要定义</div><div>&nbsp;* @type &#123;&#123;/: string, favicon: string, user: string, login: string, biz: string&#125;&#125;</div><div>&nbsp;*/</div><div>var route = &#123;</div><div>&nbsp; &nbsp; '/': &quot;/&quot;,</div><div>&nbsp; &nbsp; 'favicon': '/favicon.ico',</div><div>&nbsp; &nbsp; 'user': '/user',</div><div>&nbsp; &nbsp; 'login': '/user/login',</div><div>&nbsp; &nbsp; 'biz': '/biz'</div><div>&#125;;</div><div><br /></div><div>/**</div><div>&nbsp;* 上述路由的简单判断规则</div><div>&nbsp;* @param reqPath</div><div>&nbsp;* @returns &#123;boolean&#125;</div><div>&nbsp;*/</div><div>var isValid = function (reqPath) &#123;</div><div>&nbsp; &nbsp; for (var key in route) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (route[key] == reqPath) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; return false;</div><div>&#125;;</div><div><br /></div><div>/**</div><div>&nbsp;* 照样输出json格式的数据</div><div>&nbsp;* @param query</div><div>&nbsp;* @param res</div><div>&nbsp;*/</div><div>var writeOut = function (query, res) &#123;</div><div>&nbsp; &nbsp; res.write(JSON.stringify(query));</div><div>&nbsp; &nbsp; res.end();</div><div>&#125;</div><div><br /></div><div>/**</div><div>&nbsp;* 启用http创建一个端口为8124的服务</div><div>&nbsp;* createServer内侧为回调函数：</div><div>&nbsp;* ...可看作java servlet中的 onService(HttpRequest,HttpResponse)</div><div>&nbsp;* ...或者（doGet、doPost）</div><div>&nbsp;*/</div><div>http.createServer(function (req, res) &#123;</div><div><br /></div><div>&nbsp; &nbsp; if (!isValid(url.parse(req.url).pathname)) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.writeHead(404, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.write(&quot;&#123;'errcode':404,'errmsg':'404 页面不见啦'&#125;&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.end();</div><div>&nbsp; &nbsp; &#125; else &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.writeHead(200, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (req.method.toUpperCase() == 'POST') &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var postData = &quot;&quot;;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 因为post方式的数据不太一样可能很庞大复杂，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 所以要添加监听来获取传递的数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 也可写作 req.on(&quot;data&quot;,function(data)&#123;&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.addListener(&quot;data&quot;, function (data) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postData += data;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 这个是如果数据读取完毕就会执行的监听方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.addListener(&quot;end&quot;, function () &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var query = qs.parse(postData);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeOut(query, res);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; else if (req.method.toUpperCase() == 'GET') &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 也可使用var query=qs.parse(url.parse(req.url).query);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 区别就是url.parse的arguments[1]为true：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ...也能达到&lsquo;querystring库&rsquo;的解析效果，而且不使用querystring</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var query = url.parse(req.url, true).query;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeOut(query, res);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125; else &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //head put delete options etc.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &#125;</div><div><br /></div><div>&#125;).listen(8124, function () &#123;</div><div>&nbsp; &nbsp; console.log(&quot;listen on port 8124&quot;);</div><div>&#125;);</div><div><br /></div><div><br /></div><div>Client 端</div><div><br /></div><div>其实只要能发请求就行了 ，有在线的post、get请求工具（前提是nodejs程序要上传到自己的服务器）也有可以下载的postman等等，当然也可以手动写一个html的form表单提交不就好了吗 防工具盗链抓取 freddon所有&nbsp;</div><div><br /></div><div>如果服务端在自己本地，而且端口用上面所说的8124，so：</div><div><br /></div><div><br /></div><div><br /></div><div>使用HTML Form提交</div><div><br /></div><div>先上个常规的</div><div><br /></div><div>html文件如下</div><div><br /></div><div>&lt;!DOCTYPE html&gt;</div><div>&lt;html lang=&quot;en&quot;&gt;</div><div>&lt;head&gt;</div><div>&nbsp; &nbsp; &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div>&nbsp; &nbsp; &lt;title&gt;&lt;/title&gt;</div><div>&lt;/head&gt;</div><div>&lt;body&gt;</div><div><br /></div><div>&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1:8124/biz&quot; &gt;</div><div>&nbsp; &nbsp; &lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;freddon&quot; /&gt;</div><div>&nbsp; &nbsp; &lt;input name=&quot;domain&quot; type=&quot;text&quot; value=&quot;http://www.sagosoft.com/&quot;/&gt;</div><div>&nbsp; &nbsp; &lt;input type=&quot;submit&quot; value=&quot;以POST提交&quot; /&gt;</div><div>&lt;/form&gt;</div><div><br /></div><div><br /></div><div>&lt;form method=&quot;get&quot; action=&quot;http://127.0.0.1:8124/biz&quot; &gt;</div><div>&nbsp; &nbsp; &lt;input name=&quot;name&quot; type=&quot;text&quot; value=&quot;freddon&quot; /&gt;</div><div>&nbsp; &nbsp; &lt;input name=&quot;domain&quot; type=&quot;text&quot; value=&quot;http://www.sagosoft.com/&quot;/&gt;</div><div>&nbsp; &nbsp; &lt;input type=&quot;submit&quot; value=&quot;以GET提交&quot; /&gt;</div><div>&lt;/form&gt;</div><div><br /></div><div>&lt;/body&gt;</div><div>&lt;/html&gt;</div><div><br /></div><div><br /></div><div>得到的响应应该为：&#123;&quot;name&quot;:&quot;freddon&quot;,&quot;domain&quot;:&quot;http://www.sagosoft.com/&quot;&#125;</div><div><br /></div><div>使用Nodejs请求</div><div><br /></div><div>接下来，既然是使用Nodejs，那肯定有不用浏览器的办法，就是使用js来请求并在控制台打印。[可使用webstorm、intellij idea、命令行等环境]</div><div><br /></div><div>client.js</div><div><br /></div><div>var http = require(&quot;http&quot;);</div><div>var qs = require('querystring');</div><div><br /></div><div>var postData = &#123;&quot;name&quot;: &quot;freddon&quot;, &quot;domain&quot;: &quot;http://www.sagosoft.com/&quot;&#125;;</div><div>var outData=qs.stringify(postData);</div><div>var options = &#123;</div><div>&nbsp; &nbsp; host: '127.0.0.1',</div><div>&nbsp; &nbsp; port: 8124,</div><div>&nbsp; &nbsp; path: '/biz',</div><div>&nbsp; &nbsp; //path:'/biz?name=freddon&amp;domain='+encodeURIComponent(&quot;http://www.sagosoft.com/&quot;),</div><div>&nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp;* 如果改为get，上述的postdata需要自己拆成key＝value格式拼接在path之后</div><div>&nbsp; &nbsp; &nbsp;* 如 '/biz?name=freddon&amp;domain='+encodeURIComponent(&quot;http://www.sagosoft.com/&quot;)</div><div>&nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; method: 'POST',</div><div>&nbsp; &nbsp; headers: &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 'Content-Type': 'application/x-www-form-urlencoded',</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //只有post时，这个才有用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 'Content-Length': outData.length</div><div><br /></div><div>&nbsp; &nbsp; &#125;</div><div>&#125;;</div><div><br /></div><div>var requestCallback = function (response) &#123;</div><div>&nbsp; &nbsp; response.setEncoding('utf-8');</div><div>&nbsp; &nbsp; console.log(&quot;状态码 %d &#92;nheaders:&#92;n %s &#92;n当前的请求方式为【%s】请求&quot;,response.statusCode,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; JSON.stringify(response.headers),options.method);</div><div>&nbsp; &nbsp; var receiveData = &quot;&quot;;</div><div>&nbsp; &nbsp; response.on('data', function (chunk) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; receiveData += chunk;</div><div>&nbsp; &nbsp; &#125;).on('end', function () &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //打印</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(&quot;&#92;n从&quot; + options.host + &quot;获得的数据为：&quot; + receiveData);</div><div>&nbsp; &nbsp; &#125;);</div><div><br /></div><div>&#125;;</div><div><br /></div><div>var req = http.request(options, requestCallback).on('error',function(e)&#123;</div><div><br /></div><div>&nbsp; &nbsp; console.log(e.message);</div><div>&#125;);</div><div>req.write(outData);//当然如果是get请求 这个写了也没用</div><div>req.end();</div><div>运行结果 如下图：</div><div><br /></div><div><br /></div><div><br /></div><div>因为绝大数网络请求都是get请求，所以官方单独对get请求做了个简化版</div><div><br /></div><div>get.js</div><div><br /></div><div>var http = require(&quot;http&quot;);</div><div><br /></div><div>var urlPath='http://127.0.0.1:8124/biz?' +</div><div>&nbsp; &nbsp; 'name=freddon&amp;domain='+encodeURIComponent(&quot;http://www.sagosoft.com/&quot;);</div><div>http.get(urlPath, function(response) &#123;</div><div>&nbsp; &nbsp; response.setEncoding('utf-8');</div><div>&nbsp; &nbsp; console.log(&quot;状态码 %d &#92;nheaders:&#92;n %s &#92;n当前的请求方式为【GET】请求&quot;,response.statusCode,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; JSON.stringify(response.headers));</div><div>&nbsp; &nbsp; var receiveData = &quot;&quot;;</div><div>&nbsp; &nbsp; response.on('data', function (chunk) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; receiveData += chunk;</div><div>&nbsp; &nbsp; &#125;).on('end', function () &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //打印</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(&quot;&#92;n获得的数据为：&quot; + receiveData);</div><div>&nbsp; &nbsp; &#125;);</div><div><br /></div><div>&#125;).on('error', function(e) &#123;</div><div>&nbsp; &nbsp; console.log(e.message);</div><div>&#125;);</div><div>运行结果我就不截图了，跟上面的get请求结果相似。</div><div><br /></div><div>挺简单吧。ok，就到这里了。防工具盗链抓取 freddon所有&nbsp;</div><div><br /></div><div><br /></div><div><br /></div><div>附加</div><div><br /></div><div>接下来加点简单的Auth验证,因为这个对于生产环境蛮重要的，一般来说都是md5(id、密钥、时间戳偏移)、id、时间戳 组合生成的base64或者其他格式，这里简单提一下，就一个字符串base64完事</div><div><br /></div><div>app.js</div><div><br /></div><div>/*导入需要用到的nodejs库*/</div><div>var http = require('http');</div><div>var url = require('url');</div><div>var qs = require('querystring');</div><div><br /></div><div>/**</div><div>&nbsp;* 简单配置个路由 用来检测无用的请求 仅符合路由规则的才能被接受</div><div>&nbsp;* 自己可以按照需要定义</div><div>&nbsp;* @type &#123;&#123;/: string, favicon: string, user: string, login: string, biz: string&#125;&#125;</div><div>&nbsp;*/</div><div>var route = &#123;</div><div>&nbsp; &nbsp; '/': &quot;/&quot;,</div><div>&nbsp; &nbsp; 'favicon': '/favicon.ico',</div><div>&nbsp; &nbsp; 'user': '/user',</div><div>&nbsp; &nbsp; 'login': '/user/login',</div><div>&nbsp; &nbsp; 'biz': '/biz'</div><div>&#125;;</div><div><br /></div><div>/**</div><div>&nbsp;* 上述路由的简单判断规则</div><div>&nbsp;* @param reqPath</div><div>&nbsp;* @returns &#123;boolean&#125;</div><div>&nbsp;*/</div><div>var isValid = function (reqPath) &#123;</div><div>&nbsp; &nbsp; for (var key in route) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (route[key] == reqPath) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; return false;</div><div>&#125;;</div><div><br /></div><div>/**</div><div>&nbsp;* 照样输出json格式的数据</div><div>&nbsp;* 如果想输出key＝value&amp;key2=value。。。 格式</div><div>&nbsp;* 请使用qs.stringify(query)</div><div>&nbsp;* @param query</div><div>&nbsp;* @param res</div><div>&nbsp;*/</div><div>var writeOut = function (query, res) &#123;</div><div>&nbsp; &nbsp; res.write(JSON.stringify(query));</div><div>&nbsp; &nbsp; res.end();</div><div>&#125;</div><div><br /></div><div>/**</div><div>&nbsp;* 简单做个auth认证</div><div>&nbsp;* @returns &#123;String&#125;</div><div>&nbsp;*/</div><div>var getAuthChunk = function () &#123;</div><div>&nbsp; &nbsp; return new Buffer('freddon').toString('base64');</div><div>&#125;;</div><div><br /></div><div>/**</div><div>&nbsp;* 启用http创建一个端口为8124的服务</div><div>&nbsp;* createServer内侧为回调函数：</div><div>&nbsp;* ...可看作java servlet中的 onService(HttpRequest,HttpResponse)</div><div>&nbsp;* ...或者（doGet、doPost）</div><div>&nbsp;*/</div><div>http.createServer(function (req, res) &#123;</div><div>&nbsp; &nbsp; var auth = req.headers['authorization'];</div><div>&nbsp; &nbsp; if (!isValid(url.parse(req.url).pathname)) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.writeHead(404, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.write(&quot;&#123;'errcode':404,'errmsg':'404 页面不见啦'&#125;&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.end();</div><div>&nbsp; &nbsp; &#125; else &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; res.writeHead(200, &#123;'Content-Type': 'text/plain;charset=utf-8'&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if(auth != getAuthChunk())&#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.end(&quot;sorry,you haven't permission to Access this&quot;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; if (req.method.toUpperCase() == 'POST') &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var postData = &quot;&quot;;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 因为post方式的数据不太一样可能很庞大复杂，</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 所以要添加监听来获取传递的数据</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 也可写作 req.on(&quot;data&quot;,function(data)&#123;&#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.addListener(&quot;data&quot;, function (data) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postData += data;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 这个是如果数据读取完毕就会执行的监听方法</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; req.addListener(&quot;end&quot;, function () &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var query = qs.parse(postData);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeOut(query, res);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#125;);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; else if (req.method.toUpperCase() == 'GET') &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 也可使用var query=qs.parse(url.parse(req.url).query);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* 区别就是url.parse的arguments[1]为true：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* ...也能达到&lsquo;querystring库&rsquo;的解析效果，而且不使用querystring</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var query = url.parse(req.url, true).query;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeOut(query, res);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125; else &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //head put delete options etc.</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &#125;</div><div>&nbsp; &nbsp; &#125;</div><div><br /></div><div>&#125;).listen(8124, function () &#123;</div><div>&nbsp; &nbsp; console.log(&quot;listen on port 8124&quot;);</div><div>&#125;);</div><div><br /></div><div><br /></div><div>client.js</div><div><br /></div><div>var http = require(&quot;http&quot;);</div><div>var qs = require('querystring');</div><div><br /></div><div>var postData = &#123;&quot;name&quot;: &quot;freddon&quot;, &quot;domain&quot;: &quot;http://www.sagosoft.com/&quot;&#125;;</div><div>var outData=qs.stringify(postData);</div><div>var options = &#123;</div><div>&nbsp; &nbsp; host: '127.0.0.1',</div><div>&nbsp; &nbsp; port: 8124,</div><div>&nbsp; &nbsp; path: '/biz',</div><div>&nbsp; &nbsp; //path:'/biz?name=freddon&amp;domain='+encodeURIComponent(&quot;http://www.sagosoft.com/&quot;),</div><div>&nbsp; &nbsp; /**</div><div>&nbsp; &nbsp; &nbsp;* 如果改为get，上述的postdata需要自己拆成key＝value格式拼接在path之后</div><div>&nbsp; &nbsp; &nbsp;* 如 '/biz?name=freddon&amp;domain='+encodeURIComponent(&quot;http://www.sagosoft.com/&quot;)</div><div>&nbsp; &nbsp; &nbsp;*/</div><div>&nbsp; &nbsp; method: 'POST',</div><div>&nbsp; &nbsp; headers: &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 'Content-Type': 'application/x-www-form-urlencoded',</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //只有post时，这个才有用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 'Content-Length': outData.length</div><div><br /></div><div>&nbsp; &nbsp; &#125;</div><div>&#125;;</div><div><br /></div><div>var requestCallback = function (response) &#123;</div><div>&nbsp; &nbsp; response.setEncoding('utf-8');</div><div>&nbsp; &nbsp; console.log(&quot;状态码 %d &#92;nheaders:&#92;n %s &#92;n当前的请求方式为【%s】请求&quot;,response.statusCode,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; JSON.stringify(response.headers),options.method);</div><div>&nbsp; &nbsp; var receiveData = &quot;&quot;;</div><div>&nbsp; &nbsp; response.on('data', function (chunk) &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; receiveData += chunk;</div><div>&nbsp; &nbsp; &#125;).on('end', function () &#123;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; //打印</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(&quot;&#92;n从&quot; + options.host + &quot;获得的数据为：&quot; + receiveData);</div><div>&nbsp; &nbsp; &#125;);</div><div><br /></div><div>&#125;;</div><div><br /></div><div>var req = http.request(options, requestCallback).on('error',function(e)&#123;</div><div><br /></div><div>&nbsp; &nbsp; console.log(e.message);</div><div>&#125;);</div><div>var authStr=new Buffer('freddon').toString('base64');</div><div>req.setHeader(&quot;Authorization&quot;,authStr);</div><div>req.write(outData);//当然如果是get请求 这个写了也没用</div><div>req.end();</div><div><br /></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?#blogcomment</link>
<title><![CDATA[[评论] 初探nodejs学习笔记- 如何使用nodejs接收get/post 数据]]></title> 
<author> &lt;user@domain.com&gt;</author>
<category><![CDATA[评论]]></category>
<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?#blogcomment</guid> 
<description>
<![CDATA[ 
	
]]>
</description>
</item>
</channel>
</rss>