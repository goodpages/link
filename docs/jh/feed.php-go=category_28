<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?3583</link>
<title><![CDATA[《软件框架设计的艺术》读书笔记]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Fri, 02 Nov 2012 01:39:40 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?3583</guid> 
<description>
<![CDATA[ 
	<strong>&nbsp;</strong>从老大位置上淘来的好书《软件框架设计的艺术》，只看了几章。先写点读书笔记备忘。后续再更新。 <p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>书中大部分的内容，都是围绕框架向后兼容性，和可扩展性展开的。全书虽然是基于Java写的，但是对于AS来说绝大部分也同样适用。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>一.只公开你需要公开的内容。必须要限制对外公开的方法和属性的数量，包括public 和protected的，这些API一旦公布，就代表了对外的一种承诺，你永远不能去改变他们。否则就会带来框架版本的兼容问题。只有框架内部使用的公开方法，也不应该对外公开，给上一个&ldquo;此方法仅框架使用，外部不可以使用&rdquo;这样的文档注释是很糟糕的。但是原生提供的internal修饰符又只支持包内访问。针对这个问题，书里还特别提供了一种在Java里能巧妙的跨包访问又能对外屏蔽的方法。讲解的有点复杂。不过这个在AS里是很容易的，可以通过自定义一个框架内部使用的命名空间作为新的修饰符就行了。具体可以参考Flex源码里随处可见的mx_internal。在这个命名空间下定义需要跨包访问，但又不想被用户调用的方法，属性和类。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>二.避免深层次的继承。子类可以通过覆盖父类的方法来改变父类行为。但继承的重点不是用来改变行为的，而是扩展功能的作用。子类跟父类应的关系该是跟描述自然世界里的关系一样。子类屏蔽掉自己额外的功能后就一定可以完全被当做父类来使用。如果只是为了复用父类的部分代码，应该使用接口。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>三.模块化架构一章中强调了框架内部分模块解耦的重要性，这要求不模块的代码互相之间不能引用。但是互相引用的情况，是必然发生的。对此，书中提出了用&ldquo;依赖注入&rdquo;的方式来统一解决这个问题的方案。依赖注入简单的说也就是将所有需要直接用其他模块类的地方，都定义上接口。把使用对应的类，改为使用接口。而对应的类都去实现这个接口。最终使用一个配置类，配置每个接口默认的实现类,从而把所有依赖关系都转移到这个一个配置类里面而不是分散各处。所有依赖的地方，都使用这个配置类来查询自己使用到的接口的默认实现类。本质上还是依赖的，引用也没有断开，只是挪了个位置，都放在配置文件里了。一旦模块发生变化，改变一个配置文件比改变意大利面条式的交叉引用更有效。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>最后依赖注入的重点就都转移到了这个配置文件上，书中讨论了多种管理这个配置文件的方案。最基本的一种是，直接使用一个类，里面用代码一一写好相应接口到默认实现类的映射关系供查询。但是这个不太方便管理。所以有了进化的方案。也就是著名的Spring框架里的注入机制。用外部xml来配置这些映射关系，运行时载入解析成一个查询类。实际上原理还是跟第一种差不多。只是把用代码方式的配置改成xml，对于不了解框架的配置人员来说，比较方便而已。我试着想在自己的框架里应用这种依赖注入机制，把模块解耦。典型的应用就是所有的UI组件都有一个默认的皮肤类。但是遇到一些问题：</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>1.在无需人工干预的情况下，框架内部代码实现依赖注入：如果我用第一种方式，将所有映射关系都定义在一个LookUp类里，而所有组件都通过这个类查询默认皮肤，这样编译的时候，我只要使用了一个组件，就会导致，所有的默认皮肤都被编译进最终代码里。这个感觉是很糟糕的。如果我用第二种，用字符串的方式获取类定义的话，是绕过了编译器。但是对应的类可能根本不会被编译进代码。导致获取不到定义。所以第二种方案也只能把所有类都默认强制编译进代码才能实现。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>2.在项目阶段配置依赖注入。这种方式就不存在上面的问题了，可以只配置具体项目用到的类，才编译进代码。不会有冗余。但是问题是，为此每个项目都要单独写个自己的配置文件。这个有点太麻烦了。不够智能。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>3.在编译器阶段配置依赖注入。淘汰了前两种方案后，我突然发觉Flex里也使用了依赖注入，而且用的非常巧妙。但它框架内的组件就不存在一处引用默认皮肤的地方，同样也不需要用户自己写项目配置文件。那它是在什么时候配置的默认皮肤呢？最后我试着用mxmlc编译了一个mxml文件后再查看它自动生成的代码，终于找到了默认皮肤的配置。编译器对项目中使用的组件自动添加上了对应默认皮肤引用。原来Flex是在编译器里做了手脚啊。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2950</link>
<title><![CDATA[清除代码异味 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Wed, 08 Aug 2012 09:13:40 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2950</guid> 
<description>
<![CDATA[ 
	<div id="news_content"><p></p><p><span>今天，Venkat Subramaniam 就关于清除代码异味的话题给我们做了一个非常有趣的演讲。下面就是我记录的一些他的话。</span></p><p><span>　　<strong>为什么我们需要有质量的代码？</strong></span></p><ul><li><span>敏捷开发方法是用来应付那些要求代码做大量改动的反馈信息的方法。</span> </li><li><span>如果程序没有用一种好的表达方式来表现，那程序会很难读，难维护，难修改。</span> </li></ul><p><span>　　<strong>什么是代码异味？</strong></span></p><ul><li><span>代码异味是一种由写的很差的代码引起的一种有臭味的感觉，一种程序什么地方会有问题的感觉</span> </li><li><span>异味更多的是来自一种直觉，而不是一种有据可查的标准，当你看到有味的代码时你就&ldquo;感觉&rdquo;到了</span> </li><li><span>如果你不把异味清除，不久之后你就会习惯这种气味，不再对它有察觉</span> </li><li><span>用任何语言都能写出有异味的代码：即使最简单安全的语言，你也能做出天才才能想出的蠢事:)</span> </li><li><span>我们经常会意识不到自己在写很臭的代码，经常需要外人为我们指出这点</span> <ul><li><span><em>边注</em>：如果你不想刻意去批评某人的程序，不要说&ldquo;太愚蠢了&rdquo;，要说&ldquo;哦，这很有意思&hellip;。可有一种更好的方法你知道吗&rdquo;</span> </li></ul></li></ul><p><span>　　<strong>重复的代码</strong></span></p><ul><li><span>会引起程序里面多个地方相同的错误</span> </li><li><span><em>印度小伙</em>：每两个月我们都会把这相同的错误修改一次</span> </li><li><span><em>Venkat</em>：你们去掉了重复的代码了吗？</span> </li><li><span><em>印度小伙</em>：你说的这个方法不错！</span> </li></ul><p><span>　　<strong>不必要的复杂</strong></span></p><ul><li><span>程序员本质上讲高兴去处理复杂的问题</span> </li><li><span>复杂最恐怖</span> </li></ul><p><span>　　<strong>异常处理</strong></span></p><ul><li><span>问：有什么比一个空的异常捕捉代码更糟糕的？</span> <ul><li><blockquote><span>try&#123;... &#125; catch (Exception e)&#123;&#125;</span></blockquote></li></ul></li><li><span>答：一个带有注释的空异常捕捉代码！</span> <ul><li><blockquote><span>try&#123;... &#125; catch (Exception e)&#123;// is this required? &#125;</span></blockquote></li></ul></li><li><span>Java的异常检查：好还是不好？</span> </li><li><span>如果你不想处理一个异常，就把它传递下去</span> </li><li><span>如果你想捕捉两个异常，使用两个catch代码，不要只写一个而用If条件处理</span> </li></ul><p><span>　　<strong>Switch语句&amp; 按类型的条件判断</strong></span></p><ul><li><span>Switch语句和按类型的条件判断通常可以用多形性来代替</span> </li></ul><p><span>　　<strong>长方法</strong></span></p><ul><li><span>你不能在一屏上看到整个方法</span> </li><li><span>这通常意味着一个方法承担这多重任务</span> </li><li><span>难于调试</span> </li><li><span>不可测试</span> </li><li><span>难于重用-&gt; 导致程序员从方法的其它地方拷贝粘贴出重复的代码</span> </li><li><span>复杂的条件语句-&gt; 挑战大脑的逻辑分析能力</span> </li><li><span>方法长度：组织归纳水平比控制代码行数更重要</span> </li></ul><p><span>　　<strong>方法组成模式</strong></span></p><ul><li><span>方法里的所有语句都必须处在同一个归纳层次上</span> </li></ul><p><span>　　<strong>无用的注释</strong></span></p><ul><li><span><em>让代码自我表白</em></span> </li><li><span><em>标注为什么这样，而不是如何这样</em></span> </li><li><span>对方法表现进行描述等于重复表现</span> </li><li><span>这样的注释等于重复写一遍代码</span> <ul><li><blockquote><span>i += 1 //递增</span></blockquote></li></ul></li><li><span>长方法里用来描述这个方法有不同的功用的注释</span> <ul><li><span>把里面的功能片段提取成小方法&amp; 删除注释</span> </li></ul></li><li><span>IDE排泄物：IDE自动产生的注释空白占位符</span> </li><li><span>糟糕的注释通常产生于TDD*</span> <ul><li><span><em>*(TDD：Threat driven development，恐吓驱动开发)&mdash;&mdash;你<strong>应该</strong>为方法的表象写注释，你应该为长方法写注释，等</em></span> </li></ul></li><li><span>产品里的注释：</span> <ul><li><blockquote><span>//上帝保佑，我实在不知道这是什么意思</span></blockquote></li></ul></li></ul><p><span>　　<strong>变量名称</strong></span></p><ul><li><span>使用能表意的名称</span> </li><li><span>不要用单个字母做名称</span> </li><li><span>也不要使用太长的名称</span> </li></ul><p><span>　　<strong>继承</strong></span></p><ul><li><span>继承更多的是被滥用了</span> </li><li><span>组合通常优于继承</span> </li><li><span>在一对一关系中使用继承，满足<a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov替换原则</a></span> </li><li><span><em>不要</em>用继承来实现方法重用</span> </li><li><span>重用方法时，委托是个更好的选择</span> </li></ul><p><span>　　<strong>粘手的语言</strong></span></p><ul><li><span>这种语言更容易导致犯错误</span> </li></ul><p><span>　　<strong>最臭的代码</strong></span></p><ul><li><span>冗长的类</span> </li><li><span>重复的代码</span> </li><li><span>淘汰的方法</span> </li><li><span>不必要的塑型(cast)</span> </li><li><span>过度使用设计模式</span> </li></ul><p><span>　　<strong>代码除味</strong></span></p><ul><li><span>代码复查！</span> <ul><li><span>写出之后尽快进行</span> </li><li><span>要增量进行</span> </li><li><span>要复查测试用例</span> </li></ul></li><li><span>可使用结对编程</span> <ul><li><span>但要保持结对伙伴的经常变动，否则你会习惯你的气味，不再会有察觉</span> </li><li><span>结对伙伴一、两天调换一次</span> </li></ul></li></ul><p><span>　　<strong>一些设计原则</strong></span></p><ul><li><span><a href="http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29#High_cohesion">高聚合</a></span> </li><li><span><a href="http://en.wikipedia.org/wiki/Coupling_%28computer_programming%29">低耦合</a></span> </li><li><span><a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Demeter定律</a><span>&nbsp;</span>[<a href="http://www.pragprog.com/articles/tell-dont-ask">不要告诉我，我会通知你</a>]</span> </li><li><a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov替换原则</a> </li><li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">先让它跑起来，再让它无误，再让它快速</a> </li><li><a href="http://en.wikipedia.org/wiki/Open/closed_principle">开发/闭合原则</a> </li><li><a href="http://en.wikipedia.org/wiki/Open/closed_principle">反向依赖</a> </li><li><a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">单一责任原则</a> </li></ul><p>　　<strong>一些参考书籍</strong></p><ul><li><a href="http://goo.gl/TLcw6">代码整洁之道(Clean Code)</a> </li><li><a href="http://goo.gl/6Relk">代码大全(Code Complete) 2</a> </li><li><a href="http://goo.gl/Ck4eu">程序员修炼之道(The Pragmatic Programmer)</a> </li><li><a href="http://bit.ly/mETK0I">敏捷开发修炼之道(Practices of an Agile Developer)</a> </li><li><a href="http://www.amazon.com/Smalltalk-Best-Practice-Patterns-Kent/dp/013476904X/">Smalltalk Best Practice Patterns</a> </li><li><a href="http://bit.ly/iZ1fAP">实现模式(Implementation Patterns)</a><span>&nbsp;</span>(from<span>&nbsp;</span><a href="http://twitter.com/protoiyer">@protoiyer</a>) </li></ul><p>　　<strong>问和答</strong></p><ul><li><em>关于使用代码检测工具，例如PMD</em>：这样的工具非常的有用，它能让你捕捉到很直接的问题，使你的代码复查工作专注于高层面的设计原则问题 </li><li><em>关于IDE上附加的工具</em>：不要自己去运行它们。让这些工具在后台自动的运行(或智能化) </li><li><em>动态语言里需要重构吗</em>：动态语言里没有太多的自动重构工具，但程序员仍然应该手动的重构 </li><li><em>关于动态语言的设计模式</em>：每种语言都有自己的模式和特色。例如：smalltalk的<a href="http://stackoverflow.com/questions/341971/what-is-the-execute-around-idiom">execute around method</a>模式 </li><li><em>关于掌握多种语言</em> <ul><li>你应该知道处理一个问题的多种范式，多种风格和多种方式 </li><li>一种语言中学到的特色方法应用到其它语言里 </li><li>知道各种不同方式的各自风险 </li></ul></li><li><em>关于编程语言趋势</em>：对函数性编程，移动设备编程兴趣浓厚 </li><li><em>关于著书</em>：长时间的思考书中的各项主题，多做这方面话题的讨论，吸取精华。当开始动手去写时，已经胸有成竹，2周内把书写成 </li><li><em>关于思考文献</em>：思考文献很有用，但你也要多看看批评性的思考性文章，它们是关于你如何去思考的(<a href="http://www.reply-mc.com/2009/10/26/what-about-chris-argyris/">double loop learning</a>?) </li><li><em>关于学习</em>：在用户组里跟其它人合作，交流，讨论。你并不能学到所有的东西，但要努力缩小自己的&ldquo;你不知道你不知道的东西&rdquo;，让它成为&ldquo;你知道你不知道的&rdquo;<span style="line-height: 0px; font-size: 1px">&nbsp;</span> </li></ul></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2871</link>
<title><![CDATA[项目管理的“三边六拍”！]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Mon, 30 Jul 2012 09:12:30 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2871</guid> 
<description>
<![CDATA[ 
	&ldquo;三边&rdquo;是指：边计划、边实施、边修改，&ldquo;六拍&rdquo;是指：拍脑袋、拍肩膀、拍胸口、拍桌子、拍屁股、拍大腿！&ldquo;三边六拍&rdquo;很形象，引人深思！ <p>　　&ldquo;三边六拍&rdquo;并非本人原创，最开始我是从我的领导那听到的，我觉得很有意思，很形象，很贴合实际。下面介绍一下什么是项目管理&ldquo;六拍&rdquo;，以及我的一些感受；然后介绍&ldquo;三边&rdquo;和我的体会。</p><p><strong>　　第一拍：拍脑袋</strong></p><p>　　客户领导与软件公司领导在一起，&ldquo;拍脑袋&rdquo;确定了一个项目，于是项目马上就要开始了，你的麻烦马上就要来了。</p><p>　　&ldquo;拍脑袋&rdquo;主要说明的问题是没有想清楚为什么要做这个项目，不怎么考虑可行性和最终效果，就冲动地让项目上马了。</p><p>　　我的感受：</p><p>　　作为项目经理的你，往往无法干预这个&ldquo;拍脑袋&rdquo;的过程，你想你的领导下次拍脑袋能拍好一点，恐怕也不太可能。你能做到的事情就是，搞清楚项目的背景、搞清楚你的领导和客户的领导做这个项目的动机是什么？</p><p>　　项目要成功，你必须同时满足你的领导和客户的想法。当然双方领导的想法可能都不确定，这可能会让你很被动，但也给你带来机会来&ldquo;控制&rdquo;这些事情，前期虽然是&ldquo;拍脑袋&rdquo;安排这个项目，但你可以在后期充分与双方领导沟通，逐步将领导脑袋中不明确的东西明确（当然难度超高），让项目有成功的机会。</p><p><strong>　　第二拍：拍肩膀</strong></p><p>　　领导安排项目工作给你时，往往是语重心长地说类似这样的话：这个项目对公司如何如何重要，你是公司中非常重要的人物，这个项目没有你不能成功......拍你的肩膀，就是和你套亲切和信任，有时候还会请你甚至是项目组吃饭，表示对大家的感谢和信任。</p><p>　　我的感想：</p><p>　　咱们做软件开发的，其实是不傻的，这些门面功夫其实让我觉得很恶心，而你遇到这样的情况时，你又必须虚伪地做下面的第三拍的事情，更加恶心！但如果我是领导，我会如何安排项目工作下去呢？会不会也是这样做这些恶心的门面功夫？</p><p><strong>　　第三拍：拍胸口</strong></p><p>　　有些朋友，可能真的是以为领导很重视你，义无反顾的&ldquo;拍胸口&rdquo;保证没有问题！</p><p>　　有些朋友就比较聪明，他知道这个项目你是不可能推脱的（除非你想走人），但他又知道任务艰巨，他会在拍胸口的同时，要求增加人手和延长工期，往往会得到老板的一些妥协。</p><p>　　而我是属于比较蠢的一种，我会直接跟领导说这个项目的一些重大问题，有些项目我了解到项目&ldquo;拍脑袋&rdquo;过程后，我甚至会说这个项目不可能成功。我这样做往往惹领导不高兴，觉得我不听话，认为我对这个项目没有信心等等。</p><p>　　我的感想：</p><p>　　做人真难，我不是随便承诺的人，我能列出项目的具体问题，说明已经认真思考了，有问题自然有努力的方向，没有问题其实问题更大，不知道领导是怎样想的？拍胸口真的是很痛苦的事情啊！</p><p><strong>　　第四拍：拍桌子</strong></p><p>　　项目进展不理想，领导拍桌子骂人！</p><p>　　领导拍桌子骂人，可能是真的很火，忍不住拍了，也可能是要给你一种威慑感，让你更有压力的干活。</p><p>　　也有的领导很厉害，会忍住怒火，他知道目前只能靠你，等项目完了后才&ldquo;收拾&rdquo;你！</p><p>　　我的感想：</p><p>　　用工厂模式来管理软件项目，其实是很傻的做法。软件项目是充满创造力的事情，无聊的高压，往往让项目组不思考如何更简单，更少工作量，而疲于奔命，不断返工。而老板见到你拼命加班，虽然工作成功不尽理想，但至少老板心里会舒坦一些。这是多么无聊的怪现象啊！</p><p>　　如果遇到厉害的领导，暂时忍住怒火，继续对你&ldquo;以礼相待&rdquo;。有人会趁机&ldquo;要挟&rdquo;一把，这时候要求加薪，90%是没有问题的，但你等着项目后被开掉吧，而且可能会被开得很惨。</p><p><strong>　　第五拍：拍屁股</strong></p><p>　　现在不是奴隶社会，我又不是终身卖给你的，老子不打东家可以打西家，你可以发飙，老子何尝不可以！老子走人，你自己管你这个破项目吧！</p><p>　　我的感想：</p><p>　　不管东家还是西家，其实家家都是一个鬼样，你只是从一个火坑跳到另外一个火坑而已。不要轻易拍屁股，要思考自己是否值得留下来！凡事没有完美，出来打工更加不可能事事顺意，从你的职业规划思考，你值不值得继续为这个项目奋斗？当然要记住，做人要有基本的职业道德，他不仁，我不会不义！</p><p><strong>　　第六拍：拍大腿</strong></p><p>　　领导将项目经理气走了，项目无人打理，于是拍大腿后悔。</p><p>　　我的感想：</p><p>　　早知如此，何必当初呢？但很多领导还是不断地重复着&ldquo;六拍&rdquo;，领导还真的是不好当啊！</p><p><strong>　　&ldquo;三边&rdquo;是指：边计划、边实施、边修改。</strong></p><p>　　很多项目往往没有通盘规划就仓促上马，紧张的项目工期，太多的不清楚因素，项目组在高压力下，往往是见一步走一步，一边做一边修改。最终项目效果也不会很好，不但项目组痛苦，客户的利益也会受到伤害，最后结果就是&ldquo;双输&rdquo;了！</p><p>　　实际上很多项目可能逃不过&ldquo;三边&rdquo;命运，因为项目上马时，需求是不确定的，技术往往也是不确定的，但工期是限死的，项目的预算也很可能是限死的，在&ldquo;两大限死、两不确定&rdquo;的框架下，&ldquo;三边&rdquo;难以避免。我做过的项目，几乎都不可能从一开始就能得到全面准确的需求，都不可能在项目初期就可以制定长期而周全的计划，小版本迭代是我惯常的做法。其实敏捷就有具备&ldquo;三边&rdquo;的特点，不过不是&ldquo;见一步走一步&rdquo;，而是有一个长远的战略性规划，通过一个个小版本逐步接近我们的目标，保持灵巧的同时也能预测变化。</p><p>　　所以我对&ldquo;三边&rdquo;的感想是：&ldquo;三边&rdquo;不代表低水平，关键你是敏捷地&ldquo;三边&rdquo;还是被动地&ldquo;三边&rdquo;？</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2742</link>
<title><![CDATA[敏捷，是灵丹妙药还是又一个忽悠？]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Mon, 25 Jun 2012 10:59:57 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2742</guid> 
<description>
<![CDATA[ 
	敏捷开发和敏捷测试这两年自从从国外引进后，在国内很火，很多人都在谈论。无论是项目延期，失败，质量低下等等，你总能听到分析的原因是：&ldquo;看看，你没有敏捷了吧&rdquo;。所以一下子敏捷成了包治百病的灵丹妙药。很多项目组公司开始学习敏捷，采用敏捷，转向敏捷。但是遗憾的是很多人尝试过后发现以前的问题并没有被敏捷所解决掉，反而带来了很多新的问题，于是也有人就得出结论：敏捷又是一个大忽悠。读了很多网上关于敏捷的辩论，我想起一个故事： <p>　　话说清朝的时候慈禧太后听说西方国家有个新的交通工具，汽车，它坐在舒服跑的很快。于是就叫人买了一辆回来。但是用的时候没有人会开，于是不得不把汽车用几根柱子绑起来做成了轿子，让几个人抬着。因为汽车太沉，几个轿夫步履蹒跚，走不了几步就得歇歇。结果以前半个时辰的路走了好几个时辰。而且到了后因为门很窄，汽车做的轿子过不去，她也不得不老远就下来自己走一段。慈禧太后很不高兴就得出结论：</p><p>　　1、汽车前期投入大，维护成本高。</p><p>　　2、没有轿子走的快。</p><p>　　3、很多地方汽车都不适用。</p><p>　　4、汽车是个大忽悠的东西，根本不管用。</p><p>　　那么我们现在对敏捷的认识是不是和慈禧对汽车的认识类似呢？是因为我们不会用敏捷呢，还是因为敏捷就是个忽悠？</p><p>　　在国外通常一个概念出来之前已经有很多年的实践积累，然后为了大家交流方便或者提高普及度给其一个名字。所以是先有实践，再有概念。但是在国内正好相反，我们先把国外&ldquo;先进&ldquo;的概念引进来了而把产生概念的多年实践忽略掉了。但是概念又太虚不能当饭吃，最终还是需要具体东西和具体做法。所以不得不根据概念来设计出各种各样的做法来。这些做法听起来不错，非常符合概念，但是在项目中一使用就不灵了，旧的问题没有解决，新的问题一大堆。最终得出汽车是个大忽悠的结论。</p><p>　　敏捷和云计算是两个非常典型的例子。很多人为了敏捷，文档不要了，计划不要了，测试用例也不要了，认为几个人站在走廊里沟通沟通就把一切都搞定了，因为敏捷了嘛。但是问题并没有因为&ldquo;敏捷&ldquo;了而被解决掉，于是乎得出敏捷是个忽悠的结论。云计算也一样，很多人认为云计算就是数据中心，所以大家大兴土木建立数据中心。但是建完数据中心以后呢？没啥用处呀。那大家都在吹捧云计算，不就是个大忽悠吗。 殊不知，人家是因为业务需要很多年了已有数据中心，为了提高数据中心的使用率，开始对公众开放资源，所以才有了云计算。</p><p>　　先有概念再造实践的做法违背了事物发展规律，不仅解决不了现有问题，而且带来新的问题。敏捷是个好东西，在特定情况下。我们需要搞明白的是它要解决什么问题的？它是如何解决的。而不要在乎它叫什么名字或则防止生搬硬套。还有越是先进的东西对人和基础设施的要求越高。比如飞机再好，没有飞行员或则没有机场也没有用。高铁跑的越快对铁道的要求越高。</p><p>　　软件测试也是一样，做质量控制不是为了赶时髦。如果你的项目只做 3 个月就彻底结束了，而且就3－5个人，不会有人离开也不会有人进来，也不需要和其它任何项目打交道，或则你的产品在早期实验阶段，你可以不要文档，不要计划，不要记录 bug，完全靠口头交流。否则的话：</p><p>　　1、不能没有文档:&nbsp; 但是要减少不必要的文档，避免过于详细的文档，使用易于更新和维护的动态文档。</p><p>　　1、不能没有计划: 距离现在越远计划越模糊，但是距离现在越近计划越详细。</p><p>　　1、不能没有纪律:</p><p>　　与其在琢磨如何敏捷测试，不如一步一步把自动化做好，把持续集成做起来，创建更多的测试工具以提高测试效率，把质量反馈系统做起来，把 dev 提交代码前的质量检查做起来，把在产品中测试做起来， 把测试工程师的素质提高上去。</p><p>　　等到这些都建立起来了后，你发现自己其实已经很敏捷了。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2684</link>
<title><![CDATA[什么是数据驱动编程 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Wed, 13 Jun 2012 01:18:31 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2684</guid> 
<description>
<![CDATA[ 
	<p><strong>前言：</strong></p><p>最近在学习《Unix编程艺术》。以前粗略的翻过，以为是介绍unix工具的。现在认真的看了下，原来是介绍设计原则的。它的核心就是第一章介绍的unix的哲学以及17个设计原则，而后面的内容就是围绕它来展开的。以前说过，要学习适合自己的资料，而判断是否适合的一个方法就是看你是否能够读得下去。我对这本书有一种相见恨晚的感觉。推荐有4~6年工作经验的朋友可以读一下。</p><br /><p><strong>正题：</strong></p><p>作者在介绍Unix设计原则时，其中有一条为&ldquo;<strong>表示原则：把知识叠入数据以求逻辑质朴而健壮</strong>&rdquo;。结合之前自己的一些经验，我对这个原则很有共鸣，所以先学习了数据驱动编程相关的内容，这里和大家分享出来和大家一起讨论。</p><br /><p><strong>数据驱动编程的核心</strong></p><p>数据驱动编程的核心出发点是<strong>相对于程序逻辑，人类更擅长于处理数据</strong>。数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据。</p><p>真的是这样吗？让我们来看一个示例。</p><p>假设有一个程序，需要处理其他程序发送的消息，消息类型是字符串，每个消息都需要一个函数进行处理。第一印象，我们可能会这样处理：</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;msg_proc(</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*msg_type,&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*msg_buf)&nbsp;&nbsp;</span></span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;inivite&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inivite_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;tring_100&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tring_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;ring_180&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring_180_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;ring_181&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring_181_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;ring_182&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring_182_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;ring_183&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ring_183_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;ok_200&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_200_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;。。。。。。&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_type,&nbsp;</span><span class="string">&quot;fail_486&quot;</span><span>))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail_486_fun(msg_buf);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log(</span><span class="string">&quot;未识别的消息类型%s&#92;n&quot;</span><span>,&nbsp;msg_type);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li></ol></div><br /><p></p><p>上面的消息类型取自sip协议（不完全相同，sip协议借鉴了http协议），消息类型可能还会增加。看着常常的流程可能有点累，检测一下中间某个消息有没有处理也比较费劲，而且，没增加一个消息，就要增加一个流程分支。</p><p>按照数据驱动编程的思路，可能会这样设计：<br /></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/chgaowei/article/details/6658260#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;(*SIP_MSG_FUN)(</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*);&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">typedef</span><span>&nbsp;</span><span class="keyword">struct</span><span>&nbsp;__msg_fun_st&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*msg_type;</span><span class="comment">//消息类型 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;SIP_MSG_FUN&nbsp;fun_ptr;</span><span class="comment">//函数指针 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;msg_fun_st;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>msg_fun_st&nbsp;msg_flow[]&nbsp;=&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;inivite&quot;</span><span>,&nbsp;inivite_fun&#125;,&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;tring_100&quot;</span><span>,&nbsp;tring_fun&#125;,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;ring_180&quot;</span><span>,&nbsp;ring_180_fun&#125;,&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;ring_181&quot;</span><span>,&nbsp;ring_181_fun&#125;,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;ring_182&quot;</span><span>,&nbsp;ring_182_fun&#125;,&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;ring_183&quot;</span><span>,&nbsp;ring_183_fun&#125;,&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;ok_200&quot;</span><span>,&nbsp;ok_200_fun&#125;,&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;。。。。。。&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;</span><span class="string">&quot;fail_486&quot;</span><span>,&nbsp;fail_486_fun&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">void</span><span>&nbsp;msg_proc(</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*msg_type,&nbsp;</span><span class="keyword">const</span><span>&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*msg_buf)&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;type_num&nbsp;=&nbsp;</span><span class="keyword">sizeof</span><span>(msg_flow)&nbsp;/&nbsp;</span><span class="keyword">sizeof</span><span>(msg_fun_st);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;type_num;&nbsp;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(0&nbsp;==&nbsp;strcmp(msg_flow[i].msg_type,&nbsp;msg_type))&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg_flow[i].fun_ptr(msg_buf);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;log(</span><span class="string">&quot;未识别的消息类型%s&#92;n&quot;</span><span>,&nbsp;msg_type);&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li></ol></div><br /><p>下面这种思路的优势：</p><p>1、可读性更强，消息处理流程一目了然。</p><p>2、更容易修改，要增加新的消息，只要修改数据即可，不需要修改流程。</p><p>3、重用，第一种方案的很多的else if其实只是消息类型和处理函数不同，但是逻辑是一样的。下面的这种方案就是将这种相同的逻辑提取出来，而把容易发生变化的部分提到外面。</p><br /><p><strong>隐含在背后的思想</strong>：</p><p>很多设计思路背后的原理其实都是相通的，隐含在数据驱动编程背后的实现思想包括：</p><p>1、控制复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。</p><p>2、隔离变化。像上面的例子，每个消息处理的逻辑是不变的，但是消息可能是变化的，那就把容易变化的消息和不容易变化的逻辑分离。</p><p>3、机制和策略的分离。和第二点很像，本书中很多地方提到了机制和策略。上例中，我的理解，机制就是消息的处理逻辑，策略就是不同的消息处理（后面想专门写一篇文章介绍下机制和策略）。</p><br /><p><strong>数据驱动编程可以用来做什么：</strong></p><p>如上例所示，它可以应用在函数级的设计中。</p><p>同时，它也可以应用在程序级的设计中，典型的比如用表驱动法实现一个状态机（后面写篇文章专门介绍）。</p><p>也可以用在系统级的设计中，比如DSL（这方面我经验有些欠缺，目前不是非常确定）。</p><br /><p><strong>它不是什么：</strong></p><p>1、 它不是一个全新的编程模型：它只是一种设计思路，而且历史悠久，在unix/linux社区应用很多；</p><p>2、它不同于面向对象设计中的数据：&ldquo;数据驱动编程中，数据不但表示了某个对象的状态，实际上还定义了程序的流程；OO看重的是封装，而数据驱动编程看重的是编写尽可能少的代码。&rdquo;</p><br /><p><strong>书中的值得思考的话：</strong></p><p>数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法。&mdash;&mdash;Rob Pike</p><p>程序员束手无策。。。。。只有跳脱代码，直起腰，仔细思考数据才是最好的行动。表达式编程的精髓。&mdash;&mdash;Fred Brooks</p><p>数据比程序逻辑更易驾驭。尽可能把设计的复杂度从代码转移至数据是个好实践。&mdash;&mdash;《unix编程艺术》作者。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2313</link>
<title><![CDATA[软件项目“免坑”指南 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Tue, 10 Apr 2012 05:20:22 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2313</guid> 
<description>
<![CDATA[ 
	<p><span style="font-size: 12px">目录</span></p><p><span style="font-size: 12px"><a href="http://www.cnblogs.com/MeteorSeed/archive/2012/04/08/2427966.html#kyds">一 坑有多深？</a></span></p><p><span style="font-size: 12px"><a href="http://www.cnblogs.com/MeteorSeed/archive/2012/04/08/2427966.html#szzk"><span style="line-height: 18px">二 谁在造坑？</span></a></span></p><p><span style="font-size: 12px"><a href="http://www.cnblogs.com/MeteorSeed/archive/2012/04/08/2427966.html#rhmk">三 如何免坑？</a></span></p><p><span style="font-size: 12px">　</span><span style="font-size: 12px">　&ldquo;谁也无法改变现状，唯有无数程序员血洒大地，才能使项目重建天日。&rdquo;这一点也不夸张，软件项目做烂了就是个坑，参与者也不过是填坑的。就像是在魔兽世界战场遇到国家队一样，你赢也赢不了，出也出不去。</span></p><p><span style="font-size: 12px"><a name="kyds"></a><strong><span style="font-size: 16px">一 坑有多深？</span></strong></span></p><p><span style="font-size: 12px">　　</span><span style="font-size: 12px">当我们进入一个项目时，通过不断观察我们可以发现我们的项目到底是不是一个坑。造坑的项目，往往具有某些&ldquo;臭味&rdquo;，以下是我的一些认识，这些&ldquo;臭味&rdquo;即是项目健康状态不佳的明显标志：</span></p><ul><li><span style="font-size: 12px"><strong>编码规范形同废纸，代码质量低下</strong>&nbsp;每个项目都有编码规范，但真正严格实施却是另一回事。太多的项目把编码规范作为形式的存在，没人在乎让开发人员写出&ldquo;人能读懂的程序&rdquo;，注释和命名也成了开发人员的随心所欲。project上永远只有开发任务，而几乎找不到单元测试的时间和代码审查的时间。在高压进度之下的项目，显得如此山寨。当我们还在抱怨自己工资低的时候，就先看看我们的程序还能称作OOP吗。</span></li><li><span style="font-size: 12px"><strong>缺乏文档或文档质量低下</strong>&nbsp;前期文档很重要，不论是框架的API使用手册，还是需求或设计文档，以及各种既定流程的规范，不同种类的模板及核对表，等等这些文档，对于项目来说都是非常重要的资源。而往往有些项目，这类文档就是交由非软件行业的人员来编写，或者前期根本不打算在文档上浪费时间。这就导致了，缺少相关文档或文档质量低下，在软件构建过程中，开发者和团队，不得不为这种&ldquo;表面工程&rdquo;的产物而纠结。甚至会退回到前期准备工作，完成所需的文档。有些文档可以在后期补，但有些必须在前期进行准备，以保住团队降低风险，减少缺陷引人的几率并提高编码质量，如果前期这类文档没有做好，那么就会像考前不复习一样，自食恶果。</span></li><li><span style="font-size: 12px"><strong>无尽的需求变更，永远追不上的进度</strong> 这是最常见也是最可怕的，因为无论怎样，我们都无法完成它。客户可能认为改个程序，就像改个Excel一样简单省事，甚至会使用可动用的一切权利和资源来推行变更。好吧，我承认这样的客户我遇到过很多。当我向客户解释过变更的代价并提供备选方案后，也就只能等待客户的选择了，这多少有些运数的成分，但也是无奈之举。</span></li><li><span style="font-size: 12px"><strong>仅仅靠加班应对进度落后 </strong>进度落后并不可怕，可怕的是仅靠加班来追赶进度。这是问题的关键，长时间的赶工仍然无法赶上进度，这只意味着项目有某种更深层次的问题，已经不是单开赶工可以解决的了。留意那些长时间加班的项目，他们往往在管理上存在很大问题，发现这些问题，在你成为PM时，不要犯类似错误。</span></li><li><span style="font-size: 12px"><strong>沟通无门</strong> 如果你在一个&ldquo;叫天天不应，叫地地不灵&rdquo;的项目里，那你最好省心吧。项目中沟通很重要，但总有些项目，领导的工作太忙，人就是找不到，发出去的邮件就是没人回，遇到问题就是自己扛。在这样的项目里也有一些好处，比如锻炼自己的自学能力，以及磨练意志与根性。不过这些，也都是我的自嘲。低效的沟通将导致不必要的返工，这才是我所痛恨之处。我最为恼火的一段经历是，甲方要进行变更，开了一周的会没人通知我，我的小组在这一周里完成了原计划的数个需求并进入到测试阶段，&nbsp;但这些需求均被砍掉&nbsp;。本来只有甲方告知是可以调整进度开发其它模块的，但最终演变为资源的浪费。可见，沟通是多么的重要。</span></li><li><span style="font-size: 12px"><strong>没人关心质量</strong> 因为软件构建属于专业领域，客户并不具备相应领域的知识，由于这种信息不对称，助长了软件的质量低下。我们开发的软件可以是&ldquo;低等级高质量&rdquo;的，但不能够是&ldquo;高等级低质量&rdquo;的。但是，太多的项目不在注重编码质量，这与软件构建的复杂度有关，也与整个行业的风气有关。但不管何种原因，提高代码质量仍然应该作为团队的努力方向。团队应该奖励那些，编写高质量代码的程序员。如果你的团队奖励的是那些，&ldquo;BUG杀手&rdquo;（每天修改上百个BUG），而冷落那些缺陷检出数量很低的程序员，那么，你的PM是个不懂技术的，至少我本人认为，任何有技术背景的PM都应该奖励那些正在保持职业操守，认真对待需求，保证代码质量的程序员。他们为项目付出了更多，更多的异常处理， 更多的测试调试，更多的检查，更多的重构，虽然他们的进度并不快，但他们引人的缺陷数量很少。每个做过开发的人都会在质量和进度上做出取舍，而我敬佩那些选择质量程序员，因为他们才是真正拿开发当事业的人。在此，向所有努力提高代码质量的程序员致敬！</span></li><li><span style="font-size: 12px"><strong>没人为缺陷买单</strong> 没人为自己的成果负责。需求产出了低质量的文档，设计没有进行充分的迭代，开发可以怎么简单怎么写，测试可以随意测测，没人为自己的成果中的缺陷买单，除了项目经理，他为项目承担唯一责任。当项目组所有人员都在混时，就是在给自己挖坑。这种缺陷的堆积，会像放射性元素在食物链中的堆积一样，早晚项目会因此而崩溃。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>过高的离职率</strong> 这个是最明显的&ldquo;臭味&rdquo;，这说明我们的同行已经在这里无法忍受了。它所带来的恶略影响不光体现在可用资源的减少，还体现在对成员士气的极大影响。如果不及时改善，这将是一个非常恶性的循环，当往一个进度落后的项目中添加资源只会使进度进一步落后，而非正离职导致必须补充新的资源，资源从入职到培训都会对对团队产生震荡，并降低现行团队的生产力。一个频繁处于形成阶段的团队，很难要求其有什么凝聚力，团队问题将会凸显，尤其是在沟通上，在项目忙的时候很少能照顾到新人。花费在对新人进行培训，和与其沟通上的时间，很可能得不偿失。</span></li><li><span style="font-size: 12px"><strong>团队中的不良情绪</strong> 不同团队开始扎堆并相互敌视，例如开发组认为设计组是一帮搞业务的白痴，根本不懂编程；测试组认为开发组的人就是垃圾，BUG提交了多少便还是无法关闭；PM开始抱怨，自己的成员不配合；成员开始抱怨，PM是个纯管理没资格指挥内行做事。等等，诸如此类的怨念会在团队中积累，并以某个导火索为契机爆发。面对现实吧，至少，我远没有自己想象的那样高尚。我承认我曾经会和别的程序员说：&ldquo;你看XX他们写的代码...什么呀...&rdquo;，这样的话。在过去我也吐槽过别人代码，这种做法是错误的，我为此表示歉意。现在，如果有必要，我会说代码有缺陷，但绝不会说他的代码不好。我希望，我们能彼此尊重。对于技术人来说，不尊重他的成果就是不尊重他的人，所以我还是建议PM在管理工作中，多用&ldquo;缺陷&rdquo;，少用&ldquo;不行&rdquo;、&ldquo;不对&rdquo;。但是，项目中也总是有些人，靠鄙视别人的成果来彰显自己的实力。这些人，有，但很少。至少我遇到的很少，遇到过几个，让他们的话语成为你学习的动力吧。我曾经被人讽刺UI做的太丑，之后我学会了SL和FLEX；被人鄙视基础太差，之后开始阅读《CLR Via C#》；我朋友被人嘲笑过数据库设计，现在人家也开始买书深造。团队中就是这样，我们无法管住别人的嘴，但我们可以管住自己的。少说多听，一鸣惊人，乃上上之策。不要受情绪的影响，保持一个平静的心。</span></li><li><span style="font-size: 12px"><strong>没有项目或阶段的后评价</strong> 不对项目的阶段进行后评价，也意味着没人在乎你到底干了些什么，所有人都只是进度是否完成，而没有对完成的好坏进行评价。这也意味了，仅靠做好你的工作，你是无法得到领导的重视的。最终只有那些加班时间最长的程序员被领导认可。而能力强，口碑好的成员也只能在团队和客户中间留下传说。</span></li></ul><p><span style="font-size: 12px"><a name="szzk"></a><strong><span style="font-size: 16px">二 谁在造坑？</span></strong></span></p><p><span style="font-size: 12px">　　</span><span style="font-size: 12px">软件项目涉众众多，造坑的多为项目实施团队内部，而究其原因也是多方面的，但是始终离不了项目的四个维度&mdash;&mdash;时间、范围、成本、质量。很多时候客户并不具备软件项目的实施经验，而实施团队为了迎合客户意愿，也会多多少少的在这四了维度上做文章。资源、时间不足，轻质量重功能，往往成为造坑的契机。所以，不用怀疑，造坑的往往是我们自己。很难理解，真正挖出大坑的人，最后也是填坑的人。一个人很容易被外部事务所左右，就如&ldquo;同假的多了，真的到成假的了一样&rdquo;，多数人不愿意在一个新环境中表现得特立独行。但也有老的程序员对我说过：&ldquo;当别人做错了，你就不要跟着去做！&rdquo;所以，我认为工作就是工作，不需要我们在其中融合多少兴趣，也不要求我们有过多的付出，但对于工作的成果则要求我们认真的对待。俗话说：&ldquo;拿多少钱，办多少事！&rdquo;如果多少有些团队意识，能够对自己的工作负责，那至少在意识上，我们能给自己少造些坑。</span></p><p><strong><span style="font-size: 16px"><a name="rhmk"></a>三 如何免坑？</span></strong></p><p><strong><span style="line-height: 18px; font-size: 14px">（一） 清除盲区</span></strong></p><p><span style="line-height: 18px; font-size: 12px">　</span><span style="line-height: 18px; font-size: 12px">　以下观点，仅是我对软件项目中一些错误认识的归纳：</span></p><ul><li><span style="line-height: 18px; font-size: 12px"><strong>写出能用的程序就行啦！</strong>&nbsp;我们应该首先清楚我们做的是什么，一个成熟的团队产出的可交付成果应该包括软件编程产品，相关文档，项目实施过程中的经验教训已经其它一些非形式的成果（培训）。这里，我们必须清楚的认识到，我们所开发是是编程产品，而不是我们个人的技术实践或大学的毕设。对于编程产品，我们必须认识到，其是产品级别的，必须保证质量，必须提高用户体验，必须考虑系统的诸多特性或维度。这一过程远比我们自己写个程序要复杂的多。设计需要不断地进行迭代；开发人员需要遵守严苛的规范，编写大量的注释和大量的异常处理；测试人员需要不断地进行各种重复测试，但是正是这种全局的规范，全体团队的不懈努力，才保证了我们的编程产物可以称之为产品。所以，一定要明确，我们要完成的是一个产品，而不是一个毕业设计，它不是一个人的技术实践，而是整个团队倾注精力去完成的最佳成果。我们可以轻松的实现客户的某些需求，但需求背后的某些东西，需要我们认真对待，比如安全性和性能等。实现功能的程序谁都会写，而写出高质量的程序的才是真正的艺术。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong><strong>尽快开始编码吧</strong>&nbsp;！ </strong>软件构件是一个精心设计的过程，其前期准备十分重要。在后期修复缺陷的成本要远远高于前期。因此，在项目执行前，前期的规化十分必要。在前期每发现一个缺陷，都会为后期节省大量的成本。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>需求怎么变了！</strong> 没有不变的需求。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>进度落后了就招人呗！</strong> 这是种典型的错误认识，《人月神话》中已经说明的很清楚了&mdash;&mdash;往一个进度落后的项目中注入资源，只会使进度进一步落后。虽然，这本著作成为PM必读之作，其思想也被业界所广泛认可，但是，还是会有很多管理者单纯的认为，通过注入资源能解决问题。对于这些人，只能让实践来检验真理了。</span></li><li><span style="font-size: 12px"><strong><span style="line-height: 18px">软件质量保证是测试的工作！</span></strong><span style="line-height: 18px">这是一种逃避责任的说辞。如果把代码质量比喻为减肥，那么测试无疑是一个磅秤，减肥工作还是要有开发人员来完成。所以，不要将代码质量都寄希望于测试工作上。即使是大规模的用户测试，其错误检出率也不足五成。而真正挑起代码质量重担的是代码审查。</span></span></li><li><span style="font-size: 12px"><strong><span style="line-height: 18px">程序员你8小时就写了这么点代码？ </span></strong><span style="line-height: 18px">让开发人员将全部时间都花在编码上是不可能的。开发人员需要时间预读文档，需要与相关干系人进行沟通，需要花时间来搜索资源。此外，可能还需要编写文档，参加会议，培训以及处理个人事务等等。这些时间都会无情的夺走编码的时间。程序员大约有近似20%的时间甚至更多会用在与编码无关的事情上（不算上班或聊QQ），所以不要错误的以为每个程序员每天能写8小时的程序。</span></span></li><li><span style="line-height: 18px; font-size: 12px"><strong>你今天写了这么多行代码真有效率！</strong> 编码不是在扫地，比谁扫的面积大。不能单纯用行数来评价开发人员的工作量。评判的标准应该结合模块的复杂度，编码的缺陷检出量以及最终交付时可用代码的比例（实践表明，我们报废了大量的无用代码）。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>他今天把自己100多个BUG都改了，我们得在组里表扬下他！</strong> 在我看来这样的领导不跟也罢，这就是让人相当无语的行为。好的开发者在提交测试前，觉得会对自己的代码进行走查和调试，甚至使用单元测试工具，因此其代码的缺陷检出量很小。这样的程序员，才值得被表扬。而那个一天改了自己100多个BUG的人，作为管理者应该想想，流程哪里错了，需要进行改进。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>设计我来定，开发你闭嘴！</strong> 这样的例子也不少，这种做法有一种听起来非常合理的理由&mdash;&mdash;保证项目架构的概念完整性。其解释为，如果将设计人员从开发人员剥离，那么就可以将架构的概念完整性统一，因为设计人员的数量比开发人员是数量要少的多，更容易统一认识。而这样做的项目组，也默认地认为设计组的技术实力要明显高于开发组。他们往往从开发组中选择优秀的设计人员到设计组，但也会有走眼的时候。其一，硬手没有被提拔。这时候多半是硬手对设计不满，并对团队管理层产生质疑，并想法设法进行沟通。如果处理的好，可能硬手会被重视，如果沟通无门，那之后，可能会充斥着抱怨和不满，以及人际关系的恶化。有些强硬些的可能会选择拒绝不合理的设计或更为极端的是离职。走眼的另一种情况是，挑的人干不了设计。这样往往就是让他锻炼，而不是撤换（彼得原理&mdash;&mdash;每个人都会被晋升到他不适合的岗位）。这就郁闷到极点了，设计者将会与相应的数名开发人员进行一场旷日持久的暗战。其中，已经不只是个人的抱怨，甚至会演变成成员集体的士气低落，并最终促成小组的重组。我认为，有必要将开发人员纳入设计活动。应该参考开发人员的意见，其原因有三：其一，开发人员对实现相当熟悉，往往发现设计中的不足；其二，通过授权开发者参与设计，能让其感受到认同感，提升其参与项目的欲望，和责任心；其三，让开发参与设计，可以对设计人员进行储备，在需要时作为备选资源使用。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>客户（领导）说必须完成，我也没办法！</strong> 这就是&ldquo;领导一句话，劳动人民跑断腿！&rdquo;这是非常典型的加班借口。软件构建过程如同耕种，你每次只处理它的一小部分，一点一点的加到整个系统，使系统一点一点的&ldquo;生长&rdquo;。这也暗示了，工作应该按部就班，正如春种秋收一样，各个环节有强硬的逻辑存在。所以，我们必须学会对不合理的要求说&ldquo;不&rdquo;。这里并不是说要拒绝客户的需求，而是指应该向客户说明情况并提出相应的备选方案以供参考。例如通过通过削减范围来达到按时完工的目的。PM需要向客户说明情况，并向其提供几套可行的解决方案，以促成项目向良性发展。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>我是领导我来排进度！</strong> 工作进度的安排不能是领导的单方决策，而应该参考做了解这项工作的人的意见。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>系统上线了，项目就算结束了！</strong> 只有当可交付成果成功移交，项目进行的相应的收尾工作，项目的经验教训文档被总结和归纳，一个项目才算真正意义上的完成。</span></li></ul><p><strong><span style="line-height: 18px; font-size: 14px">（二） 参考建议</span></strong></p><ul><li><span style="line-height: 18px; font-size: 12px"><strong>做好前期准备</strong> 前期准备很重要，如果在开始构建之前认真的地进行适当的准备活动，那么项目会运作的良好。充足的准备防止我们制造一个错误的产品。前期工作的好坏，多少会为这个项目的成功和失败打下基础。即使进入构建阶段，如果我们发现前期工作做的不好，也完全有理由退回去。前期准备工作和核心目标就是降低风险&mdash;&mdash;一个好的项目规划者能够尽可能早地将主要的风险清除掉，以使项目的大部分工作能够尽可平稳地进行。目前，对后期影响最严重的风险是糟糕的需求分析和项目规划，因此准备工作就倾向于集中改进需求分析和项目规划。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>预先行其事，必先利其器</strong>&nbsp;用软件武装团队提高生产效率，例如：版本控制，错误跟踪，信息发布，自动发布，CASE工具，调试工具，测试工具，文档管理，代码生成工具等等。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>分析项目类型，在管理和构建之间找寻平衡</strong>&nbsp;商业系统、使命攸关的系统、性命攸关的系统在整个项目阶段具备不同的控制粒度。需要根据项目的具体类型来确定管理的严谨程度，避免&ldquo;过度控制&rdquo;或&ldquo;控制不足&rdquo;。</span></li><li><span style="font-size: 12px"><strong>需求必须被冻结</strong> 需求必须被冻结，如果需求不能冻结，那么谁来了都没有用。再强的团队也无法完成一个无尽的任务。</span></li><li><span style="font-size: 12px"><strong>变更必须走流程</strong> 正确应对变更，变更并不可怕，可怕的是失控的变更。以下建议希望对读者有所帮助：</span></li></ul><blockquote><p style="text-align: center">&nbsp;<strong style="line-height: 18px; font-size: 12px"><span style="font-size: 14px">在构建期间处理需求变更</span></strong></p><div class="postBody"><div id="cnblogs_post_body"><ol><li><span style="font-size: 12px">核对需求，评估质量：如果需求不够好，停下来，把它做好再开始。</span></li><li><span style="font-size: 12px">确保每一个人都知道需求变更的代价：让客户知道需求办更并不像在Excel上进行几个修改那样容易，&ldquo;进度&rdquo;和&ldquo;成本&rdquo;是你最有力的武器。</span></li><li><span style="font-size: 12px">建立一套变更控制程序：固定的变更控制程序让你知道在什么时候处理变更，让客户知道你会处理他们的提议。</span></li><li><span style="font-size: 12px">使用能适应变更的开发方法：迭代与增量。</span></li><li><span style="font-size: 12px">放弃这个项目：如果以上提议没有一条奏效，需求变更极其频繁，那么，评估你的项目，考虑放弃它吧，继续下去你只会越陷越深。</span></li><li><span style="font-size: 12px">注意项目的商业案例：性价比，没必要满足超出项目成本的需求。</span></li></ol></div></div></blockquote><ul><li><span style="line-height: 18px; font-size: 12px"><strong>关于加班</strong> 做IT的加班是很正常的，但加班要加的有意义，而且不应该长期加班。必须针对关键路径上的工作进行赶工，而不是做些无法加快整体进度的工作。而且，应当安排调休，而不是支付加班费。其主要原因也是我不赞成加班的原因&mdash;&mdash;疲劳更容易引人缺陷。加班无疑会使人疲劳，每个人都想尽快结束手上的工作后回家休息。在长期疲惫的情况下，人员的工作效率会下降，士气会低落，非正常离职率增加，最重要的是疲惫的团队很难保证软件的质量，缺陷在不知不觉中引人，在后期无疑会为此付出代价。项目的总成本和周期，都会随着引人缺陷的数量的增加而倍增，而且发现的越晚越严重。</span></li><li><span style="font-size: 12px"><strong>做好版本控制和配置管理&nbsp;</strong>版本控制和配置管理是必须有的，即便是再小的项目也不能忽视，必须加以重视，一旦版本混乱，多多少少会对构活动造成影响。所以，平时不要偷懒，管理好每个基线。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>授权的好处</strong> 授权好处多多，包括：一，减少管理者工作量；二，对人员有意识地进行锻炼，培养储备人才；三，提高人员对项目的参与度，从而提高士气。</span></li><li><span style="font-size: 12px"><strong>乐观管理与悲观管理</strong> 乐观与悲观完全取决于人的性格，一般来讲多数倾向于乐观，应该清楚这两种性格在项目中的优势与劣势。我本人倾向于悲观，可能是性格使然，但悲观的管理至少不会误事。乐观管理的优势在于，很容易营造气氛，擅长给客户或领导描绘一个美好的未来。这种作风，前期很舒服，但后期可能要吃苦了。乐观管理容易出现的问题是对风险的预计不足，不能预留充足的缓冲时间，没有准备足够的预防措施。其表现就是，在进行进度计划时，总是认为今天的问题今天可以解决，已经修复的BUG将不会再次出现，用户需求是最后一次变更，等等诸如此类的乐观想法会使管理者蒙蔽双眼，而没有做足风险应对，其结果就是不管怎么加班就是赶不上进度，因为进度计划被设计为最顺利的情形，而不是现实场景。悲观管理的好处是，为潜在风险做足了准备。但悲观管理有一个非常大的缺陷，就是&ldquo;过度控制&rdquo;，可以比喻为&ldquo;疑心病&rdquo;（小心的都有些病态了）。其表现是为：按照之前的措施，发现遗漏了一个问题，那么悲观管理者会在之前措施基础上增加新的保障措施，然后又发现遗漏了一个问题，之后会继续追加保障措施。乍看之下没啥问题，因为是在不断地进行过程改进，但问题出在保障措施的增长速度过于惊人，称其为&ldquo;疑心病&rdquo;一点也不为过，悲观管理者容易在很小的地方施加过多的控制，造成人日的浪费，而忽略掉本应该关注的更为重要的问题。不管那种性格的管理，清楚自己的弱点总是好的。</span></li><li><span style="font-size: 12px"><strong>有效的沟通，不要踢皮球</strong> 软件项目因为其本身的复杂度和涉众众多，所以更加需要沟通。沟通问题是所有大型项目都共用的问题，在大多数团队中往往也不认为沟通是个问题。但我还是想请读者认真对待沟通，比如邮件。邮件可以回复的慢，但请回复邮件。当我在一个连发出的邮件都没人回复的团队中工作时，除了无法解决问题，让我感受到的只有无奈以及冷漠。</span></li><li><span style="font-size: 12px"><strong>客户是我们的朋友 </strong>把你的客户当成朋友，客户是我们做重要的资源之一。在每个客户背后往往隐藏着更多潜在的客户。我们必须清楚，客户作为非专业人士，其可能并不理解我们的工作，在项目执行阶段产生摩擦是难免的。但是，这些都不能成为我们迁怒客户或故意在工作中放水的借口。即便是为了项目能成功收尾，我们也必须维护好与客户的关系。</span></li><li><span style="font-size: 12px"><strong>不要超前设计，不要项目镀金</strong> 超前设计和项目镀金都是不可取的，因为他是在浪费资源。满足需求以外的东西，不会对你的项目有任何好处，但是却可能引人缺陷。</span></li><li><span style="font-size: 12px"><strong>总结经验教训</strong> 必须对阶段进行经验教训总结，没有什么比这些收获更有价值。这样文档就是组织的资产，是以后类似项目的参考和依据，并在持续优化方面发挥更为重要的作用。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>不要让会议和文档拖了团队的后腿</strong>&nbsp;&ldquo;当船快要沉的时候，我们需要的是一个发号施令的领袖，而不是开会。&rdquo;软件项目的核心问题是降低复杂度，越是复杂的项目就越需要沟通，但别让开会拖了我们的后腿。没有必要的会尽量少开或不开，要常开会，开小会，每次会议就几个相关干系人碰头沟通下就可以了，没有必要扩大为全员参与。冗长的讨论应该适时的终止，毕竟会议室上只能做出决策，而解决问题还得在会下。所以我认为应该精简那些冗长的会议，别然开会成为我们的工作。此外，要时刻谨记客户最终需要的是可以良好运行的软件产品而不是华丽的文档。所以，文档要恰到好处，写的再漂亮的文档没有完备的系统也不过是废纸一堆，别丢了西瓜捡芝麻，可以正常工作的软件才是我们的工作重心。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>核对表的你的好助手</strong>&nbsp;就像飞机工程师在检查飞机时使用核对表一样，软件项目也可以大量使用核对表。核对表可以帮助检验文档的质量，降低缺陷数量，以及改进项目管理。好的核对表，是你工作中的好助手。</span></li><li><span style="line-height: 18px; font-size: 12px"><strong>小范围的受控好过大范围的失控</strong> 要注意控制的粒度，事无巨细。根据项目规模，人员构成，要采用不同的控制粒度。评估可控范围，并不是控制越广越好，控制不了就是失控。 对无暇顾及的地方授权别人管理是个可行的做法。&nbsp;即便是小范围是受控，也好过大范围的失控。一个失控的项目，谁也不知道其会走向何方。</span></li></ul>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2312</link>
<title><![CDATA[项目经理的“势能”培养 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Tue, 10 Apr 2012 05:19:52 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2312</guid> 
<description>
<![CDATA[ 
	<p style="text-indent: 21pt"><span style="font-family: 宋体">项目经理的&ldquo;势能&rdquo;培养</span> </p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">我很早之前就听说过，做为一个项目经理，至少要在公司工作两年以上，且年龄不小于三十岁。我当时还年轻，对这两点很不屑。而现在，我却很理解。在公司工作时间短，对人员不熟悉，将很难横向协调资源；年纪过轻则不够沉稳、练达，难以实现快速沟通。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">作为</span>IT<span style="font-family: 宋体">企业，很多项目经理都是由基层做起的，技术好、经验丰富、熟悉行业知识。作为项目经理本人，也觉得自己对团队的领导能力勿庸置疑。并不会认为自己沟通上会有问题。在这里，我也不想讲什么大道理，只举例子、讲故事。</span></p><h3><span style="font-family: 宋体">举一个例子。</span></h3><p style="text-indent: 21pt"><span style="font-family: 宋体">去财务报帐，出纳说票贴的不对，公司财务制度上要求餐费与交通费分开贴，退回来重贴。贴完让出纳整好单子，找老总签字，老总出去了，没办法，只好到明天。而到明天，老总回来，自己却要出差了。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">好不容易等老总签了字，拿到财务室，出纳说，财务上没有钱，票先放这里，等两天吧。一拖好几天，票压一堆报不了，项目中各项开销还得支出，严重影响工作情绪。这里要说明一下，财务上没有现金是很正常的，当然也不是完全没有，还是要留一些费用应对日常开销的，至于给不给你，就看财务的心情了。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">如果换一个场景。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">发票拿到财务室，出纳一看不合格，直接开涮：&ldquo;你怎么搞的呀，刚公布的财务制度都没看吗，整天忙啥哩？算了，算了，放这吧，反正老总不在，等会儿还是我整一下吧，指望你干这活也没指望。你该干啥干啥去吧，下一回再这样我就给你扔出去。&rdquo;</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">过两天，财务电话过来：&ldquo;你的钱还要不要呀？公司有回款了，要拿钱的赶紧啦。&rdquo;然后项目经理直接到财务签字拿钱，发票老总已经签过字，整个流程出纳都帮做了。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">一个空降的项目经理与一个老员工项目经理，在协调资源时，差别是很明显的。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">为什么空降的项目经理不能很好的协调资源。因为他跟同事不熟悉，他的团队会很支持他，其它人员则不一定。人家只给你照章办事，或许不会影响你工作，但同样不会推动你的工作。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">而老员工项目经理，与各部门人员都很熟悉，老总也很信任他。这样处理工作就比较顺利，例如前面说的，出纳帮助你贴票，然后替你拿到老总那里，老总出于对项目经理与出纳的信任，就直接把字签了。项目经理出差回来签字就能领钱，效率高多了。</span></p><h3><span style="font-family: 宋体">再举一个例子。</span></h3><p style="text-indent: 21pt"><span style="font-family: 宋体">项目临近结束，各个功能都差不多要做完了，项目完成进度也被标到</span>90%<span style="font-family: 宋体">。而项目经理心里很清楚，后面的修修补补，测试、调整会占用大量时间。公司项目管理不够完善，很多隐性的东西都无法显现出来。而客户此时又提出了一些新的要求，急切要完成。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">如果告诉老总说，现在还需增加三个月的工作时间，老总肯定不同意，因为既然都完成</span>90%<span style="font-family: 宋体">了，剩下的工作还不加把劲在两星期内搞定，竟然还要增加三个月，挨批是难免的。如果给客户说，实在没有精力做新功能，客户要挟说，不做就不验收。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">项目经理谁也不敢得罪，心里明白问题关键，却不知道该如何说服别人。只有硬着头皮往下做。结果项目延期，质量下降，勉强验收了，还有一大堆问题。最主要是因为工作强度加大，加班加点，透支团队成员工作激情，项目最终结束后，大批成员离职。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">而如果项目经理换种思路。首先向团队成员灌输&ldquo;行百里者半九十&rdquo;，越到后面，繁杂琐事越多，越不能放松冲刺。要尽可能保持成员的工作积极性。一方面，向公司说明情况，通过项目管理的知识来讲解问题的具体原因，尤其是项目收尾管理，并不是代码写完就是项目结束，还有很多事情要做。总之，摆事实讲道理，积极向公司申请资源，尤其是宽限项目时间（此时单独强调增加开发人手并不明智）。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">再一方面，与客户方负责人沟通，甚至私人宴请以促进感情。尽可能把一些新功能放到项目运营维护中来实现，或是项目二期中实现。如果客户仍然坚持，则最好说服他降低质量要求，在验收时放自己一马。向其承诺，在运维中提升质量。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">整个情况要向团队成员说明，争取成员的理解与支持。也要向公司说明情况，尽可能多申请些额外福利。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">从这个例子中可以看出，项目经理所做的工作，都不是&ldquo;高科技&rdquo;的，非技术的却又是重要的。针对不同对象，例如团队成员、公司高层、客户方负责人等，分析利害与关注点，权衡利益，各个击破。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">一个年轻的项目经理与一个老成的项目经理，在处理这些事情时，风格会大不相同。就像上个例子，客户方负责人一般也不会太年轻，三十来岁才会担当个负责人，如果项目经理太年轻，阅历浅薄，则不太容易与对方平等交流。即便他明白道理，也很难影响他人支持自己工作。</span></p><h3><span style="font-family: 宋体">讲一个故事</span></h3><p style="text-indent: 21pt"><span style="font-family: 宋体">很多年前，我还年少的时候，喜欢下象棋，在学校里基本上我能下赢的，我总能下赢，我下不赢的，总也下不赢。不得其解，也慢慢懒得操练了。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">后来有次学校搞业余活动，有个老师是省象棋协会的，组织了一节棋课。我去晚了，只听了半节。大致意思是讲，下棋要讲全局观，要有战略，例如中局五种策略，中局成杀、不成杀则优、不占优占先、不占先则多子、不多子则求和。还有什么炮破士、马破相、残局炮归家等等。却没有讲如何下棋，课堂上也没有摆个象棋，或是什么棋谱。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">我并没有把这些当回事儿，之后也很少下棋。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">又过多年，毕业后同学聚一起，闲来无事，与一个同学下了两盘。刚开始，他问我这两年有没有下棋，我说没有。他调侃我，&ldquo;那你以前下不赢我，今天你也难赢了&rdquo;。我也笑着认同，反正只是玩玩，何必认真。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">可是一开局，他就傻眼了，一直处在下风，且每局必输。他很吃惊，我也很吃惊。之后我认真思考了这件事，觉得是那节棋课影响了我，人的思考能力、计算能力都差不多，而思维方式不同，结果也会有很大不同。他看到的是&ldquo;棋&rdquo;，我看到的是&ldquo;局&rdquo;。决定胜败的不是棋艺。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">又过了几年，我已经不再年少，但还算年轻吧。有一次找一个朋友玩，正好他的一个朋友也在，吃完饭没事儿做，恰巧有副象棋，就与他的朋友下了几局。他们都比我年龄大，已经三十多岁了。不过我也没有放在眼里，自以为水平相当可以，三局我两胜，颇为自得。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">等他走后，我朋友问我：&ldquo;他水平怎么样呀？&rdquo;我带着些&ldquo;谦虚&rdquo;，洋洋自得：&ldquo;他水平挺可以的，我差点就输了，还好我三局两胜，略胜那么一点点。&rdquo;</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">我朋友听完哈哈大笑：&ldquo;你知道他是干吗的吗？他是卖保险的。卖保险的吗，任何人都可能是他的潜在客户，他自然不会去赢你，不光让你赢，还要让你赢得有面子，这才是高手。他原来是在象棋协会的，论象棋，那叫牛&times;死了。&rdquo;</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">我听完之后，惭愧至极。我关注的是&ldquo;棋局&rdquo;，人家所关注的，则超脱棋局之外。眼界不一样，看到的也不一样，操控点也不一样，输赢已经不重要，重要的是输与赢，哪个更有利于自己，然后才是&ldquo;如何去输&rdquo;与&ldquo;如何去赢&rdquo;。棋局只是一个棋子。决定成败的不是棋艺。</span></p><p style="text-indent: 21pt"></p><p style="text-indent: 21pt"><span style="font-family: 宋体">我讲这个故事，是想说明，一个项目经理，对自己操作的项目要有全局观；而且，视角不能仅限于项目本身。明确自身定位，了解外部环境，才能最大成度影响到整个&ldquo;局&rdquo;中的各个元素，而这个影响力，就叫&ldquo;势&rdquo;。可以这么说，你明确的势力范围，可以只是你的团队，但你的影响力却不能仅限于团队本身。</span></p><p style="text-indent: 21pt"><span style="font-family: 宋体">做到这些，容易吗？当然不容易。如文章开头所说，&ldquo;做为一个项目经理，至少要在公司工作两年以上，且年龄不小于三十岁。&rdquo;这样，才有可能会做得好一些。</span></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1961</link>
<title><![CDATA[敏捷开发的原则]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Sat, 03 Mar 2012 07:58:19 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1961</guid> 
<description>
<![CDATA[ 
	<p>最近要在公司做的一次技术分享，实际上敏捷实践不到一年，接触敏捷还是从实习公司的一次敏捷培训开始，从那个时候起便深深地被影响。我记得那次培训是2011年的元旦假期，距今也有一年多了吧，期间也翻阅了一些敏捷思想的书籍，也有自己的一些思考和总结。原来是什么样子的，我不知道，写出来分享，记录和研究。阅读本文，也可以直接下载分享的PPT。</p><p><strong>【我总是那样做】</strong></p><p>大多数人习惯使用右手来操作手机（大多数），那如果现在颠倒过来，使用左手会发生什么事情？一部分人会不习惯，发送短信也会很变扭，甚至经常性打错字。总之，没有我们习惯的右手来得顺利。</p><p>为什么颠倒了习惯，我们会笨手笨脚？</p><p>很难有正确的答案来回答这个问题，当然这样做的目的也仅仅是为了使大家关注这个话题。我们平常的经验和习惯帮助我们建立了一套可以完成一项任务的体系，除非必要情况，我们很少会采用另外的方式来完成目的。当然，目的为导向的思想会告诉你这没有意义，我已经知道一种可以达到目的的方法，为什么我需要学会第二种？我想我没有办法反驳这点，这也不是我的目的，现在的问题是：为是为什么会笨手笨脚？我是因为我的固有的思维方式和习惯（你是什么原因？）。我从来没有想过可以使用左手来使用手机，我不习惯这么做，所以采用这种方式我做不好。可能你会见到过这样一些人，他们明明是右撇子，却偏偏使用左手来使用筷子，甚至有些人左右手都可以使用筷子，如同足球运动员左右脚都可以踢球一样。更多的方法可以帮助我们更好地解决问题，我想这是有意义的。</p><p>是什么在阻碍我们尝试新方式？</p><p>记得做奥数的时候，我们为找出解决问题的办法而绞尽脑汁，当然也会发现，总有那么一些人，他们明明已经有解决问题的办法了，但是他们却期望找到一个更好的方法。今天，我们坐在这里，思考如何能够提高我们的工作效率，使自己成为一个伟大的&ldquo;代码设计师&rdquo;，那么面对我们每天要完成的任务，我们是只求解决，还是力图完美？哦，能够完成任务的人并没有什么不好，那么是什么导致了我们有不同的思维方式？是什么让我们对任务有不同的态度？</p><p>如何避免旧的习惯对我们学习新事物的影响？</p><p>变的&ldquo;无知&rdquo;，现在，请扔掉我们以前的经验，我们都是一群渴望知识的小学生。当然，不要担心，在分享之后，我会把它们还给你们的。</p><p><strong>【穿越到过去】</strong></p><p>2001年之前，大型软件的开发采用&ldquo;瀑布&rdquo;过程，经常出现软件交付延期的情况。瀑布过程依赖太多的假设条件，其中有些风险过高，如：假设集成能够顺利进行、项目的复杂程度是可以控制的、计划是可以被遵循的。然而，项目的计划似乎并未考虑上述可变因素，风险随时出现。</p><p>用什么来保证软件质量和开发周期？</p><p>一些软件开发者通过经验总结如何保证软件质量和项目进度，其中一些解决方法是：</p><p>1. 依靠出众的个人及其经验</p><p>2. 总结犯错并建立约束条件</p><p>当有新的错误出现时，便增加了新的人为控制和建立新的约束条件。</p><p>最终，导致约束条件相互冲突、预算超支、进度反而无法保证、程序复杂业务凌乱。</p><p>2001年，业内一些软件聚在一起，概括了一些能够让软件团队具有快速工作、应对变化的价值观和原则，他们称自己为敏捷联盟。随后的几个月，他们创建了一份声明。这份声明也就是敏捷联盟宣言，我们称之为：敏捷原则。</p><p><strong>【敏捷联盟宣言】</strong></p><p>它包括：</p><p>12条原则</p><p>4个价值观</p><p>目的是：建立易维护的软件代码，提高团队工作效率，保证最终软件符合需求，保证项目按时完成</p><p style="text-align: center"><img class="insertimage" src="attachment.php?fid=670" border="0" /><br /></p><p><strong>【价值观】</strong></p><p>1. 个体和交互 比 过程和工具 重要</p><p>2. 可以工作的软件 比 面面俱到的文档 重要</p><p>3. 客户合作 比 合同谈判 重要</p><p>4. 响应变化 比 遵循计划 重要</p><p></p><p>人是获得成功的关键因素，如果团队中没有优秀的成员，那么使用再好的过程也无法拯救失败的项目，但是不好的过程却可以使优秀的成员失去效用。优秀的成员如果没有良好的沟通，从而作为团队来工作，那么即使拥有一批很优秀的成员，也会失败。</p><p>合适的工具对于成功来讲非常重要，如：编译器、IDE、SVN等，但是跟成员相比，我们认为人更重要。</p><p>没有文档的软件是一种灾难，代码并不是传达系统原理和结构的理想媒介。团队更需要编制易于编写和阅读的文档。但是应当适当的控制文档的数量，毕竟可以最终工作的软件是我们最终想要的。当代码更新时，文档的更新问题也是一个让人头疼的事。</p><p>软件外包公司经常会面临这样的客户：客户扔下一笔钱，写下自己期望的软件的样子，然后离开直到截止日期的时候，询问软件是否完成。当他看到软件的样子的时候，他经常会惊讶：这不是我想要的！合同谈判无法帮助开发人员理解客户的需求，通过和客户更多的交流来帮助开发人员理解客户的需要，从而开发出不偏离客户需求的软件。经常地保持沟通是一项重要的措施来帮助软件符合需求。Scrum要求每个迭代开发出可用的软件，同时用这个开发后的软件与客户交流，如果客户发现问题可以即使修改。</p><p>应对软件环境的变化是敏捷开发的一个重要的特性。尤其近年的互联网快速发展，互联网产品的生命周期相对较短，加上各个公司的竞争，谁能尽快推出自己的产品，谁就能走在市场的前端。一个计划一年的计划，在软件开发完成之后可能就已经跟不上时代的步伐。敏捷团队欢迎变化，敏捷设计也是针对变化而出现，传统的软件开发担心需求的变更，敏捷开发将需求控制到短期内需求稳定。</p><p>一个好的策略是，做两周内的详细计划，做3个月的粗略计划。</p>【1. 目的：使客户满意】 <p></p><div>&bull;Our highest priority is to satisfythe customer through early and continuous delivery of valuable software.</div><div>&bull;我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</div><div><br /></div><div>&ndash;初期交付的系统中所包含的功能越少，最终交付的系统的质量越高</div><div>&ndash;逐渐增加功能的方式和经常性的交付系统，可以增加软件的质量</div><div><br /></div><div><img class="insertimage" src="attachment.php?fid=671" border="0" /><br /></div><p></p><p></p><p>MIT Sloan管理评论杂志刊登的一篇论文，发现了很多对于最终系统质量有关系的实践，其中一个实践表明：尽早地交付具有部分功能的系统和系统质量之间具有很强的相关性。论文中指出：</p><div>1.初期交付的系统中所包含的功能越少，最终交付的系统的质量越高。</div><div>2.逐渐增加功能的方式和经常性的交付系统，可以增加软件的质量。</div><p></p><p>明确了我们软件开发的目的：使客户满意</p><p>每次开发一个功能的创建或改进，并与客户交流，若得到客户确认，则可以直接作为最终产品的功能直接使用；若客户有提议，则按照在此基础上进行改进。</p>这样做的好处在于，它帮助软件团队永远不偏离需求和客户，围绕着需求和客户，同时也保证了开发出的产品是客户满意 <p>【2. 态度：欢迎需求变更】</p><p>Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.<br />欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。<br />要求：软件保持灵活性<br />要求：团队成员学习能力<br /></p><p><img class="insertimage" src="attachment.php?fid=672" border="0" /><br /></p><br /><p>这是一个关于态度的原则，声明敏捷团队是不惧怕变化的团队。<br />团队认为改变需求是好的事情，因为改变意味着团队可以学到更多。<br />同时，这也是对敏捷团队和软件本身的要求，意味着团队成员具有较好的学习能力和软件具有很好的灵活性来应对这种变化。<br />这也是为什么敏捷开发被互联网接受的原因。<br />互联网的产品随时在变，传统的软件开发由于更新速度问题，成为创新和与时俱进的绊脚石。</p><p>【3.&nbsp;关注：客户需要的软件】</p><p>Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.<br />经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。<br /><br />交付的是软件和功能，而非文档<br />尽早地、经常性交付(2~4周)<br />可以集成运行的版本<br /></p><p><img class="insertimage" src="attachment.php?fid=673" border="0" /><br /></p><p></p><p>每次给客户提交可以运行的软件，并通过客户确认来逐步完成软件开发</p><br /><p>【4. 合作：推倒那堵墙】</p><p>Business people and developers must work together daily throughout the project.<br />业务人员和开发人员必须相互合作，项目中的每一天都不例外。<br /><br /><br />软件需要被引导<br />团队成员和客户需要关注软件进度<br />团队成员和客户能相互理解彼此想法<br /></p><p><img class="insertimage" src="attachment.php?fid=674" border="0" /><br /></p><p></p><p>有些公司的产品经理和开发人员中间相隔一堆墙，甚至有些公司的业务人员和技术人员不在同一层楼上。这导致了一些话题：</p><p>产品经理认为将这件产品的需求写明确，也发给了开发人员，而开发人员也按照自己的理解来开发产品，软件开发出来之后，</p><p>产品经理往往不解：软件怎么是这个样子的？</p><p>技术人员：这不就是你想要的样子么？</p>【5. 核心：团队成员】 <p>Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.<br />激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。<br /><br />项目成功最重要的因素：人！<br /></p><p><img class="insertimage" src="attachment.php?fid=675" border="0" /><br /></p><p></p><p>在敏捷项目中，人是项目取得成功的最重要的因素。所有其他因素被认为是次要的，如：过程、环境、文档、管理、技术，当这些东西对团队成员有负面影响时，需要对它们进行改变。</p><p>前面提到，办公室环境的&ldquo;墙&rdquo;对我们的沟通造成影响，那么需要推倒它一样，来帮助我们面对面沟通；如果传统的文档对我们造成压力，我们可以通过其它方式来简化它或者转化它为我们喜欢和接受的方式。</p><p>改变的原则：以团队成员为核心。</p>【6. 沟通：面对面】 <p>The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.<br />不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。<br /><br />文档不是默认的沟通方式，交谈才是<br /></p><p><img class="insertimage" src="attachment.php?fid=676" border="0" /><br /></p><p></p><p>敏捷项目中，默认的沟通方式是面对面的交流，而非冗余的文档。有的时候会编写文档，项目的所有信息可能不会在文档中体现。当然，这种情况适用于在稳定的敏捷团队中使用。</p><p>这里并不是赞成移除文档。在非标准的事情上建立标准是一件有意义的事情，产品经理期望通过需求文档来告诉架构师我们即将要开发的产品，架构师单纯从文档来获取需求的信息是不完全的。通过面对面的沟通可以帮助架构师更全面地了解即将要开发的产品。</p><p>然而，在一些技术交流中，文档可以作为辅助作用帮助开发人员沟通，如：接口文档、类库文档等。所有这些接口可以帮助开发人员熟悉接口标准。</p><p>对于接口的标准，一些设计原则中会有体现（这里不多做介绍）。</p>【9. 追求：技术卓越和设计良好】 <p>Continuous attention to technical excellence and good design enhances agility.<br />坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。<br /><br /><br />关注新的技术和好的设计会增强敏捷能力<br />随时准备对项目使用最好的设计<br />在当前的需求下，当前的设计是最好的<br /></p><p></p><p>高的产品质量是获取高的开发速度的关键。</p><p>尽量保证软件的简洁、健壮是快速开发的途径。所有敏捷团队成员都致力于只编写他们能够编写的最高质量的代码。</p><p>他们不会制造混乱的代码后告诉自己需要更多的时间来清理它们。如果今天制造了混乱，今天清理。</p><p>另外，它的另一个含义是：绝不过渡设计。在当前需求的情况下，当前的设计是最优的设计。</p><p>如果我们编写一个hello,world，不需要使用庞大的框架来考虑数据设计要求，除非这个helloworld是通过数据库来进行数据传递的，否则绝不会考虑对数据库的引入。</p>【10. 根本：简洁】 <p>Simplicity--the art of maximizing the amount of work not done--is essential.<br />以简洁为本，它是极力减少不必要工作量的艺术。<br /><br />不做过渡设计和华而不实的设计<br />新需求到来再考虑它（重构）<br /></p><p></p><p>使用最简单的方式来实现需求，是敏捷开发的一项艺术所在。当有更多的需求到来时才考虑如何实现。</p><p>另外，代码的质量需要另外的原则来保证：随时重构。</p><p>重构是在实现新需求的过程中，清除掉出现的冗余代码。随时重构是防止系统混乱的重要途径，常常也是一项必备技能之一。</p>【11.团队：自组织】 <p>The best architectures, requirements, and designs emerge from self-organizing teams.<br />最好的架构、需求和设计出自自组织团队。<br /><br />敏捷团队是自组织团队<br />敏捷团队是义务和责任的&ldquo;原子&rdquo;<br />敏捷团队对成员有较高的要求：自组织<br /></p><br /><p></p><p>敏捷团队是自组织团队，任务不是以人为单位被分配的，而是以团队为单位来分配。再又团队来确定完成任务的最好的办法。</p><p>作为原子，敏捷团队成员共同解决所要完成的需求。每一个成员有权利参与这个过程的所有方面，如PHP开发人员可以参与JS部分的工作等。不存在单一的成员对系统架构、需求或者测试负责的情况。</p><p>整个团队共同承担责任，每一个团队成员都能够影响它们。</p><p>另外，敏捷团队对成员的要求较高。敏捷团队的每个成员被要求成为多面手，使得他们可以做参与到任务的各个方面来。同时，在使用结队编程等团队开发方式的情况下，</p>【12.调整：定期反思】 <p>At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.<br />团队定期地反思如何能提高成效，并依此调整自身的举止表现。<br /><br />总结不足，如何解决<br />（SCRUM）反思会<br /></p><p></p><p>敏捷团队会不断对团队的组织方式、规则、规范、关系等进行调整。敏捷团队知道团队所处的环境不断变化，并且知道为了保持团队的敏捷性，必须要随着环境一起变化。</p><p>敏捷要解决的一个问题便是快速应对变化。因此，随时地对自身进行更新，是应对变化环境的一种途径。</p><p>在scrum中，每一次迭代之后会有反思会的进行，反思会总结过去一个迭代中遇到的困难，提出解决途径。</p><br /><p><strong>【对比】</strong></p><p></p><table border="0" cellspacing="0" cellpadding="0" width="922"><tbody><tr height="50"><td><p>敏捷宣言原则</p></td><td><p>我的传统做法</p></td><td><p>冲突/共鸣</p></td></tr><tr height="135"><td><p>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</p></td><td><p>实现所需功能</p><p>实现某项技术</p><p>完成给定工作</p></td><td><p>使产品经理和自己同时满意是自己的目标&hellip;</p></td></tr><tr height="135"><td><p>&hellip; &hellip;</p></td><td><p>&hellip; &hellip;</p></td><td><p>&hellip; &hellip;</p></td></tr></tbody></table><br /><p></p><br /><p>附录：</p><p>1. 《敏捷开发原则》 PPT&nbsp;<a href="http://vdisk.weibo.com/s/2SNR9" target="_blank">http://vdisk.weibo.com/s/2SNR9</a></p><p>2. 文档材料<a href="http://vdisk.weibo.com/s/2SMSc">&nbsp;http://vdisk.weibo.com/s/2SMSc</a></p><p>3. 参考资料：</p><p></p><p>《可伸缩敏捷开发：企业级最佳实践》 Dean Leffingwell， 电子工业出版社</p><p>《敏捷软件开发 原则、模式与实践》 Robert C. Martin， 清华大学出版社</p><p>敏捷宣言英文版：<a href="http://agilemanifesto.org/iso/en/principles.html">http://agilemanifesto.org/iso/en/principles.html</a></p><p>敏捷宣言中文版：<a href="http://agilemanifesto.org/iso/zhchs/principles.html">http://agilemanifesto.org/iso/zhchs/principles.html</a></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1917</link>
<title><![CDATA[从瀑布模型、极限编程到敏捷开发]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Wed, 29 Feb 2012 02:56:09 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1917</guid> 
<description>
<![CDATA[ 
	<span style="widows: 2; text-transform: none; background-color: #f8f8f8; text-indent: 0px; font-family: 宋体; white-space: normal; orphans: 2; letter-spacing: normal; color: #333333; word-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">【引自<a style="color: #004276; text-decoration: underline" href="http://zhaisj.blog.51cto.com/219066/46187">Jack zhai</a>的博客】软件开发是一种对人类智慧的管理，对人大脑思维的&ldquo;工厂化&rdquo;管理。人是有感情的、有情绪的、变化的、相对独立的工作单元，这与冰冷的机器是不可比的，所以在中国的历史上，管理人是最难的工作；&ldquo;学而优则仕&rdquo;的观点就是让最聪明的人应该选出来做官，做官就是管理人的。软件开发不仅是代码编程，而是人员的有效组织，如何既发挥人的主观能动性，避免情绪变化对工作的影响，又可以让大家有效的交流，让多个大脑的思路统一，快速完成目标呢？多年来软件企业的管理者一直在不断地探索。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">另外，有一个问题一直是软件开发管理人员的心病：软件是工具，开发的是客户业务的应用，但客户不了解软件，开发者不了解业务，如何有效沟通是软件质量的重大障碍。把开发者变成客户业务的专家是个没有办法的办法，让软件企业付出的代价也是昂贵的。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">瀑布模型、极限编程、敏捷开发是有代表性的开发模式，在对开发者、客户、最终的产品的关注上的变化，体现了软件开发管理者在管理模式上的变化。<br /><br /><strong style="text-align: center; font-weight: bold">一、瀑布开发</strong></p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">瀑布模型(Waterfall Model)是Royce在1970年提出的，他把大型软件开发分为：分析与编程，象工厂流水线一样把软件开发过程分成各种工序，并且每个工序可以根据软件产品的规模、参与人员的多少进一步细分成更细的工序。该模型非常符合软件工程学的分层设计思路，所以成为软件开发企业使用最多的开发模型。</p><table border="1" cellspacing="0" class="ln" align="center" bgcolor="#ddddd"><tbody><tr><td style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px" bgcolor="#ffffff"><img class="insertimage" src="attachment.php?fid=665" border="0" /></td></tr><tr><td class="it" align="center" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px" bgcolor="#dddddd">图1</td></tr></tbody></table><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">瀑布模型的特点：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">1、强调文档，前一个阶段的输出就是下一个阶段的输入，文档是个阶段衔接的唯一信息。所以很多开发人员好象是在开发文档，而不是开发软件，因为要到开发的后期，才可以看到软件的&ldquo;模样&rdquo;。<br />2、没有迭代与反馈。瀑布模型对反馈没有涉及，所以对变化的客户需求非常不容易适应，瀑布就意味着没有回头路。<br />3、管理人员喜欢瀑布模型的原因是把文档理解为开发的速度，可以方便地界定不同阶段的里程碑。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">瀑布模型的用户很多，也有一些反对的意见：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">第一、瀑布模型不适合客户需求不断变化的软件开发，尤其是客户的业务管理的软件，业务随着市场变化，而软件初期的设计可能已经大大变化，而后期的需求更改成本是开始的10倍基数。在ERP盛行的软件市场里，一方面市场带动需求变化，另一方面初期客户对需求描述不清楚，都为瀑布模型的使用团队带来困难。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">第二、瀑布模型是一种软件文档的开发，把开发者变成流水线上的机器，大量重复性的工作让编程人员提不起兴趣，工作很枯燥，没有激情，编程成了一种没有创意的机械劳动，这让一向以高科技为标志的高级程序人员大为恼火。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">在这种背景下，极限编程(extreme Programming, XP)带来了新鲜的空气。<br /><br /><strong style="text-align: center; font-weight: bold">二、极限编程</strong></p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">极限编程诞生于一种加强开发者与用户的沟通需求，让客户全面参与软件的开发设计，保证变化的需求及时得到修正。要让客户能方便地与开发人员沟通，一定要用客户理解的语言，先测试再编码就是先给客户软件的外部轮廓，客户使用的功能展现，让客户感觉到未来软件的样子，先测试再编码与瀑布模型显然是背道而驰的。同时，极限编程注重用户反馈与让客户加入开发是一致的，让客户参与就是随时反馈软件是否符合客户的要求。有了反馈，开发子过程变短，迭代也就很自然出现了，快速迭代，小版本发布都让开发过程变成更多的自反馈过程，有些象更加细化的快速模型法。当然极限编程还加入了很多激励开发人员的&ldquo;措施&rdquo;，如结队编程、40小时工作等。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">极限编程是一种开发管理模式，它强调的重点是：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">1、角色定位</strong><br />极限编程把客户非常明确地加入到开发的团队中，并参与日常开发与沟通会议。客户是软件的最终使用者，使用是否合意一定以客户的意见为准。不仅让客户参与设计讨论，而且让客户负责编写拥护故事(User Story)，也就是功能需求，包括软件要实现的功能以及完成功能的业务操作过程。用户在软件开发过程中的责任被提到与开发者同样的重要程度。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">2、敏捷开发</strong><br />敏捷开发追求合作与响应变化。迭代就是缩短版本的发布周期，缩短到周、日，完成一个小的功能模块，可以快速测试、并及时展现给客户，以便及时反馈。小版本加快了客户沟通反馈的频率，功能简单，在设计、文挡环节大大简化。极限编程中文挡不再重要的原因就是因为每个版本功能简单，不需要复杂的设计过程。极限编程追求设计简单，实现客户要求即可，无需为扩展考虑太多，因为客户的新需求随时可以添加。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">3、追求价值</strong><br />极限编程把软件开发变成自我与管理的挑战，追求沟通、简单、反馈、勇气，体现开发团队的人员价值，激发参与者的情绪，最大限度地调动开发者的积极性，情绪高涨，认真投入，开发的软件质量就大大提高。结对编程就是激发队员才智的一种方式。<br /><br />极限编程把软件开发过程重新定义为聆听、测试、编码、设计的迭代循环过程，确立了测试-&gt;编码-&gt;重构(设计)的软件开发管理思路。</p><table border="1" cellspacing="0" class="ln" align="center" bgcolor="#ddddd"><tbody><tr><td style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px" bgcolor="#ffffff"><img class="insertimage" src="attachment.php?fid=666" border="0" /></td></tr><tr><td class="it" align="center" style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px" bgcolor="#dddddd">图2</td></tr></tbody></table></span><br /><span style="widows: 2; text-transform: none; background-color: #f8f8f8; text-indent: 0px; font-family: 宋体; white-space: normal; orphans: 2; letter-spacing: normal; color: #333333; word-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">极限编程的12个实践是极限编程者总结的实践经典，是体现极限编程管理的原则，对极限编程具有指导性的意义，但并非一定要完全遵守12个实践，主要看它给软件过程管理带来的价值。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">1、小版本</strong><br />为了高度迭代，与客户展现开发的进展，小版本发布是一个可交流的好办法，客户可以针对性提出反馈。但小版本把模块缩得很小，会影响软件的整体思路连贯，所以小版本也需要总体合理的规划。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">2、规划游戏</strong><br />就是客户需求，以客户故事的形式，由客户负责编写。极限编程不讲求统一的客户需求收集，也不是由开发人员整理，而是采取让客户编写，开发人员进行分析，设定优先级别，并进行技术实现。当然游戏规则可进行多次，每次迭代完毕后再行修改。客户故事是开发人员与客户沟通的焦点，也是版本设计的依据，所以其管理一定是有效的、沟通顺畅的。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">3、现场客户<br /></strong>极限编程要求客户参与开发工作，客户需求就是客户负责编写的，所以要求客户在开发现场一起工作，并为每次迭代提供反馈。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">4、隐喻</strong><br />隐喻是让项目参与人员都必须对一些抽象的概念理解一致，也就是我们常说的行业术语，因为业务本身的术语开发人员不熟悉，软件开发的术语客户不理解，因此开始要先明确双方使用的隐喻，避免歧异。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">5、简单设计</strong><br />极限编程体现跟踪客户的需求变化，既然需求是变化的，所以对于目前的需求就不必过多地考虑扩展性的开发，讲求简单设计，实现目前需求即可。简单设计的本身也为短期迭代提供了方便，若开发者考虑&ldquo;通用&rdquo;因素较多，增加了软件的复杂度，开发的迭代周期就会加长。简单设计包括四方面含义：（1）通过测试。（2）避免重复代码。（3）明确表达每步编码的目的，代码可读性强。（4）尽可能少的对象类和方法。由于采用简单设计，所以极限编程没有复杂的设计文档要求。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">6、重构<br /></strong>重构是极限编程先测试后编码的必然需求，为了整体软件可以先进行测试，对于一些软件要开发的模块先简单模拟，让编译通过，到达测试的目的。然后再对模块具体&ldquo;优化&rdquo;，所以重构包括模块代码的优化与具体代码的开发。重构是使用了&ldquo;物理学&rdquo;的一个概念，是在不影响物体外部特性的前提下，重新优化其内部的机构。这里的外部特性就是保证测试的通过。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">7、测试驱动开发<br /></strong>极限编程是以测试开始的，为了可以展示客户需求的实现，测试程序优先设计，测试是从客户实用的角度出发，客户实际使用的软件界面着想，测试是客户需求的直接表现，是客户对软件过程的理解。测试驱动开发，也就是客户的需求驱动软件的开发。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">8、持续集成</strong><br />集成的理解就是提交软件的展现，由于采用测试驱动开发、小版本的方式，所以不断集成(整体测试)是与客户沟通的依据，也是让客户提出反馈意见的参照。持续集成也是完成阶段开发任务的标志。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">9、结对编程<br /></strong>这是极限编程最有争议的实践。就是两个程序员合用一台计算机编程，一个编码，一个检查，增加专人审计是为了提供软件编码的质量。两个人的角色经常变换，保持开发者的工作热情。这种编程方式对培养新人或开发难度较大的软件都有非常好的效果。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">10、代码共有</strong><br />在极限编程里没有严格文档管理，代码为开发团队共有，这样有利于开发人员的流动管理，因为所有的人都熟悉所有的编码。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">11、编码标准</strong><br />编码是开发团队里每个人的工作，又没有详细的文档，代码的可读性是很重要的，所以规定统一的标准和习惯是必要的，有些象编码人员的隐喻。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">12、每周40小时工作</strong><br />极限编程认为编程是愉快的工作，不轻易加班，今天的工作今天做，小版本的设计也为了单位时间可以完成的工作安排。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px"><strong style="text-align: center; font-weight: bold">三、敏捷开发</strong></p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">极限编程的思想体现了适应客户需求的快速变化，激发开发者的热情，也是目前敏捷开发思维的重要支持者。<br />2001年，17名编程大师分别代表极限编程、Scrum(&ldquo;棒球&rdquo;团队开发模式)、特征驱动开发、动态系统开发方法、自适应软件开发、水晶方法、实用编程等开发流派，发表&ldquo;敏捷软件开发&rdquo;宣言。敏捷软件开发是一个开发软件的管理新模式，用来替代以文件驱动开发的瀑布开发模式。敏捷方式也称轻量级开发方法。敏捷软件开发宣言内容：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">◆个体和交互胜过过程和工具<br />◆可以工作的软件胜过面面具到的文档<br />◆可户合作胜过合同谈判<br />◆响应变化胜过遵循计划</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">敏捷开发集成了新型开发模式的共同特点，它重点强调：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">1、以人为本，注重编程中人的自我特长发挥。<br />2、强调软件开发的产品是软件，而不是文档。文档是为软件开发服务的，而不是开发的主体。<br />3、客户与开发者的关系是协作，不是合约。开发者不是客户业务的&ldquo;专家&rdquo;，要适应客户的需求，是要客户合作来阐述实际的需求细节，而不是为了开发软件，把开发人员变成客户业务的专家，这是传统开发模式或行业软件开发企业的最大面临问题。<br />4、设计周密是为了最终软件的质量，但不表明设计比实现更重要，要适应客户需求的不断变化，设计也要不断跟进，所以设计不能是&ldquo;闭门造车&rdquo;、&ldquo;自我良好&rdquo;，能不断根据环境的变化，修改自己的设计，指导开发的方向是敏捷开发的目标。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">敏捷开发避免了传统瀑布方式的弊端，主要是吸收了各种新型开发模式的&ldquo;动态&rdquo;特性，关注点从文档到开发者，管理方式也从工厂的流水线到团队的自我放松式的组织。总结敏捷开发与瀑布模式的不同，主要是下面几个&ldquo;敏捷&rdquo;的关注点：</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">◆<strong style="text-align: center; font-weight: bold">迭代</strong><br />软件的功能是客户的需求，界面的操作是客户的&ldquo;感觉&rdquo;，对迭代的强调是缩短了软件版本的周期<br />◆<strong style="text-align: center; font-weight: bold">客户参与</strong><br />以人为本，客户是软件的使用者，是业务理解的专家，没有客户的参与，开发者很难理解客户的真实需求<br />◆<strong style="text-align: center; font-weight: bold">小版本</strong><br />快速功能的展现，看似简单，但对于复杂的客户需求，合理地分割与总体上的统一，要很好地二者兼顾是不容易的。</p><p style="padding-bottom: 0px; background-color: transparent; text-indent: 28px; margin: 10px 0px; padding-left: 0px; padding-right: 0px; color: #333333; padding-top: 0px">敏捷就是&ldquo;快&rdquo;，快才可以适应目前社会的快节奏；要快就要发挥个人的个性思维多一些，个性思维的增多，虽然通过结队编程、代码共有、团队替补等方式减少个人对软件的影响力，但也会造成软件开发继承性的下降，因此敏捷开发是一个新的思路，但不是软件开发的终极选择。对于长时间、人数众多的大型软件应用的开发，文档的管理与衔接作用还是不可替代的。如何把敏捷的开发思路与传统的&ldquo;流水线工厂式&rdquo;管理有机地结合，是软件开发组织者面临的新课题。</p></span>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1841</link>
<title><![CDATA[番茄工作法图解]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[软件工程]]></category>
<pubDate>Tue, 21 Feb 2012 09:05:31 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1841</guid> 
<description>
<![CDATA[ 
	<span style="widows: 2; text-transform: none; background-color: #ffffff; text-indent: 0px; font-family: Lucida, 'Lucida Grande', Tahoma, sans-serif; white-space: normal; orphans: 2; letter-spacing: normal; color: #000000; word-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><span style="widows: 2; text-transform: none; background-color: #ffffff; text-indent: 0px; font-family: Lucida, 'Lucida Grande', Tahoma, sans-serif; white-space: normal; orphans: 2; letter-spacing: normal; color: #000000; word-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><p><br /><img style="width: 305px; height: 205px; border-width: 0px" src="attachment.php?fid=635" border="0" hspace="3" vspace="3" align="right" />有一种时间管理的方法？！而且还叫什么&ldquo;番茄&rdquo;？！当第一次听到&ldquo;番茄工作法&rdquo;这个名字时，这就是我的感觉。接下来才知道原来这里的&ldquo;番茄&rdquo;实际上指的是该方法中一个道具的名字：番茄钟。这是一种番茄状的计时钟，轻轻一扭，它便开始工作。当到达所定时间时，比如25分钟，它会响铃，通知你时间已到。</p><p>为什么一种时间管理方法会冠以一个物品的名称呢？问题的答案就蕴含在它的方法中：</p><p><strong>使用道具</strong></p><p><strong>3样东西：</strong>纸、笔和番茄钟。</p><p><strong>3种表格，每种表格一张纸：</strong>任务清单、今日待办和记录，分别用于记录一段时间内的任务、今日要完成的任务以及每日总结。</p><p><strong>实际方法</strong></p><p><strong>任务计划：</strong>先填完任务清单，接着每天从任务清单中抽取出今天要完成的任务，从而形成今日待办。一般来讲，任务清单每隔一个阶段做一次，今日待办则是每天都要进行。</p><p><strong>任务执行：</strong>从今日待办中选出优先级最高的任务，开启番茄钟，工作，番茄钟响铃，立即休息。以此循环序列依次完成今日待办中的任务，每次番茄钟结束时，需进行记录。</p><p><strong>任务检查：</strong>每日结束时，检查完成的番茄钟数，了解自己任务执行的情况。<img class="insertimage" src="attachment.php?fid=636" border="0" /></p></span><p><strong>任务反馈：</strong>根据检查结果，重新评估计划列表。</p><p>看出来了吗，&ldquo;番茄&rdquo;在这里不仅仅指的是番茄钟，而且还是度量你全神贯注完成任务的单位，既然担负着这样重要的责任，这种方法以它命名自然就不奇怪了。等等，上面的方法哪里体现了全神贯注的意思？没有吗？对不起，那是我疏忽了！全神贯注、全力以赴正是番茄工作法强调的核心，这也是它不同于其他GTD方法的之所在：在每个番茄钟里，你必须排除一切干扰，全身心地投入到手头的任务上。</p><p>这怎么可能，有谁没有在工作时接到过电话？！我听到了你的叫嚷。没错，我有过。番茄工作法也没有要求你做到与世隔绝，完全&ldquo;两耳不闻窗外事&rdquo;。至于如何处理这种&ldquo;突发状况&rdquo;，这里先卖个关子，否则把内容全讲了，叫人家如何卖书，做人不能这么不厚道;)。</p><p>上面的内容你都可以在《番茄工作法图解》这本书里找到，而且更详细。虽然它并不是我读到的关于该工作法的第一本书（实际上它是第二本），但却是最轻松愉快的一本。不仅仅是因为它的作者本身就有计算机背景（它的出版公司是大名鼎鼎的The Pragmatic Programmers，别跟我说你没有读过或听说过它出版的那本著名的《程序员修炼之道》），而且还因为书中配以了大量妙趣横生的插图，还是彩色的！</p><p><img class="insertimage" src="attachment.php?fid=637" border="0" />整本书的篇幅并不大，不过区区136页，而且还有大量的插图。翻得快的话，一两个小时就可以读完。可短并不代表内涵就不丰富。恰恰相反，从这本书中，你可以看到：</p><ul><li>为何番茄工作法卓有成效</li><li>相关的背景理论知识</li><li>番茄工作法的核心方法</li><li>处理工作中断</li><li>通过记录的历史数据对未来进行预估</li><li>根据自己的特点进行调整</li><li>在团队中应用方法</li></ul><p>本书的节奏非常快，但又不因为快而致使重点丢失。这种风格跟InfoQ的迷你书非常相似，对于如今快节奏生活的人们来说，这或许是一种快速获取新知识的好方法吧。团队应用，是本书的另一个亮点，同时也是其他GTD书籍里少有涉及的内容。考虑到作者本身就是从事软件开发，确切的说是使用敏捷方法的开发人员，将它应用到结对编程这样的实践里应该不足为奇。至于如何应用呢，还是到书中看个究竟吧。</p><p>另外值得一提的是，给本书作序的两位也来头不小，一位就是番茄工作法的发明者本人，而另一个本则是广受欢迎的InfoQ迷你书《硝烟中的Scrum和XP》的作者。有他二人的作序，这会是一本怎样的书呢？:)。</p>最后，作为本书中的额外收获，对番茄工作法感兴趣的读者，还可以从<a style="color: #0b59b2; text-decoration: underline" href="http://www.pomodorotechnique.com/">番茄工作法的网站</a>上下载<a style="color: #0b59b2; text-decoration: underline" href="http://www.pomodorotechnique.com/resources/ThePomodoroTechnique-CHN_v1-3.pdf">免费的中文版</a>，它正是我读到的第一本关于番茄工作法的书。<br /><br /><br /><span style="widows: 2; text-transform: none; background-color: #ffffff; text-indent: 0px; font-family: Lucida, 'Lucida Grande', Tahoma, sans-serif; white-space: normal; orphans: 2; letter-spacing: normal; color: #000000; word-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><p>大家好，我正好使用番茄工作法写这篇《番茄工作法图解》的书评。雷锋说：&ldquo;人的生命是有限的，为人民服务是无限的，我要把.......&rdquo;，我们或许只能仰视雷锋同志的崇高精神，但是都意识到生命是有限的、宝贵的，大家需要时间来赚钱养家........如果你在工作或者生活当中总感觉时间不够用或者做事效率较低，那么番茄工作法可能会改变你的状态，番茄工作法并不是一个特别新的模式，已经流行了一段时间，而这本《番茄工作法图解》是又一本介绍该方法的著作，有什么独到之处？</p><ul><li>作者Staffan N?teberg[瑞典]并不是番茄工作法的创始人，但是他是该方法的亲身实践者和受益者，所以他以自己的实际经历写成了这本书，其中有自己的建议、实践体会等等，很适合想尝试番茄工作法的朋友。</li><li>这本书很薄，没有多少字，适合性子急的读者，估计都会一口气读完，不会因为恐惧&ldquo;大部头&rdquo;而放弃对番茄工作法的了解。</li><li>图文并茂，每一页上半部分都是作者的手绘图，下半部分是几行文字，多感观的信息输入会加深读者的印象，提高了趣味性，不会感觉厌倦。</li><li>翻译得比较地道，因为这本书并不是什么软件开发某个特定领域的专业书籍，原作内容天马行空，属于散文式的结构，涉及的领域比较广泛，如心理学、社会行为学等，翻译起来有难度，我个人觉得中文版本做得比较尽心。</li></ul><p><img class="insertimage" src="attachment.php?fid=638" border="0" />说了这本书的特点，再说说番茄工作法的内容。简而言之，就是通过定时机制在一段时间内让自己集中精力解决一件事情，记住：一段时间只做一件事情。番茄工作法建议把时间段分为25分钟，当然开始的时候如果无法保证精力集中的状态，可以将时间段减少，例如15分钟，等加强训练之后，可以再递增。另外，这段时间只允许关注一件事情，不能分心。大家在平时工作中总是面临各种各样的事情，有紧急的，有长期的，在选取任务时必须查看待办事情清单，确定优先级最高的任务， 然后评估其使用多少个番茄钟（25分钟），一旦确定下来，就要集中精力做这件事情。就像我现在一样，评估写这篇书评需要花费两个番茄钟，然后开始动笔。一旦动笔之后，避免干扰，工作情境的切换特别耗费人的精力，也会影响士气，如果现在被人打扰，那么将他们的问题记录下来，稍后再处理，继续把心思用在既定的事情上。完成一个番茄钟后，强制自己休息一段时间（5分钟），离开电脑，离开办公桌，最好去外面走一走。然后再回来继续下一个番茄钟，OK，我的第一个番茄钟结束了，需要休息了，离开键盘，5分钟后再见!</p><p>我回来了，刚才去走廊里伸了伸懒腰，呼吸了新鲜空气，回来再设置一个番茄钟。《番茄工作法图解》提到了在尝试番茄工作法时可能会遇到的各种问题。我在看了这本书之后开始使用番茄工作法，面临的第一个问题是总想超时，你知道，一旦开始了某项工作，不知不觉就到25分钟了，舍不得放下，但是仔细想想，还是要休息的，因为你或许能够再坚持一个番茄钟，但不是可持续发展的路线，短暂的休息会让你效率更高。</p><p>哦，我的手机短信提醒铃声响了，待会再看，我不能走神，继续写书评。</p><p><img class="insertimage" src="attachment.php?fid=639" border="0" />提到番茄钟，大家可千万不要把厨房里的定时器拿到公司的办公室，那嘎嘎的计时声.........按照《番茄工作法图解》的建议，我找到了一些免费、开源的软件番茄钟，向大家推荐<a style="color: #0b59b2; text-decoration: underline" href="http://www.google.com.hk/url?sa=t&amp;source=web&amp;cd=4&amp;ved=0CDsQFjAD&amp;url=http://sourceforge.net/projects/pomodorotimer/&amp;ei=MC-5TZqeCpGGvgP21qiiAw&amp;usg=AFQjCNHs5gy07zXt4Vfu6q9ThEKfudZ_0g&amp;sig2=0sNQDoA0V-K7IRo0LqrQwA">Pomodoro Timer</a>，无需安装，直接运行，在右下角是个番茄的图标，随时可以开始一个新的番茄钟，能够设定时间段的长度，并把以前的完成情况做了历史统计，我最喜欢它的一点在于，它可以模仿计时的声音！也就说，虽然不能使用实际的闹钟，但是通过模拟计时声，你也可以身临其境。作者Staffan N&ouml;teberg特意提到，这种计时的声音可以引起紧迫感，有助于集中精力完成任务，当然还要视个人的具体情况而定。</p><p>书评写的差不多了，但是还有时间，番茄工作法建议大家不要提前完成任务，在剩余时间内进行总结和回顾，也就是反馈非常重要，有助于为以后更好的进行工作提供经验和改进建议。每天可能会有十几个番茄钟的工作，作者Staffan N&ouml;teberg建议大家在一天工作之后，对照着完成的工作清单和番茄钟的历史，反思一下出现的问题，比如有多少次主动或被动中断？哪些任务的番茄钟数量评估的有问题？今后如何改进等等。不断的自我反馈会有助于更好地实施番茄工作法。</p><p>除此之外，《番茄工作法图解》还提到了其他与该方法有关的问题，比如在多人合作时怎么实践番茄工作法、如何应付中断等。</p><p>总之，对番茄工作法感兴趣的朋友可以阅读《番茄工作法图解》，应该会对该方法有一个完整的了解，当然，光说不练假把式，希望大家在放下这本书时，能够积极的投身到方法的实践中，相信会对大家提高工作效率有积极的促进作用，等你的好消息！</p><p>番茄钟还有5分钟，我的这篇书评对应的两个番茄钟就要结束了，我再回顾一下这篇书评，看看有什么严重问题。</p><p>OK，检查完毕，番茄钟也响了，正如它的提示声音：well done！</p><br /></span><br /></span>
]]>
</description>
</item>
</channel>
</rss>