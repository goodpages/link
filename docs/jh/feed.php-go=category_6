<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?3627</link>
<title><![CDATA[面向Altera FPGA的OpenCL:提高性能和设计效能]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Fri, 09 Nov 2012 01:22:25 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?3627</guid> 
<description>
<![CDATA[ 
	开放计算语言（OpenCL&trade;）编程模型与Altera的并行FPGA体系结构相结合，实现了功能强大的系统加速解决方案。面向OpenCL的Altera&reg; SDK为您提供了设计环境，工程师很容易在FPGA上实现OpenCL应用。 <p>　　<strong>什么是OpenCL？</strong></p><p>　　OpenCL标准是第一个开放、免版税、统一的编程模型，能够在异构系统上加速算法实现。OpenCL支持在不同的平台上使用基于C的语言来开发代码&mdash;&mdash;从CPU、GPU、数字信号处理（DSP）器件，到FPGA。Khronos集团的很多供应商都支持OpenCL。</p><p style="text-align: center"></p><p>　　<strong>面向FPGA的OpenCL有什么优点？</strong></p><p>　　（1）用户的产品能够更迅速面市</p><p>　　&nbsp;&nbsp;&nbsp; 与传统的FPGA设计流程相比，产品能够更迅速面市。</p><p>　　&nbsp;&nbsp;&nbsp; 使用OpenCL C （基于ANSI C）并行编程语言而不是传统的底层硬件描述语言（HDL）来描述用户的算法。</p><p>　　&nbsp;&nbsp;&nbsp; 在更高层的设计抽象环境中迅速进行设计开发。</p><p>　　&nbsp;&nbsp;&nbsp; 针对目前和未来的FPGA重新定位OpenCL C代码，设计不会过时。</p><p>　　&nbsp;&nbsp;&nbsp; 跳过耗时的手动时序收敛以及FPGA、主机和外部存储器之间的通信接口设计工作，一个步骤中就可以在FPGA上实现OpenCL C代码。</p><p>　　（2）获得性能更好、功效更高的解决方案</p><p>　　&nbsp;&nbsp;&nbsp; 把对性能要求较高的功能从主处理器中卸载到FPGA上，从而提高了性能。</p><p>　　&nbsp;&nbsp;&nbsp; 通过观看采用OpenCL，卸载到FPGA来加速算法性能的演示，了解详细信息。</p><p>　　&nbsp;&nbsp;&nbsp; 与其他硬件方案相比，显著降低功耗，提高性能。采用FPGA的精细粒度体系结构，Altera面向OpenCL的SDK只生成需要的逻辑，功耗只有硬件方案的1/5。</p><p>　　很多市场领域对通过并行软件编程来提高性能、加速产品面市的需求越来越高，包括计算机和存储、军事、医疗和广播等市场。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?466</link>
<title><![CDATA[基于FPGA的视频格式转换系统设计]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Tue, 01 Nov 2011 10:36:40 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?466</guid> 
<description>
<![CDATA[ 
	<p>摘 要: 针对电视制式PAL /NTSC 信号输出VGA 显示格式的解决办法，详细讲述了基于FPGA 视频格式转换系统的设计实现。采用Cyclone Ⅲ系列的EP3C1*84C6作为核心处理器件，实现了NTSC /PAL制式视频的解码、色空间转换( CSC)、帧速率转换和隔行逐行转换、缩放、视频DAC 转换，最终实现分量R、G、B的VGA 视频格式的视频输出，分辨率可达1 600 &times; 1 200@ 100 Hz。</p><p><strong>1 系统设计</strong></p><p>设计使用了ALTERA 的EP3C1*84C6型号FPGA 作为视频处理核心，连接两片DDR2 SDRAM,DDR2芯片型号为M icron的MT47H 32M16BN _37E，作为系统的数据存储器件，带宽为32 bit,时钟速率为200MHz，数据速率为400 Mbps。视频解码芯片为TVP5147，视频DAC 采用高性能ADV7123。整个系统框架如图1所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=167" border="0" width="600" height="229" /><br /></p><p align="center">图1 视频处理板框图</p><p><strong>2 硬件功能模块。</strong></p><p><strong>2. 1 视频解码</strong></p><p>TVP5147的解码过程如图2所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=168" border="0" width="700" height="340" /><br /></p><p align="center">图2 TVP5147解码过程</p><p>视频解码芯片TVP5147复位后，通过MCU 向其正确配置I2C寄存器。本文的TVP5147的I2C 寄存器配置的值如表1所示。</p><p align="center">表1 TVP5147的I2C寄存器设置</p><p align="center"><img class="insertimage" src="attachment.php?fid=169" border="0" width="609" height="475" /><br /></p><p><strong>2. 2 视频存储器</strong></p><p>在视频处理模块中包括了大量的视频数据存储器模块，主要可分为行存储器、帧存储器以及查找表存储器3类。</p><p>( 1)行存储器用于存储视频中一行的数据，由于数据量不大，用FPGA 内部RAM 来实现。</p><p>( 2)帧存储器用于存储一帧视频数据，由于数据量大，用DDR2来实现。</p><p>( 3)查找表存储器用于产生不规则的输入输出相应，如Sin函数和Gamma矫正曲线。</p><p><strong>2. 3 FPGA 模块设计</strong></p><p>FPGA 模块设计如图3。</p><p align="center"><img class="insertimage" src="attachment.php?fid=170" border="0" width="492" height="266" /><br /></p><p align="center">图3 FPGA 模块框图</p><p><strong>2. 3. 1 数据串并转换和色度重采样模块</strong></p><p>此模块分为串并转换和色度重采样两个部分。</p><p>串并转换主要是为了把TVP5147 输出的混合数据转换为分量数据。由于采用了BT. 656 10- b it 4：2：2模式，其输出数据时钟为像素时钟( 13. 5 MHz) 的两倍，输出数据依次为Cb0，Y0，C r0，Y1,Cb1，Y2，C r1 等，本模块将其转为4：2：2 的Y&lsquo;CbCr 分量数据，RTL 仿真结果如图4所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=171" border="0" width="561" height="117" /><br /></p><p align="center">图4 串并转换模块仿真结果</p><p>虽然视频分量传输带来了更好的图像还原度，但同时也带来了数据带宽的加大，因此很多时候人们把视觉上不那么重要的色差信号进行了重采样为4：2：2 (或4：1：1)以降低传输数据带宽。而在视频和显示系统内部基本使用4：4：4 的信号，因此色度重采样也成了视频转换中必不可少的模块。本文实现了4:2:2 到4%4%4和4：4：4 到4:2:2的转换。4：2：2 到4：4：4 的转换方法有直接重复法、一维滤波法以及亮度自适应滤波法。</p><p>考虑硬件成本和处理质量，我们选用一维滤波法，即只考虑色度通道在水平方向的滤波。图5为采用n抽头FIR滤波器进行色度重采样的模块框图。</p><p align="center"><img class="insertimage" src="attachment.php?fid=172" border="0" width="600" height="218" /><br /></p><p align="center">图5 4：2：2 到4：4：4色度重采样模块</p><p><strong>2. 3. 2 色空间转换模块( CSC )</strong></p><p>由于不同视频标准采用了不同的色彩空间，而且有些视频处理需要在特定色空间里处理，因此色空间转换是十分必要的。色空间转换实际上是一个三输入经线性矩阵变换后得到新的三输出，其基本的转换公式如下：</p><p align="center"><img class="insertimage" src="attachment.php?fid=173" border="0" width="479" height="246" /><br /></p><p>上式中的Ax，Bx，Cx，Sx 分别代表不同空间之间的转换系数。一般视频系统中涉及的色空间包括电脑的R' G ' B ' 空间，NTSC 和PAL的Y'UV 空间，以及Y&rsquo;CbCr空间。图6为转换模块框图，其中的转换系数可任意配置，即标准不限定。上节中的10 b it Y'CrCb可以通过这个色空间转换器，用标清到高清的转换系数转为8 b it的BT. 709标准Y'CrC 数据。</p><p align="center"><img class="insertimage" src="attachment.php?fid=174" border="0" width="600" height="205" /><br /></p><p align="center">图6 色空间转换模块( Rx 为round ing 值)</p><p>输入8 bit的R'G' B'信号，先经R' G' B' 到Y'CbC r转换成10 b it的Y&lsquo; CbC r信号，然后再转成8 bit的R' G'B ' 信号。其中色空间转换采用的是高清标准，采用小数部分为16 b it的定点小数来处理转换系数。图中上部分为8 bit的R'G'B'数据输入，中间为10 b it的Y'CrCb数据，下部分为8 b it的R'G'B'数据输出。由于做了流水线处理，输出有3 个时钟的延迟。</p><p align="center"><img class="insertimage" src="attachment.php?fid=175" border="0" width="500" height="128" /><br /></p><p align="center">图7 8 b its R&rsquo;G&lsquo;B&rsquo;转10 bits Y&lsquo; CbC r再转回8 b its R&rsquo;G&lsquo;B&rsquo;仿真结果</p><p><strong>2. 3. 3 帧率转换和隔行逐行转换模块</strong></p><p>隔行转逐行的方法可以分为空域和时域两个方面。空域算法简单，易于硬件实现，常见有直接重复行和在垂直方向上进行插值得到缺失的行。时域方法涉及到相邻场之间的运算，常见方法有场混合、运动自适应去隔行算法以及复杂度最高的运动补偿去隔行算法。本文折衷考虑使用场混合方法，即将场数据相邻场两两合成为逐行的帧数据，如图8所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=176" border="0" width="500" height="91" /><br /></p><p align="center">图8 场混合法实现隔行逐行变换</p><p>PAL和SECAM 制式的场频为50 Hz，而NTSC 为60H z，当需要进行不同场频信号的叠加就需要进行场频转换。大多视频设备使用的帧频为60 H z，因此本文只涉及50~ 60 H z的帧率转换。常用方法有场重复、场插值、运动补偿法，其中场插值算法如图9所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=177" border="0" width="600" height="229" /><br /></p><p align="center">图9 50 Hz转60 Hz的场插值方法</p><p>对于PAL制式从上面两图可知，只要能同时读取3行场数据即可以实现隔行逐行变换和帧率转换一次完成。如输出的第1帧由输入的第1，2 场数据决定,而输出的第2 帧由输入的第1，2，3场数据决定，而输出的第3帧由输入的第2，3，4 场数据决定，依次类推。</p><p>系统使用位宽为48的DDR2存储器作为场存储器，而在FPGA 内部DDR2控制器端数据宽度为96。如产生第2 帧输出的处理过程为，在第1场存入时，把高64bit屏蔽掉不写入，而低32 b it写入场数据(实际只利用30 b it)。在第2场存入时，把高32 位和低32 b it屏蔽掉不写入，而中间32 bit写入场数据。在第3 场存入时，把低64 b it屏蔽掉不写入，而高32 bit写入场数据。这样在数据读取的时候可以顺序同时读出3场数据，然后进行上述的组合插值运算，即可得到输出。场存储器数据内格式如图10所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=178" border="0" width="600" height="272" /><br /></p><p align="center">图10 可以实现同时去隔行和帧率转换的场存储器</p><p>注意新的输入场数据不能覆盖掉相邻的数据，因此在数据存入时屏蔽位是在不断跳动的，并以5 场为一个周期。虽然这样降低了写入的效率，但由于所有数据读写都是顺序操作，因此从整体上来说仍然提高了DDR2 的存取效率，并且使操作变得简单。对于NTSC 制式，由于帧率转换部分可不用考虑，可以将只使用低64位部分进行两场存储。</p><p><strong>2. 3. 4 缩放模块</strong></p><p>视频缩放包括放大( up scaling ) 和缩小( downsca ling )两个方面，而进行缩放的基本方法为空间插值。下式为对图像进行插值的一般数学表达式，其中g ( i，j)为缩放图像中待插值点的像素值，f ( k，l)为原始图像中坐标( k，l)处的像素值，h( i- k，j - l)为插值基函数。</p><p align="center"><img class="insertimage" src="attachment.php?fid=179" border="0" width="488" height="50" /><br /></p><p>插值基函数的选择可以有很多种，通常有二维的矩形函数、线性函数、三次函数及S inc 函数等，它们分别对应于最近邻插值、线性插值、三次插值以及理想插值(实际中利用S inc函数截断后插值) ，其插值效果为从差到好排列，但实现难度也依次提高。在实际处理中是利用滤波器来实现插值基函数，而且由于这些插值的对称性，可以将其分解为横向和纵向插值两部分分开进行，如二维线性插值函数对应双线性插值( Bilinear Interpo lation)，三次函数对应双三次插值( B icub ic Interpo lation) ，对于Sinc 插值函数实际中为多相位插值( Po lyphase Interpo lation)。本文使用多相位插值法实现图像缩放，实际上在4 ? 4领域大小内进行多相位插值和三次插值几乎是一样的，只是对应插值函数值略微不同。多相位插值法是通过对输出点对应原图中的领域进行Lanczos2 函数移相插值来产生输出点的。如图11所示。</p><p align="center"><img class="insertimage" src="attachment.php?fid=180" border="0" width="500" height="440" /><br /></p><p align="center">图11 Lanczos2 函数</p><p>假设g ( u，v )为经缩放后输出图像中一点，其还原到原图像的最近点为f ( i，j) 且两者在原图中相差( x，y )的坐标，则输出点g ( u，v)的数学表达如下，从其可以看出实际上分为两步实现分别进行垂直滤波和水平滤波。</p><p align="center"><img class="insertimage" src="attachment.php?fid=181" border="0" width="605" height="143" /><br /></p><p>其中有关系式: i = ( u &times;W in ) /W out，j = ( v &times;H in) /H out; x = ( u &times; W in)% W out，y = ( v &times;H in)%H out。W in 和Wout分别为缩放前后的图像宽度，H in和H out分别为缩放前后的图像高度。图12为4 &times;4领域水平垂直相位，其中的水平相位值分别为PH 0,PH 1，PH 2，PH 3，垂直相位值分别为PV0，PV1，PV2,PV3。只要根据上述关系式求得x，y 值就能获得8 个相位值，就能实现多相位滤波。</p><p align="center"><img class="insertimage" src="attachment.php?fid=182" border="0" width="500" height="311" /><br /></p><p align="center">图12 4&times;4 领域水平垂直相位</p><p>图13为本文设计的图像缩放器中滤波器部分框图，其中的垂直水平查找表里分别存放着4个不同相位的Lanczos2 函数值。</p><p align="center"><img class="insertimage" src="attachment.php?fid=183" border="0" width="600" height="250" /><br /><br /></p><p align="center">图13 图像缩放器中的滤波器</p><p><strong>2. 4 视频DAC</strong></p><p>视频编码到模拟R、G、B 由视频DAC 芯片ADV7123，它内部有三独立通道10 bit高速DAC，如图14所示为其功能图及其系统作用。</p><p align="center"><img class="insertimage" src="attachment.php?fid=184" border="0" width="600" height="203" /><br /></p><p align="center">图14 ADV7123系统图</p><p><strong>3 系统电源设计</strong></p><p>电源的可靠性是电子系统设计成败的关键。在设计电源时，在保证电源的可靠性的基础之上需要综合考虑电源电路的效率与体积，此系统需要0. 9 V,1. 2 V，1. 8 V，2. 5 V，3. 3 V，5 V 共6种电源。</p><p>LM2737输出电流最大为5 A，效率高达90%，封装为SO IC，体积小。DDR2的VTT 与VRef的0. 9 V电压由DDR 参考终端电压通用芯片TPS51100 转换而来。</p><p align="center"><img class="insertimage" src="attachment.php?fid=185" border="0" width="600" height="323" /><br /></p><p align="center">图15 电源设计框图</p><p><strong>4 结束语</strong></p><p>本文采用C yc lone III的EP3C1*84C6器件及相关的视频编解码芯片设计视频格式转换系统，实现了普通电视信号到较为通用的VGA 接口信号的转换，同时通过对视频信号的缩放等处理增大视频分辨率。另外，采用FPGA作为核心视频处理器件，使得系统对视频制式的支持具有很好的灵活性。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?384</link>
<title><![CDATA[开源RISC架构OpenRISC]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Tue, 25 Oct 2011 05:08:23 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?384</guid> 
<description>
<![CDATA[ 
	<div id="p_fullcontent" class="detail"><p>OpenRisc是OpenCores组织提供的基于GPL协议的开放源代码的RISC（精简指令集计算机）处理器。有人认为其性能介于ARM7和 ARM9之间，适合一般的嵌入式系统使用。最重要的一点是OpenCores组织提供了大量的开放源代码IP核供研究人员使用，因此对于一般的开发单位具 有很大的吸引力。</p><p>OpenRisc具有以下的主要特点：</p><ol><li>采用免费开放的32/64bit RISC/DSP架构。 </li><li>用Verilog HDL(硬件描述语言)实现了基于该RISC/DSP架构的RTL(寄存器传输级)描述。 </li><li>具有完整的工具链，包括：开源的软件开发工具，C语言实现的cpu仿真模型，操作系统，以及软件应用所需的函数库。 <br /><br /><a href="http://opencores.org/">http://opencores.org/</a></li></ol></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?216</link>
<title><![CDATA[基于SystemC的软硬件协同验证]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Mon, 17 Oct 2011 03:29:04 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?216</guid> 
<description>
<![CDATA[ 
	<p>集成电路设计规模越来越大，速度越来越快，复杂度也越来越高，因此有必要在更高的抽象级别对设计对象进行描述和验证，以实现更快的仿真速度及软硬件的协同验证。但是传统的设计在前期完成软硬件的划分后，对软硬件部分进行单独设计，在软硬件的集成平台没有完成之前，很少进行软硬件的协同仿真验证。许多重要的性质如性能、成本、实时性等，很大程度上是在设计早期决定的，在传统设计流程中，要到设计的后阶段进行系统整合和验证时才能发现，这时再返回设计的开始阶段修改设计，必然会大大延长设计周期，增加设计成本，其工作量往往也很大。</p><p><br />随着开发语言的不断完善，出现了些支持更高抽象级别的设计语言，如SystemC、System Verilog等，这些语言较好地实现了软硬件的协同验证。其中SystemC以更接近于C++的风格特点，而受到设计者的青睐。本文介绍了采用SystemC语言，在设计的前期实现软硬件协同验证的方法。</p><p><strong>SystemC的简介</strong></p><p><br />SystemC是由开放性的SystemC联盟组织(Open SystemC Initiative，OSCT)推出的一种系统级设计和验证语言，SystemC是基于C++的建模平台，其本质是在C++的基础上添加了硬件扩展库和仿真核，支持EDA设计中的各个抽象层次，如寄存器级、行为级、系统级的建模，能够表达并发性、实时性、交互性等硬件模型的概念。</p><p><br />SystemC完全支持C++的数据类型，如果从系统级建模而言，完全可以将SystemC作为C++来处理，可以使用标准的C++语言开发工具来建立、仿真、调试和探索设计对象的各种体系结构和算法描述。在本文中，对SystemC的调试采用了Visual C++ 6.0，对其进行的仿真用了ModelSim SE 6.1f。</p><p><br />使用SystemC，可以像使用VHDL或者Verilog语言一样进行RTL级和行为级的建模。SystemC中主要的类包括模块(modules)、进程(processes)、端口(ports)、信号(signals)等，还有一个调度内核，负责在每一个时钟周期调度进程和更新信号值。为了支持寄存器传输级的并行描述，SystemC采用了与传统硬件描述语言基本相同的调度模式&mdash;&mdash;基于△(delta)延时。一个△周期包括求值和更新两个阶段，在一个时间点上，这样的△周期会持续出现，直到再求值前后的结果不再发生变化。</p><p><br />SystemC中的模块用关键字SC_MODULE来定义，其端口定义与Verilog类似。当存在多个模块时，在SystemC中用顶层函数sc_main()来实现各个模块的连接，没有该函数的代码是无法编译的。在SystemC中，进程是一个基本的执行单元，它被调用来仿真目标系统的行为。进程的行为是多样化的，可以实现某个函数的功能，也可以在运行过程中被挂起，并且进程是并行执行的，一个进程中不能包含或直接调用其他进程。SystemC的进程主要有两种，方法进程(SC_METHOD)和线程进程(SC_THREAD)。方法进程是唯一可以综合的RTL进程，它的特点是当敏感表上有事件发生，它就被调用，调用后立即返回。只有该类进程返回后，仿真系统的时间才有可能前进，因此该类进程不能被挂起。线程进程不是RTL级进程，它可以被挂起和重新激活，所以它的一个用途是用来描述验证平台(testbench)。</p><p><strong>基于SystemC的硬件软件协同验证技术</strong></p><p><br />在传统的系统设计中，系统设计人员自己选择语言(通常是C或C++)编写可执行程序，调试并验证功能后，对系统进行软硬件的划分，并将需要硬件实现的部分交给RTL设计组，RTL设计组再在C/C++基础上重新编写设计对象，以将其综合成门电路，该流程如图1所示。在这个过程中，软件部分往往是用C/C++来编写的，对这部分的验证可以用Visual C++等来实现，而硬件部分通常是用Verilog或VHDL来编写的，这就需要设计者将C/C++转换为HDL，对其验证也只能单独用Modelsim等工具来完成，这样很难在早期实现协同验证，必须等软硬件都各自验证完成，再用基于软硬件的集成平台来验证，但此时设计已经基本完成，如果发现错误，其修改工作量是很可观的。</p><p align="center"><img src="http://www.epc.com.cn/magzine/20070201/richard20070208131926.gif" border="0" width="234" height="312" /></p><p align="center"><strong>图1&nbsp; 传统设计过程图</strong></p><p><br />与传统的方法相比，基于SystemC的设计流程与以前的设计流程本质区别在于，使用一种统一的语言就可以完成从系统级到RTL，从软件到硬件的全部设计，整个设计的软硬件可以协同设计和仿真。SystemC提供了在高抽象级别使用抽象数据类型对系统的硬件部分进行建模，支持软硬件早期的协同验证。图2为基于SystemC的设计流程，从C/C++到HDL的过程不需要再作转换，可以用一种语言完成所有设计和验证。</p><p align="center"><img src="http://www.epc.com.cn/magzine/20070201/richard20070208132000.gif" border="0" width="87" height="305" /></p><p align="center"><strong>图2&nbsp; SystemC设计流程图</strong></p><p><br />在图2中，由于SystemC实质上就是C++，所以把C/C++的模型转换为SystemC的模型并没有多大难度，设计者完全可以用SystemC进行设计，并用它生成各种测试基准进行验证。同时软硬件协同验证的阶段也提前到了设计的初期，这样在硬件平台实现之前就可以对设计的合理性和可行性做出充分的评价，并可以尽早对设计进行优化。</p><p><br />用SystemC进行软硬件协同设计和验证的具体过程如图3所示。通过使用SystemC类库，设计者可以编写目标系统的系统层(system level)、行为层(behavioral level)或RTL层的SystemC模型代码。SystemC类库在其中起到两个作用：一是提供了描述硬件行为如并发、层次化模块、端口、时钟等这些类的实现；二是提供了一个轻型的进程调度核。使用标准的C++编译器，如Visual C++等，可以将设计者编写的SystemC代码进行编译、链接，得到一个可执行的程序，该程序的执行的结果就是设计者所设计的目标系统的模拟运行，用于验证设计正确与否的各种测试基准同样使用SystemC编写，并且随同设计一起编译，SystemC的代码调试可以使用任何常见的C++调试环境进行调试，如Visual C++。另外在模拟中还可以产生波形文件，并使用常见的波形显示工具如Modelsim等进行分析。</p><p align="center"><img src="http://www.epc.com.cn/magzine/20070201/richard20070208132054.gif" border="0" width="400" height="394" /></p><p align="center"><strong>图3&nbsp; SystemC设计流程图</strong></p><p><br />上面提到的在系统级和行为级时，软硬件划分之后，对整个系统的功能用SystemC来实现软硬件的协同验证，接下来就是设计中硬件部分的细化，在RTL级实现。一种理想的情况当然是在RTL级也一直沿用SystemC，对系统级的SystemC进一步的细化到RTL级。但事实上，现在SystemC对RTL级的支持并不够，所以将SystemC转换为可综合的HDL就不可避免。</p><p>SystemC不仅可以在高抽象层次单独对设计进行软硬件的协同验证，还可以和Verilog或VHDL一起进行联合的验证，这就为真正意义上的协同验证提供了可能性。</p><p><br />在ModelSim SE 6.1f及其以上的版本中，都支持对SystemC和HDL的混合验证。在这种情况下，设计的硬件部分已经用HDL语言完成，而软件部分完全可以用SystemC来实现。在集成平台没有完成时，只要能用SystemC实现软硬件的通信，实现软硬件协同验证显然可以做到。而SystemC充分考虑到这一点，在ModelSim SE 6.1f中很好地支持了混合的编译和验证。在ModelSim SE 6.1f中，对Verilog的module编译用vlog命令，对SystemC的module编译用sccom-g命令，编译完成后用sccom-link命令将所有的对象连接起来，从而可以完成编译和仿真，具体的过程可以参阅ModelSim SE 6.1f的用户手册，本文也讲在接下来的例子中有针对性地进行说明。</p><p><strong>软硬件协同验证举例</strong></p><p><br />下面将以H.264解码器为例，介绍如何进行软硬件的协同验证。限于篇幅，只对其中关键性的步骤给出相关的分析和介绍。</p><p><br />根据上文中给出的过程，在完成对解码器进行软硬件划分后，对软硬件部分用SystemC语言来设计，并进行Visual C++下的协同验证，限于篇幅，对这部分不做说明，设计者可以自己参考SystemC的语法完成。这之后，将硬件部分用Verilog实现。在完成软件部分和硬件部分各自单独的验证之后，为了实现软硬件的协同仿真，在软件部分加了一个实现系统总线传输功能的进程，而硬件部分的各个模块则作为接在系统总线上的单元，这样以来，软件部分就可以通过进程实现与系统总线上的硬件模块通信。实验室中对H.264解码器完成了软硬件的划分，并完成了行为级协同验证，在接下来的过程中本文将对读者关心的几个关键步骤进行简单介绍。</p><p><br /><strong>● C/C++向SystemC的转化</strong></p><p><br />由上文中可以看出，C/C++模型向SystemC模型的转换是协同验证的开端。C语言向SystemC的转换，可以认为是C语言向C++转换的过程。在H.264解码器设计中，软件部分是用C语言描述的，故而这里将着重完成C模型向SystemC模型的转换。</p><p><br />在所有的C语言代码中，程序的开始都是main()函数，通过main函数调用其他函数。而在SystemC中，主要成分则是进程。于是很容易想到用进程来代替函数的功能，但是直接的转换是行不通的，因为进程是并行的。根据H.264解码器的C语言代码，把它整个作为一个module，先定义SystemC的一个顶层模块SC_MODULE(H264top)，接下来对H264top这个模块定义端口和进程，对端口的定义可以根据具体情况而定，而对于进程的定义，必须把原来的C语言的main函数定义成一个方法进程SC_METHOD(prc_main)，这个取名为prc_main进程在功能上完全等同于main函数，通过这个进程来调用原先的其他函数。完成这些转换后，再加上一个顶层函数sc_main()来实现连接，这样软件部分向SystemC的转换就基本完成，可以到Visual C++中编译调试了。</p><p><br /><strong>● 完成软硬件部分的结合，实现协同仿真</strong></p><p><br />这一步是整个协同仿真中最为关键的一步。一般意义上，软件部分和硬件部分无法直接连接，它们之间必须要有一条系统总线来实现通信。</p><p><br />在SystemC改写的软件模块中，为了要实现软硬件的交互，用Modelsim实现软硬件协同仿真，定义了一个线程进程SW2HW，用于软件与硬件之间的通信。在用SystemC实现这这个进程时，要注意使它的行为符合系统总线的传输协议。根据SystemC语法，SW2HW作为模块H264top的一个进程，它与方法进程prc_main是并行的，并且两者不可以互相调用，那么更谈不上互相通信。为了解决这个矛盾，SystemC中指出，进程可以和模块的其他成员函数相互调用。于是在实现软硬件通信的进程SW2HW后，还需要把原来在进程prc_main中的，需要和硬件交互的函数重新在模块顶层模块H264top中定义为成员函数。这样软硬件的交互才能真正实现。</p><p><br /><strong>结语</strong></p><p><br />以往，硬件软件协同验证技术往往是使用一些复杂的数据结构作为描述、分析和综合的平台，这样的结构只能称为虚拟平台，它需要复杂的工具来整合不同软硬件设计语言和进行协合验证。本文的研究采用一个可执行的SystemC描述来代替这个虚拟平台，在设计过程中，设计者可以使用一个可执行的SystemC描述做为设计对象，在完成RTL级的设计后，也可以通过SystemC编写的通信机制实现软硬件的实时通信，达到软硬件协同仿真的目的。</p><!--开始插入图片--><!--&nbsp;&nbsp;&nbsp;&nbsp;richard20070208131926.gif&nbsp;&nbsp;&nbsp;&nbsp;richard20070208132000.gif&nbsp;&nbsp;&nbsp;&nbsp;richard20070208132054.gif&nbsp;&nbsp;&nbsp;&nbsp;--><!--结束插入图片-->
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?215</link>
<title><![CDATA[业内领先的ANSI C综合系统——ImpulseC]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Mon, 17 Oct 2011 03:27:55 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?215</guid> 
<description>
<![CDATA[ 
	<span style="font-family: Times New Roman">电子系统级（ESL）技术是近十年来电子系统设计技术发展的新方向。从方法学演变的角度来说，当归属于第四代电子设计方法学。与可综合RTL代码对业内技术发展影响力一样，ESL技术很好地解决了RTL不能解决的设计当中的诸多问题，大大提升了设计质量以及效率，成为电子系统设计的里程碑式技术方法，也必将成为今后若干年电子设计技术的主要研究方向。</span> <p><br /><span style="font-family: Times New Roman">　　ESL方法的主要特性有：设计者只需关注系统模型的功能设计及验证，而不用关注具体实现方法；整个系统不论是软件还是硬件可用统一的高级语言描述，如ANSI C语言；具有完备的系统级验证方法，包括软硬件的合理划分及协同验证；具有完备的设计重用解决方案，大量的软件算法IP核可以直接移植到硬件当中；具有快速的系统实现方法，可以将整个系统模型快速可靠的自动优化实现到目标硬件平台上。</span></p><p><br /><span style="font-family: Times New Roman">　　上文的描述体现了ESL技术的先进性，但是真正从方法学演进到工程应用还应得益于ESL工具的产生与发展。有据可查，成熟的ESL工具是21世纪的产物，特别是2003年ImpulseC的推出极大促进了ESL技术的普及和发展，在相当长时间里引领此项技术的发展潮流。</span></p><p><br /><span style="font-family: Times New Roman">　　实践ImpulseC</span></p><p><br /><span style="font-family: Times New Roman">　　由Impulse Accelerated公司于2003年推出的Impulse Codeveloper（简称为ImpulseC）一经面世就成为了各大电子设计公司企业争相实践的平台。为了增加直观性，笔者用数字信号处理领域当中的经典算法--FFT作为示例来测试其性能。</span></p><p><br /><span style="font-family: Times New Roman">　　在ImpulseC当中进行系统设计可以通过特定的流程来实现。而从该流程中可以看出，我们按照流程向导操作，从应用程序级的ANSI C代码输入到完成任意平台的实现，都是无缝连接的。以下是此次评测步骤：</span></p><p><br /><span style="font-family: Times New Roman">　　第一步，输入代码到Codeveloper平台当中，这是ImpulseC的集成开发环境。</span></p><p><br /><span style="font-family: Times New Roman">　　这是一个基4算法的32位浮点FFT描述。为了考量ImpulseC的自动优化能力，此次试验过程没有添加任何的优化指令。</span></p><p><br /><span style="font-family: Times New Roman">　　第二步，对代码进行功能测试。ImpulseC提供了一个完整的C级代码调试环境。我们不但可以对其进行GCC编译并直接运行仿真，而且可以通过ImpulseC提供的接口直接将代码导入到MS Visual Studio、Borland C++、Turbo C等第三方调试工具当中进行调试分析。除此之外，ImpulseC还提供了模块级数据分析察看工具Application Monitor,在此当中可以专注于随着运行时间而变化的模块或者函数之间数据传递，可以对功能错误进行更加明确的定位。</span></p><p><br /><span style="font-family: Times New Roman">　　ESL方法学的核心之一在于重点关注系统模型的功能，而且相对RTL来讲，高级语言的调试手段非常丰富。所以，笔者推荐系统调试在高级语言阶段完成大部分工作。</span></p><p><br /><span style="font-family: Times New Roman">　　第三步，系统综合与实现。通过ImpulseC提供的CoBuilder可以直接将可综合C代码优化综合生成可综合的RTL（VHDL/Verilog）代码。除此之外，在综合过程当中ImpulseC可以根据代码的结构与描述方式自动增加各类优化方式。当然，所有的优化方式都可以通过设计师来明确化。这些优化方式包括：Pipeline,Unroll,Primitive等。如果需要明确化，可通过Pragma例化。</span></p><p><br /><span style="font-family: Times New Roman">　　第四步，对生成代码进行逻辑综合并评价比较。综合后生成的代码总共由2个文件与1个文件夹组成，包括FFT代码的VHDL/Verilog实现及相应的库。将代码导入到ISE当中，创建工程并直接综合，可得到设计的时序与面积预估。</span></p><p><br /><span style="font-family: Times New Roman">　　通过典型的Verilog实现对比，ImpulseC综合后的时序和面积与RTL描述差距很小。这证明了ImpulseC优异的综合能力及优化能力。此外，这是由工具自动优化生成的代码，没有进行任何的人工干预。</span></p><p><br /><span style="font-family: Times New Roman">　　第五步，RTL代码的验证。ImpulseC可以自动生成RTL代码的Testbench,并且可直接应用于RTL仿真器进行仿真，通过这种方法可完成功能等效验证。</span></p><p><br /><span style="font-family: Times New Roman">　　上述5个步骤也是一个典型的算法硬件化流程。在ImpulseC当中，设计者只需要关注C算法功能的正确性就可以快速完成一个高质量的硬件IP设计。除此之外，ImpulseC还可以支持SoPC、SoC等以处理器为核心的系统设计，可根据设计需求自动产生可配置的各类处理器总线模型，从而大大缩短一个完整的系统设计由桌面到市场的时间。</span></p><p><br /><span style="font-family: Times New Roman">　　ImpulseC的应用状况及前景</span></p><p><br /><span style="font-family: Times New Roman">　　ImpulseC是到目前为止最为完整的最优秀的基于ANSI C的ESL设计开发平台，可以帮助设计者完成快速的算法硬件化及完整的电子系统快速实现。这无疑解决了现有手段所亟待解决的问题。自2003年推出以后，ImpulseC得到了大量业内用户的好评，已经成为这些用户的系统设计首选。ImpulseC主要优势归纳起来有以下几点：完整的ANSI C支持，多层次系统综合优化手段，全方位的系统调试手段，等效验证解决方案，全面的各类平台支持。</span></p><p><br /><span style="font-family: Times New Roman">　　ImpulseC的应用领域涵盖了多个行业，如航空、航天、防御军工、金融、民用等领域。全球公认的10大防御企业已全部采用ImpulseC.ImpulseC在国内也同样拥有大量用户。</span></p><p><br /><span style="font-family: Times New Roman">　　随着ESL技术的不断发展、ESL平台的不断完善，其最终将取代传统的电子设计手段，而ImpulseC作为其中的姣姣者，将引领此项技术不断发展。我们有理由相信，随着时间的推移，ImpulseC会更加完善，更加能够融入到我们的应用当中。</span></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?211</link>
<title><![CDATA[H.264 VHDL]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Mon, 17 Oct 2011 02:55:36 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?211</guid> 
<description>
<![CDATA[ 
	<p>The H.264 VHDL core is a hardware implementation of the H.264 video compression algorithm. The core accepts up to the highest resolution HDTV video stream as input and outputs the encoded bitstream. Simple, fully synchronous design with low gate count.<br /><a href="http://sourceforge.net/projects/h264vhdl/">http://sourceforge.net/projects/h264vhdl/</a></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?210</link>
<title><![CDATA[hardh264]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Mon, 17 Oct 2011 02:51:37 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?210</guid> 
<description>
<![CDATA[ 
	<p>A hardware H.264 video encoder written in VHDL suited to non-interlaced IP cameras and megapixel cameras. Designed to be synthesized into an FPGA or ASIC. Fast and small. Modular. Extensible.<br /><a href="http://sourceforge.net/projects/hardh264/">http://sourceforge.net/projects/hardh264/</a></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?124</link>
<title><![CDATA[ABEL]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Mon, 10 Oct 2011 13:14:40 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?124</guid> 
<description>
<![CDATA[ 
	ABEL:Advanced Boolean Equation Language, 普遍使用的三种硬件描述语言的一种（ABEL，VHDL，Verilog)，用它来描述逻辑函数，可方便设计者使用PLD（可编译逻辑器件）来实现函数功能。<br />&nbsp;　　ABEL程序是包含一些元素的文本文件：<br />&nbsp;　　&times;文档，包括程序名和注释<br />&nbsp;　　&times;标识逻辑函数输入、输出的说明<br />&nbsp;　　&times;用来指定要实现的逻辑函数的语句<br />&nbsp;　　&times;实现逻辑函数功能的PLD或其他目标器件的类型说明<br />&nbsp;　　&times;用来指定在一定输入的条件下，逻辑函数期望输出的&ldquo;测试向量&rdquo;。<br />&nbsp;　　同时，ABDL（Advanced Boolean Equation Language）是Data I/O公司的注册商标。 
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?53</link>
<title><![CDATA[Altium Designer]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Thu, 06 Oct 2011 07:43:28 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?53</guid> 
<description>
<![CDATA[ 
	Altium Designer 提供了唯一一款统一的应用方案，其综合电子产品一体化开发所需的所有必须技术和功能。Altium Designer 在单一设计环境中集成板级和FPGA系统设计、基于FPGA和分立处理器的<span style="color: #136ec2">嵌入式软件开发</span>以及PCB版图设计、编辑和制造。并集成了现代设计数据管理功能,使得Altium Designer成为电子产品开发的完整解决方案－一个既满足当前，也满足未来开发需求的解决方案。
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?52</link>
<title><![CDATA[Cadence]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[fpga/cpld]]></category>
<pubDate>Thu, 06 Oct 2011 03:29:51 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?52</guid> 
<description>
<![CDATA[ 
	Cadence Design Systems Inc.是全球最大的电子设计技术(Electronic Design Technologies)、程序方案服务和设计服务供应商。其解决方案旨在提升和监控半导体、<span style="color: #136ec2">计算机系统</span>、网络工程和电信设备、<span style="color: #136ec2">消费电子产品</span>以及其它各类型电子产品的设计。产品涵盖了电子设计的整个流程，包括系统级设计，功能验证，IC综合及布局布线，模拟、混合信号及射频IC设计，全定制<span style="color: #136ec2">集成电路设计</span>，IC物理验证，PCB设计和硬件仿真建模等。 其总部位于美国<span style="color: #136ec2">加州</span>圣何塞（San Jose），在全球各地设有销售办事处、设计及研发中心。<br /><span class="headline-content">Cadence 公司产品介绍<br /></span><span class="headline-content"><h3 class="headline-2 bk-sidecatalog-title"><span class="headline-content">1、板级电路设计系统</span></h3><p>　　包括原理图输入、生成、模拟数字/混合电路仿真，fpga设计，pcb编辑和自动布局布线mcm电路设计、高速pcb版图的设计仿真等等。包括： </p><p>　　* Concept HDL原理图设计输入工具，有for NT和for Unix的产品。 </p><p>　　* Check Plus HDL原理图设计规则检查工具。（NT &amp; Unix） </p><p>　　* SPECTRA Quest Engineer PCB版图布局规划工具（NT &amp; Unix） </p><p>　　* Allegro　Expert专家级PCB版图编辑工具　（NT &amp; Unix) </p><p>　　* SPECTRA Expert AutoRouter 专家级pcb自动布线工具 </p><p>　　* SigNoise信噪分析工具 </p><p>　　* EMControl <span style="color: #136ec2">电磁兼容性</span>检查工具 </p><p>　　* Synplify FPGA / CPLD综合工具 </p><p>　　* HDL Analyst HDL分析器 </p><p>　　* Advanced Package Designer先进的MCM封装设计工具 </p><h3 class="headline-2 bk-sidecatalog-title"><span class="headline-content">2、Alta系统级无线设计</span></h3><p>　　这一块的产品主要是应用于网络方面的，我个人以为。尤其是它包括有一套的gsm模型，很容易搞cdma等等之类的东西的开发。但是我觉得做信号处理和图象处理也可以用它，因为它里面内的spw太牛了，至少是看起来是，spw最牛的地方就是和hds的接口，和matlab的接口。matlab里面的很多模型可以直接调入spw，然后用hds生成<span style="color: #136ec2">c语言</span>仿真代码或者是hdl语言仿真代码。（这我没有license，没有试过，看openbook上说的）。也就是说，要是简单行事的话，就可以直接用matlab做个模型，然后就做到版图了，呵呵。 </p><p>　　Alta主要有下面的一些Package: </p><p>　　* SPW (Cierto Signal Processing Work System)信号处理系统。 </p><p>　　可以说，spw包括了matlab的很多功能，连demo都有点象，呵呵。它是面向电子系统的模块化设计、仿真和实现的环境。它的通常的应用领域包括无线和有线载波通信、多媒体和网络设备。在进行算法设计、滤波器设计、c Code生成、软/硬件结构联合设计和硬件综合的理想环境。它里面非常有意思的就是信号计算器。 </p><p>　　* HDS (Hardware Design System)硬件系统设计系统 </p><p>　　它现在是SPW的集成组件之一。包括仿真、库和分析扩展部分。可以进行spw的定点分析行为级和rtl级的代码生成。 </p><p>　　* Mutimedia多媒体 （Multimedia Design Kit) </p><p>　　我没有见识过这部分的东东。在产品发布会的演示上看起来倒是很有意思。据说可以很快的生成一个多媒体的应用环境。它可以进行多媒体应用的设计，包括<span style="color: #136ec2">电视会议系统</span>、数字电视等等以及任何种类的图象处理系统的设计。 </p><p>　　* 无线技术Wireless（IS-136 Verification Environment) </p><p>　　无线电技术标准系统级验证工具，可以在系统级的抽象层上生成、开发和改进遵守IS-54/136 标准的信号处理算法。在完成硬件结构设计后，就可以使用hds直接生成可综合的hdl描述和相应的标准检测程序（testbench）。 </p><p>　　* IS-95无线标准系统级验证 </p><p>　　* BONeS网络衉议分析和验证的设计工具。 </p><p>　　这个东东看起来很有意思。它是一套软件系统，专门用来做<span style="color: #136ec2">多媒体网络</span>结构和衉议的设计这个东东看起来很有意思。它是一套软件系统，专门用来做多媒体网络结构和衉议的设计的。可以用来快速的生成和分析<span style="color: #136ec2">结构单元</span>之间的信息流的抽象模型，并建立一个完整的<span style="color: #136ec2">无线网络</span>的运作模型。例如，用户可以改进atm转换器的算法，并建立其基于微处理器包括高速缓存和内存和总线、通信处理方法的应用模型。 </p><p>　　* G、VCC 虚拟衉同设计工具包 </p><p>　　它是用来进行基于可重用的ip核的系统级设计环境。 </p><p>　　在上面的这些东西中，我觉得很重要的还是需要有库的支持，例如在spw里面就要有对应的不同的算法的hdl库的支持，才能够得到最后rtl级的实现。在大学版中，这些部分的license和部分bin代码也没有提供。 </p><h3 class="headline-2 bk-sidecatalog-title"><span class="headline-content">3、逻辑设计与验证（LDV）设计</span></h3><p>　　这部分的软件大家都应该是很熟悉的，因为pc版的d版好象现在已绮很普及了。^-^这里简单介绍一下cadence的ldv流程，虽然感觉大家用synopssy还是居多。 </p><p>　　首先是老板产生一个创意，然后就是设计人员（学生）使用vhdl或者是verilog语言对设计来进 行描述，生成hdl代码。然后，可以用 Verilog-XL, NC-Verilog, LeapfrogVHDL NC-VHDL等工具来进行行为级仿真，判断设计的可行性，验证模块的功能和设计的debug。然后是调试和分析环境中使用代码处理箱（verisure/for verilog) (VHDLCover/for VHDL)分析仿真结果，验证测试级别。然后用Ambit BuildGates进行综合，并使用综合后的时延估计（SDF文件）来进行门级仿真，然后再使用verifault进行故障仿真。 </p><p>　　以上是很简单的一个流程，实际上系统级设计后，就应该进行设计仿真的，要是设计是一个大的模块的话。而且在综合的时候，写综合限制文件也是很麻烦的，要求很多次的反复。上面的流程还不包括测试的加入（如扫描啦什么的）。上面的流程对于小设计是可以的。 </p><p>　　LDV包括的模块有下面的这些东西： </p><p>　　* verilog-xl仿真器 </p><p>　　* Leapfrog VHDL仿真器 </p><p>　　支持混合语言的仿真，其vhdl语言的仿真是通过编译后仿真，加快了速度。 </p><p>　　* Affirma NC Verilog仿真器 </p><p>　　其主要的特点是适合于大系统的仿真。 </p><p>　　* Affirma NC VHDL仿真器 </p><p>　　适用于<span style="color: #136ec2">VHDL语言</span>的仿真。 </p><p>　　* Affirema 形式验证工具--等价检验器 </p><p>　　* Verifault-XL 故障仿真器 </p><p>　　感觉故障仿真是最费时间的仿真步骤。用来测试芯片的可测性设计的。 </p><p>　　* VeriSure代码覆盖率检查工具 </p><p>　　* Envisia Build Gates 综合工具 </p><p>　　Ambit 的BuildGates的特性中，我觉得最好用的应该是它的PKS的feature，当然，呵呵我没有它的license。因为在pks feature中，ambit可以调用se的pdp等物理布局工具来进行时延估计。这样的话，我觉得它的Timing 会比synopsys要好。在我试过的synopsys的小的设计中，大概它的误差在100%左右，呵呵。综合后时间是2.9ns,布局布线和优化后的时间是5ns。可是ambit的综合肯定是要比synopsys的差的，因为它没有很大的库的支持，在大的逻辑块的综合的时候我觉得就可以很明显的感觉出来的。我没有具体试过，那位大虾有时间可以比较一下他们的综合特性。 </p><h3 class="headline-2 bk-sidecatalog-title"><span class="headline-content">4、时序驱动的深亚微米设计</span></h3><p>　　这部分是底层设计的软件。底层设计的工作我感觉是细活，来来回回是需要走很多次重复的流程的。在以前的设计流程中( .6um及其以上 )，一般情况下对于连线延时是可以不用考虑，或是说它们对设计的影响不算很大。在设计完成后，做一下pex，然后仿真一下，小设计的话，多半是可以通过的。 </p><p>　　现在的很多软件都直接在布局阶段就将线路延时考虑进去，这也是现在的深亚微米设计的要求。因为在设计中，连线延时对整体设计的影响很大，因此甚至在综合阶段就需要考虑到floorplan的影响。synopsys和ambit和jupiter(Avanti!公司的综合软件)等在它们的综合过程中都加入了这样的考虑。 </p><p>　　candence的软件中，有SE和design planner两个主要的软件来进行时序驱动的设计,Cadence 的这块的软件推出很早，可惜就是更新比较慢，现在象avanti公司的软件都把布局布线，时序分析和综合等等几乎全套的流程都统一起来的时候，cadence现在在底层还没有什么创新的地方，还是几年前的模样。 </p><h3 class="headline-2 bk-sidecatalog-title"><span class="headline-content">5、全定制ic设计工具</span></h3><p>　　* Virt uos Schematic Composer : IC Design Entry 它是可以进行混合输入的原理图输入方式。支持 vhdl/hdl语言的文本输入。 </p><p>　　* Affirma Analog DEsign Environment </p><p>　　这是一个很好的混合信号设计环境 </p><p>　　* Virtuos Layout Editor版图编辑 </p><p>　　它支持参数化单元，应该是一个很好的特性。 </p><p>　　* Affirma Spectra 高级电路仿真器 </p><p>　　和hspice一类的仿真器。 </p><p>　　* Virtuoso Layout Synthesizer </p><p>　　直接的layout生成工具，小规模设计环境 </p><p>　　* Assura 验证 环境，包括diva </p><p>　　* dracula验证和参数提取包 </p><p>　　* ICCragtsman 布局设计的环境。在面向ip的设计中比较合适。</p></span>
]]>
</description>
</item>
</channel>
</rss>