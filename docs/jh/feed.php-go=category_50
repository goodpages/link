<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?5886</link>
<title><![CDATA[如何打一手好Log]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Wed, 19 Feb 2014 10:31:02 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?5886</guid> 
<description>
<![CDATA[ 
	<div id="cnblogs_post_body" style="margin: 0px 0px 20px; padding: 0px; color: #333333; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 25px"><p style="margin: 10px auto; padding: 0px">如果项目上过线的话，那你一定知道Log是多么重要。</p><p style="margin: 10px auto; padding: 0px">　　为什么说Log重要呢？因为上线项目不允许你调试，你只能通过Log来分析问题。这时打一手好Log的重要性绝不亚于写一手好代码。项目出问题时，你要能拿出Log证明自己负责的部分没有问题，如果是自己的问题，要从Log里快速找出错误原因。如果没有从Log里找出错误原因，那一定是一件很悲催的事情，特别是在bug不容易重现的情况下。那简直就是叫天天不灵，叫地地不应啊。</p><p style="margin: 10px auto; padding: 0px">&nbsp;</p><p style="margin: 10px auto; padding: 0px">　　一.Log级别</p><p style="margin: 10px auto; padding: 0px">　　Log最常用的级别就是DEBUG，INFO，WARN，ERROR，其他的很少用。如何运用合适的Log级别也是非常重要的，在不该用ERROR的地方用了ERROR，可能会给你带来额外的麻烦。下边仅根据自己的使用习惯，分别说一下我对各种级别的理解。</p><p style="margin: 10px auto; padding: 0px">　　1.ERROR：</p><p style="margin: 10px auto; padding: 0px">　　ERROR是错误的意思，但不代表出现异常的地方就该打ERROR。我认为ERROR是相对程序正确运行来说的，如果出现了ERROR那就代表出问题了，开发人员必须要查一下原因，或许是程序问题，或许是环境问题，或许是理论上不该出错的地方出错了。总之，如果你觉得某个地方出问题时需要解决，就打ERROR，如果不需要解决就不要打ERROR。</p><p style="margin: 10px auto; padding: 0px">　　举例来说，如果有一个接口。调用者传过来的参数不在你的接受范围内，在这种情况下你不能打ERROR，因为传什么值是用户决定的，并不影响程序正确运行。想象一下，如果你的服务器上有监控程序的话，检测到ERROR或WARN就报警，参数错误你也打ERROR，那运维人员会疯掉的。</p><p style="margin: 10px auto; padding: 0px">　　如果做一个对讲机，在解析语音数据包时出错了，那就要打ERROR了，因为这个是理论上不该出错的地方，要不就是你的解析代码有问题，要不就是开发人员在拼凑语音包时存在问题，这个时候需要你来找出问题的原因。所以应该打ERROR。</p><p style="margin: 10px auto; padding: 0px">　　2.WARN：</p><p style="margin: 10px auto; padding: 0px">　　WARN是指出现了不影响程序正确运行的问题，WARN也是问题但不影响程序正常运行，如果WARN出现的过于频繁或次数太多，那就代表你要检查一下程序或环境或依赖程序是否真的出问题了。</p><p style="margin: 10px auto; padding: 0px">　　假如你访问一个接口，设置了一个超时，超时之后会抛异常，你在try块里不该打ERROR也不该打INFO来无视它，这时你应该打WARN，紧紧是警告一下，如果超时过多那就该检查一下了，是不是对方接口有问题了或者是网络环境出问题了。</p><p style="margin: 10px auto; padding: 0px">　　3.INFO和DEBUG：</p><p style="margin: 10px auto; padding: 0px">　　ERROR和WARN是指有问题，而INFO和DEBUG就是指一般的信息了。在程序出问题时，如果这条log可以帮助你分析问题或查看程序的运行情况，那就应该打个INFO。如果仅仅是为了在调试阶段查看程序是否运行正确那就要打DEBUG。前边讨论的接口参数错误问题，就应该打个INFO了，调用者说你的接口总是返回错误代码，你可以告诉他，是他的哪个参数传错了。</p><p style="margin: 10px auto; padding: 0px">&nbsp;</p><p style="margin: 10px auto; padding: 0px">　　二.如何打</p><p style="margin: 10px auto; padding: 0px">　　1.log必备信息</p><p style="margin: 10px auto; padding: 0px">　　在每一条log中都要将时间、类名及函数名，可以的话将行号也打印出来（不建议手写行号），像java的log4j就是不错的。</p><p style="margin: 10px auto; padding: 0px">　　2.函数开始结束处</p><p style="margin: 10px auto; padding: 0px">　　在重要函数的开始结束出应该打上log&nbsp;，这样在看log时会比较直观，什么时候开始什么时候结束就会一目了然，万一中间出异常导致程序退出了，也知道是在哪个函数突然中断的。也同样适用于一个重要逻辑块的开始结束。</p><p style="margin: 10px auto; padding: 0px">　　3.返回结果</p><p style="margin: 10px auto; padding: 0px">　　尽量在重要函数或web接口的每个返回分支打印返回结果。在出现不好分析的异常时，从细节下手，这时log会派上用场。如果跟合作方在数据方面出现争议也可以及时拿出证据。</p><p style="margin: 10px auto; padding: 0px">　　4.添加Exception异常的捕获</p><p style="margin: 10px auto; padding: 0px">　　如果你在代码中捕获了某种异常，那你要在try块后添加Exception的捕获，以防出现运行时异常中断程序。</p><p style="margin: 10px auto; padding: 0px">　　5.务必打印堆栈信息</p><p style="margin: 10px auto; padding: 0px">　　在异常捕获代码中务必要将堆栈信息打印出来，否则打了那么多的log可能会功亏一篑。</p><p style="margin: 10px auto; padding: 0px">　　6.多线程的log</p><p style="margin: 10px auto; padding: 0px">　　在多线程的程序中，log最好要标记thredId，否则可能不知道是哪个线程的作业，也无法有条理的来观察一个线程。</p><p style="margin: 10px auto; padding: 0px">　　7.成功失败标志</p><p style="margin: 10px auto; padding: 0px">　　如果某个函数是做一件比较关键的事情，那么这件事情成功还是失败了，要打印log，否则关键事件运行结果如何都拿不出证据的话，实在是不能让人信服。</p><p style="margin: 10px auto; padding: 0px">　　8.前后log的关系</p><p style="margin: 10px auto; padding: 0px">　　如果是web程序或接口，那log就不是按照你预定的顺序出现的，可能是好几个响应的log穿插在一起的。代码里如果有几条log前后存在一定的数据关系，那么要将这几条log的关联信息打出来，用来确定是针对同一个响应的。如果没有明确的标志，很难说后边的log跟前边的log是同一个响应或者是针对同一条数据。</p><p style="margin: 10px auto; padding: 0px">　　9.关于耗时</p><p style="margin: 10px auto; padding: 0px">&nbsp;　　访问一个第三方接口、上传下载文件等可能耗时的操作，都要记录完成这个操作所耗的时间。否则程序性能出了问题，你不知道是网络原因呢，还是你调用的第三方接口性能出现问题呢，还是你自己程序的问题呢。</p><p style="margin: 10px auto; padding: 0px">　　10.关于数量</p><p style="margin: 10px auto; padding: 0px">&nbsp;　　涉及到数量的操作要打印log，比如查询数据库和批量拷贝文件、上传下载、批量格式转换等批量操作，设计到的数量要打印出来。</p><p style="margin: 10px auto; padding: 0px">&nbsp;</p><p style="margin: 10px auto; padding: 0px">　　总之，打log的目的是为了迅速排错或在有争议时拿出证据证明自己。基于这个目的，log不在多，只要抓住一切对自己有利的信息，就可以了。</p><p style="margin: 10px auto; padding: 0px">　　想起其他的再继续补充吧，欢迎大家拍砖补充。</p><p style="margin: 10px auto; padding: 0px">　　</p></div><div id="MySignature" style="margin: 0px; padding: 0px; color: #333333; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 25px">本人学识尚浅，写文目的是为了得到大家指点。 倘若文章帮到了您，那真是好极了。</div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2033</link>
<title><![CDATA[短小精悍的C++单元测试框架CppUnitLite源码分析 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Fri, 09 Mar 2012 07:01:12 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2033</guid> 
<description>
<![CDATA[ 
	这几天集中精力阅读2个C++的<span class="t_tag">测试</span><span class="t_tag">框架</span>源代码，一个是CppUnit，另一个就是今天要说的CppUnitLite啦。 <br /><br />CppUnitLite是一个由Michael Feathers开发的短小精悍的C++测试框架，Michael Feathers同时也是CppUnit的原作者。使用者可以通过这个框架根据自己的实际需要进行扩展。 <br /><br /><a rel="nofollow" href="http://www.objectmentor.com/resources/downloads.html" target="_blank">http://www.objectmentor.com/resources/downloads.html</a> <br /><br /><a rel="nofollow" href="http://www.objectmentor.com/resources/bin/CppUnitLite.zip" target="_blank">http://www.objectmentor.com/resources/bin/CppUnitLite.zip</a> <br /><br />这个框架的目的在于： <br /><br />为开发者提供容易编写的独立的测试。 <br /><br />遵循JavaUnit的模式，避免使用C++的一些高级特性，比如RTTI，异常，<span class="t_tag">模板</span>等，这些因素不利于程序的移植。 <br /><br />现在假设有一个Deque类需要测试，测试所用的代码如下： <div class="blockcode"><div id="code27446_-1"><ol><li>#include &quot;TestHarness.h&quot; <br /></li><li>#include &quot;Deque.h&quot; <br /></li><li>//from <a href="http://www.cnblogs.com/gpcuster" target="_blank">http://www.cnblogs.com/gpcuster</a><br /></li><li><br /></li><li>int main() <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; TestResult tr; <br /></li><li>&nbsp; &nbsp; TestRegistry::runAllTests(tr); <br /></li><li>&nbsp; &nbsp; return 0; <br /></li><li>&#125; <br /></li><li>TEST( Deque, construction) <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li>&nbsp; &nbsp; CHECK ( 0 == d.size() ); <br /></li><li>&#125; <br /></li><li>TEST (Deque, dont_try_suicide) <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li>&nbsp; &nbsp; d.push_front(1); <br /></li><li>&nbsp; &nbsp; d = d; <br /></li><li>&nbsp; &nbsp; CHECK( 1 == d.pop_front()); <br /></li><li>&#125;<br /></li></ol></div><em>复制代码</em></div>tr是用来保存测试的结果的，你可以通过继承TestResult来添加自己需要，比如显示成功的测试有多少，失败的测试有多少。 <br /><br />TestRegistry::runAllTests(tr);这段代码表示开始执行测试。朋友们一定就会问啦，需要测试的代码是怎么关联进去的？要回答这个问题，我们可以看看实际要测试的代码，比如 <div class="blockcode"><div id="code27446_0"><ol><li>TEST( Deque, construction) <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li>&nbsp; &nbsp; CHECK ( 0 == d.size() ); <br /></li><li>&#125;<br /></li></ol></div><em>复制代码</em></div>这个函数看起来很奇怪，其实TEST是一个宏定义，这个框架中定义啦一个Test的基类，作者使用啦一个非常巧妙的宏（TEST）来生成一个派生与Test的类型，类型的名称由这个看似函数而不是函数的第一个参数（Deque）和第二个参数（construction）组成。同时实现啦Test::run函数，这里的实现也就是 <div class="blockcode"><div id="code27446_1"><ol><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li>&nbsp; &nbsp; CHECK ( 0 == d.size() ); <br /></li><li>&#125;<br /></li></ol></div><em>复制代码</em></div>其中的CHECK ( 0 == d.size() );也是用宏实现的。 <br /><br />为了能让大家看得更清楚，我们看看 <div class="blockcode"><div id="code27446_0"><ol><li>TEST( Deque, construction) <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li>&nbsp; &nbsp; CHECK ( 0 == d.size() ); <br /></li><li>&#125;<br /></li></ol></div><em>复制代码</em></div>这段代码在编译的时候变成了这个样子： <div class="blockcode"><div id="code27446_3"><ol><li>class constructionDequeTest : public Test <br /></li><li>&#123; <br /></li><li>public: <br /></li><li>&nbsp; &nbsp; constructionDequeTest () : Test (&quot;Deque&quot; &quot;Test&quot;) &#123;&#125; &#92; <br /></li><li>void run (TestResult&amp; result_); <br /></li><li>&#125;constructionDequeInstance; <br /></li><li><br /></li><li>void constructionDequeTest::run (TestResult&amp; result_) <br /></li><li>&#123; <br /></li><li>&nbsp; &nbsp; Deque d; <br /></li><li><br /></li><li>&nbsp; &nbsp; //CHECK ( 0 == d.size() ); <br /></li><li>&nbsp; &nbsp; &#123; <br /></li><li>&nbsp; &nbsp; &nbsp; &nbsp; if (!(0 == d.size())) <br /></li><li>&nbsp; &nbsp; &nbsp; &nbsp; &#123; <br /></li><li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_.addFailure (Failure (name_, __FILE__,__LINE__, &quot;0 == d.size()&quot;)); <br /></li><li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return; <br /></li><li>&nbsp; &nbsp; &nbsp; &nbsp; &#125; <br /></li><li>&nbsp; &nbsp; &#125; <br /></li><li>&#125;<br /></li></ol></div><em>复制代码</em></div>这样，在编译的时候就自动生成啦一个用于测试类。<br /><br />注意类定义的最后同时进行了实例化constructionDequeInstance，通过查看Test的代码你会发现，在实例话的时候调用了TestRegistry::addTest (this);这样，就把这个测试类的代码添加到了TestRegistry中去，同时TestRegistry又实现啦Singleton Pattern单件模式，所以我们也就很自然地回答了开始的问题（TestRegistry::runAllTests(tr);这段代码表示开始执行测试。朋友们一定就会问啦，需要测试的代码是怎么关联进去的？）。<br /><br />如果大家有兴趣，可以进一步看一看Google公布的<span class="t_tag">开源</span>c++单元测试框架<a rel="nofollow" href="http://code.google.com/p/googletest/" target="_blank"><span style="color: #000000">googletest</span></a><br /><br />Google's framework for writing C++ tests on a variety of platforms (Linux, Mac OS X, Windows, Cygwin, Windows CE, and Symbian). Based on the xUnit architecture. Supports automatic test discovery, a rich set of assertions, user-defined assertions, death tests, fatal and non-fatal failures, value- and type-parameterized tests, various options for running the tests, and XML test report generation.<br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2032</link>
<title><![CDATA[Google Test Primer ：开始使用Google C++ 测试框架]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Fri, 09 Mar 2012 07:00:12 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2032</guid> 
<description>
<![CDATA[ 
	<p><strong>Google C++ Testing Framework Primer</strong></p><p></p><p>翻译：<a href="http://rayleex.spaces.live.com/blog/cns!C32DFA3924AF2128!218.entry" target="_blank">Ray Li </a>(<a href="mailto:ray.leex@gmail.com">ray.leex@gmail.com</a>) <br />修改日期：2008年7月6日<br />原文参见：<a href="http://code.google.com/p/googletest/wiki/GoogleTestPrimer">http://code.google.com/p/googletest/wiki/GoogleTestPrimer</a> </p><p></p><p><strong>Introduction</strong><strong>：为什么需要</strong><strong>Google C++ </strong><strong>测试框架？</strong> </p><p></p><p>Google C++ 测试框架帮助你更好地编写C++测试。 </p><p></p><p>无论你是在Linux，Windows，还是Mac环境下工作，只要你编写C++代码，Google 测试框架都可以帮上忙。 </p><p></p><p>那么，哪些因素才能构成一个好的测试？以及，Google C++ 测试框架怎样满足这些因素？我们相信： </p><ol><li>测试应该是<em>独立</em>、<em>可重复</em>的。因为其他测试成功或失败而导致我们要对自己的测试进行debug是非常痛苦的。Google C++ 测试框架通过将每个测试在不同的对象中运行，使得测试分离开来。当一个测试失败时，Google C++ 测试框架允许你独立运行它以进行快速除错。 </li><li>测试应该能够被很好地<em>组织</em>，并反映被测代码的结构。Google C++ 测试框架将测试组织成测试案例，案例中的测试可以共享数据和程序分支。这样一种通用模式能够很容易辨识，使得我们的测试容易维护。当开发人员在项目之间转换，开始在一个新的代码基上开始工作时，这种一致性格外有用。 </li><li>测试应该是<em>可移植</em>、<em>可重用</em>的。开源社区有很多平台独立的代码，它们的测试也应该是平台独立的。除开一些特殊情况，Google C++ 测试框架运行在不同的操作系统上、与不同的编译器（gcc、icc、MSVC）搭配，Google C++ 测试框架的测试很容易与不同的配置一起工作。 </li><li>当测试失败时，应该提供尽可能多的、关于问题的<em>信息</em>。Google C++ 测试框架在第一个测试失败时不会停下来。相反，它只是将当前测试停止，然后继续接下来的测试。你也可以设置对一些非致命的错误进行报告，并接着进行当前的测试。这样，你就可以在一次&ldquo;运行-编辑-编译&rdquo;循环中检查到并修复多个bug。 </li><li>测试框架应该能将测试编写人员从一些环境维护的工作中解放出来，使他们能够集中精力于测试的<em>内容</em>。Google C++ 测试框架自动记录下所有定义好的测试，不需要用户通过列举来指明哪些测试需要运行。 </li><li>测试应该<em>快速</em>。使用Google C++ 测试框架，你可以重用多个测试的共享资源，一次性完成设置/解除设置，而不用使一个测试去依赖另一测试。</li></ol><p>因为Google C++ 测试框架基于著名的xUnit架构，如果你之前使用过JUnit或PyUnit的话，你将会感觉非常熟悉。如果你没有接触过这些测试框架，它也只会占用你大约10分钟的时间来学习基本概念和上手。所以，让我们开始吧！ </p><p></p><p>Note：本文偶尔会用&ldquo;Google Test&rdquo;来代指&ldquo;Google C++ 测试框架&rdquo;。 </p><p></p><p><strong>基本概念</strong></p><p></p><p>使用Google Test时，你是从编写<em>断言</em>开始的，而断言是一些检查条件是否为真的语句。一个断言的结果可能是成功、非致命失败，或者致命失败。如果一个致命失败出现，他会结束当前的函数；否则，程序继续正常运行。 </p><p></p><p><em>测试</em>使用断言来验证被测代码的行为。如果一个测试崩溃或是出现一个失败的断言，那么，该测试<em>失败</em>；否则该测试<em>成功</em>。 </p><p></p><p>一个测试案例（test case）包含了一个或多个测试。你应该将自己的测试分别归类到测试案例中，以反映被测代码的结构。当测试案例中的多个测试需要共享通用对象和子程序时，你可以把他们放到一个测试固件（<em>test fixture</em>）类中。 </p><p></p><p>一个<em>测试程序</em>可以包含多个测试案例。 </p><p></p><p>从编写单个的断言开始，到创建测试和测试案例，我们将会介绍怎样编写一个测试程序。 </p><p></p><p><strong>断言</strong> </p><p></p><p>Google Test中的断言是一些与函数调用相似的宏。要测试一个类或函数，我们需要对其行为做出断言。当一个断言失败时，Google Test会在屏幕上输出该代码所在的源文件及其所在的位置行号，以及错误信息。也可以在编写断言时，提供一个自定义的错误信息，这个信息在失败时会被附加在Google Test的错误信息之后。 </p><p></p><p>断言常常成对出现，它们都测试同一个类或者函数，但对当前功能有着不同的效果。ASSERT_*版本的断言失败时会产生致命失败，并<strong>结束当前函数</strong>。EXPECT_*版本的断言产生非致命失败，而不会中止当前函数。通常更推荐使用EXPECT_*断言，因为它们运行一个测试中可以有不止一个的错误被报告出来。但如果在编写断言如果失败，就没有必要继续往下执行的测试时，你应该使用ASSERT_*断言。 </p><p></p><p>因为失败的ASSERT_*断言会立刻从当前的函数返回，可能会跳过其后的一些的清洁代码，这样也许会导致空间泄漏。根据泄漏本身的特质，这种情况也许值得修复，也可能不值得我们关心&mdash;&mdash;所以，如果你得到断言错误的同时，还得到了一个堆检查的错误，记住上面我们所说的这一点。 </p><p></p><p>要提供一个自定义的错误消息，只需要使用&lt;&lt;操作符，或一个&lt;&lt;操作符的序列，将其输入到框架定义的宏中。下面是一个例子： </p><p></p>&nbsp; <div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span>ASSERT_EQ(x.size(),&nbsp;y.size())&nbsp;&lt;&lt;&nbsp;</span><span class="string">&quot;Vectors&nbsp;x&nbsp;and&nbsp;y&nbsp;are&nbsp;of&nbsp;unequal&nbsp;length&quot;</span><span>; &nbsp;&nbsp;</span></span></li><li><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;x.size();&nbsp;++i)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(x[i],&nbsp;y[i])&nbsp;&lt;&lt;&nbsp;</span><span class="string">&quot;Vectors&nbsp;x&nbsp;and&nbsp;y&nbsp;differ&nbsp;at&nbsp;index&nbsp;&quot;</span><span>&nbsp;&lt;&lt;&nbsp;i; &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><p>任何能够被输出到ostream中的信息都可以被输出到一个断言宏中&mdash;&mdash;特别是C字符串和string对象。如果一个宽字符串（wchar_t*，windows上UNICODE模式TCHAR*或std::wstring）被输出到一个断言中，在打印时它会被转换成UTF-8编码。 </p><p></p><p><strong>基本断言</strong> </p><p></p><p>下面这些断言实现了基本的true/false条件测试。 </p><p></p><table border="0" width="500"><tbody><tr><td width="167"><strong>致命断言</strong></td><td width="166"><strong>非致命断言</strong></td><td width="165"><strong>验证条件</strong></td></tr><tr><td width="167">ASSERT_TRUE(<em>condition</em>);</td><td width="166">EXPECT_TRUE(<em>condition</em>); </td><td width="165"><em>condition</em>为真</td></tr><tr><td width="167">ASSERT_FALSE(<em>condition</em>); </td><td width="166">EXPECT_FALSE(<em>condition</em>); </td><td width="165"><em>condition</em> 为假</td></tr></tbody></table><p></p><p>记住，当它们失败时，ASSERT_*产生一个致命失败并从当前函数返回，而EXCEPT_*产生一个非致命失败，允许函数继续运行。在两种情况下，一个断言失败都意味着它所包含的测试失败。 </p><p></p><p>有效平台：Linux、Windows、Mac。 </p><p></p><p><strong>二进制比较</strong> </p><p></p><p>本节描述了比较两个值的一些断言。 </p><p></p><table border="0" width="500"><tbody><tr><td width="166"><strong>致命断言</strong></td><td width="166"><strong>非致命断言</strong></td><td width="166"><strong>验证条件</strong></td></tr><tr><td width="166">ASSERT_EQ(<em>expected</em>, <em>actual</em>);</td><td width="166">EXPECT_EQ(<em>expected</em>, <em>actual</em>);</td><td width="166"><em>expected</em> == <em>actual</em></td></tr><tr><td width="166">ASSERT_NE(<em>val1</em>, <em>val2</em>);</td><td width="166">EXPECT_NE(<em>val1</em>, <em>val2</em>);</td><td width="166"><em>val1</em> != <em>val2</em></td></tr><tr><td width="166">ASSERT_LT(<em>val1</em>, <em>val2</em>);</td><td width="166">EXPECT_LT(<em>val1</em>, <em>val2</em>);</td><td width="166"><em>val1</em> &lt; <em>val2</em></td></tr><tr><td width="166">ASSERT_LE(<em>val1</em>, <em>val2</em>);</td><td width="166">EXPECT_LE(<em>val1</em>, <em>val2</em>);</td><td width="166"><em>val1</em> &lt;= <em>val2</em></td></tr><tr><td width="166">ASSERT_GT(<em>val1</em>, <em>val2</em>);</td><td width="166">EXPECT_GT(<em>val1</em>, <em>val2</em>);</td><td width="166"><em>val1</em> &gt; <em>val2</em></td></tr><tr><td width="166">ASSERT_GE(<em>val1</em>, <em>val2</em>);</td><td width="166">EXPECT_GE(<em>val1</em>, <em>val2</em>);</td><td width="166"><em>val1</em> &gt;= <em>val2</em></td></tr></tbody></table><p></p><p>在出现失败事件时，Google Test会将两个值（<em>Val1</em>和<em>Val2</em>）都打印出来。在ASSERT_EQ*和EXCEPT_EQ*断言（以及我们随后介绍类似的断言）中，你应该把你希望测试的表达式放在<em>actual</em>（实际值）的位置上，将其期望值放在<em>expected</em>（期望值）的位置上，因为Google Test的测试消息为这种惯例做了一些优化。 </p><p></p><p>参数值必须是可通过断言的比较操作符进行比较的，否则你会得到一个编译错误。参数值还必须支持&lt;&lt;操作符来将值输入到ostream中。所有的C++内置类型都支持这一点。 </p><p></p><p>这些断言可以用于用户自定义的型别，但你必须重载相应的比较操作符（如==、&lt;等）。如果定义有相应的操作符，推荐使用ASSERT_*()宏，因为它们不仅会输出比较的结果，还会输出两个比较对象。 </p><p></p><p>参数表达式总是只被解析一次。因此，参数表达式有一定的副作用（side effect，这里应该是指编译器不同，操作符解析顺序的不确定性）也是可以接受的。但是，同其他普通C/C++函数一样，参数表达式的解析顺序是不确定的（如，一种编译器可以自由选择一种顺序来进行解析），而你的代码不应该依赖于某种特定的参数解析顺序。 </p><p></p><p>ASSERT_EQ()对指针进行的是指针比较。即，如果被用在两个C字符串上，它会比较它们是否指向同样的内存地址，而不是它们所指向的字符串是否有相同值。所以，如果你想对两个C字符串（例如，const char*）进行值比较，请使用ASSERT_STREQ()宏，该宏会在后面介绍到。特别需要一提的是，要验证一个C字符串是否为空（NULL），使用ASSERT_STREQ(NULL, c_string)。但是要比较两个string对象时，你应该使用ASSERT_EQ。 </p><p></p><p>本节中介绍的宏都可以处理窄字符串对象和宽字符串对象（string和wstring）。 </p><p></p><p>有效平台：Linux、Windows、Mac。 </p><p></p><p><strong>字符串比较</strong></p><p></p><p>该组断言用于比较两个C字符串。如果你想要比较两个string对象，相应地使用EXPECT_EQ、EXPECT_NE等断言。 </p><p></p><table border="0" width="700"><tbody><tr><td width="235"><strong>致命断言</strong></td><td width="234"><strong>非致命断言</strong></td><td width="229"><strong>验证条件</strong></td></tr><tr><td width="235">ASSERT_STREQ(<em>expected_str</em>, <em>actual_str</em>);</td><td width="234">EXPECT_STREQ(<em>expected_str</em>, <em>actual_str</em>);</td><td width="229">两个C字符串有相同的内容</td></tr><tr><td width="235">ASSERT_STRNE(<em>str1</em>, <em>str2</em>);</td><td width="234">EXPECT_STRNE(<em>str1</em>, <em>str2</em>);</td><td width="229">两个C字符串有不同的内容</td></tr><tr><td width="235">ASSERT_STRCASEEQ(<em>expected_str</em>, <em>actual_str</em>);</td><td width="234">EXPECT_STRCASEEQ(<em>expected_str</em>, <em>actual_str</em>);</td><td width="229">两个C字符串有相同的内容，忽略大小写</td></tr><tr><td width="235">ASSERT_STRCASENE(<em>str1</em>, <em>str2</em>);</td><td width="234">EXPECT_STRCASENE(<em>str1</em>, <em>str2</em>);</td><td width="229">两个C字符串有不同的内容，忽略大小写</td></tr></tbody></table><p></p><p>注意断言名称中出现的&ldquo;CASE&rdquo;意味着大小写被忽略了。 </p><p></p><p>*STREQ*和*STRNE*也接受宽字符串（wchar_t*）。如果两个宽字符串比较失败，它们的值会做为UTF-8窄字符串被输出。 </p><p></p><p>一个NULL空指针和一个空字符串会被认为是<em>不一样</em>的。 </p><p></p><p>有效平台：Linux、Windows、Mac。 </p><p></p><p>参见：更多的字符串比较的技巧（如子字符串、前缀和正则表达式匹配），请参见[Advanced Guide Advanced Google Test Guide]。 </p><p></p><p><strong>简单的测试</strong> </p><p></p><p>要创建一个测试： </p><ol><li>使用TEST（）宏来定义和命名一个测试函数，它们是一些没有返回值的普通C++函数。 </li><li>在这个函数中，与你想要包含的其它任何有效C++代码一起，使用Google Test提供的各种断言来进行检查。 </li><li>测试的结果由其中的断言决定；如果测试中的任意断言失败（无论是致命还是非致命），或者测试崩溃，那么整个测试就失败了。否则，测试通过。&nbsp; </li></ol><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span>TEST(test_case_name,&nbsp;test_name)&nbsp;&#123; &nbsp;&nbsp;</span></span></li><li><span>...&nbsp;test&nbsp;body&nbsp;... &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span>&nbsp; </li></ol></div><p>TEST（）的参数是从概括到特殊的。<em>第一个</em>参数是测试案例的名称，<em>第二个</em>参数是测试案例中的测试的名称。记住，一个测试案例可以包含任意数量的独立测试。一个测试的<em>全称</em>包括了包含它的测试案例名称，及其独立的名称。不同测试案例中的独立测试可以有相同的名称。 </p><p></p><p>举例来说，让我们看一个简单的整数函数： </p><p></p><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&nbsp;Factorial(</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&nbsp;n);&nbsp;</span><span class="comment">//&nbsp;返回n的阶乘</span><span>&nbsp;&nbsp;</span></span>&nbsp; </li></ol></div><p></p><p><span>这个函数的测试案例应该看起来像是： </span></p><p></p><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码 </div></div><ol class="dp-cpp"><li><span><span class="comment">//&nbsp;测试0的阶乘 </span><span>&nbsp;&nbsp;</span></span></li><li><span>TEST(FactorialTest,&nbsp;HandlesZeroInput)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(1,&nbsp;Factorial(0)); &nbsp;&nbsp;</span></li><li><span>&#125; &nbsp;&nbsp;</span></li><li><span class="comment">//&nbsp;测试正数的阶乘 </span><span>&nbsp;&nbsp;</span></li><li><span>TEST(FactorialTest,&nbsp;HandlesPositiveInput)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(1,&nbsp;Factorial(1)); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(2,&nbsp;Factorial(2)); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(6,&nbsp;Factorial(3)); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(40320,&nbsp;Factorial(8)); &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><p></p><p>Google Test根据测试案例来分组收集测试结果，因此，逻辑相关的测试应该在同一测试案例中；换句话说，它们的TEST（）的第一个参数应该是一样的。在上面的例子中，我们有两个测试，HandlesZeroInput和HandlesPostiveInput，它们都属于同一个测试案例FactorialTest。 </p><p></p><p>有效平台：Linux、Windows、Mac。 </p><p></p><p><strong>测试固件（</strong><strong>Test Fixtures</strong><strong>，又做测试夹具、测试套件）：在多个测试中使用同样的数据配置</strong> </p><p></p><p>当你发现自己编写了两个或多个测试来操作同样的数据，你可以采用一个<em>测试固件</em>。它让你可以在多个不同的测试中重用同样的对象配置。 </p><p></p><p>要创建测试固件，只需： </p><ol><li>创建一个类继承自testing::Test。将其中的成员声明为protected:或是public:，因为我们想要从子类中存取固件成员。 </li><li>在该类中声明你计划使用的任何对象。 </li><li>如果需要，编写一个默认构造函数或者SetUp()函数来为每个测试准备对象。常见错误包括将SetUp()拼写为Setup()（小写了u）&mdash;&mdash;不要让它发生在你身上。 </li><li>如果需要，编写一个析构函数或者TearDown()函数来释放你在SetUp()函数中申请的资源。要知道什么时候应该使用构造函数/析构函数，什么时候又应该使用SetUp()/TearDown()函数，阅读我们的FAQ。 </li><li>如果需要，定义你的测试所需要共享的子程序。</li></ol><p>当我们要使用固件时，使用TEST_F()替换掉TEST()，它允许我们存取测试固件中的对象和子程序： </p><p></p><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码 </div></div><ol class="dp-cpp"><li><span><span>TEST_F(test_case_name,&nbsp;test_name)&nbsp;&#123; &nbsp;&nbsp;</span></span></li><li><span>...&nbsp;test&nbsp;body&nbsp;... &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><p></p><p>与TEST()一样，第一个参数是测试案例的名称，但对TEST_F()来说，这个名称必须与测试固件类的名称一些。你可能已经猜到了：_F正是指固件。 </p><p></p><p>不幸地是，C++宏系统并不允许我们创建一个单独的宏来处理两种类型的测试。使用错误的宏会导致编译期的错误。 </p><p></p><p>而且，你必须在TEST_F()中使用它之前，定义好这个测试固件类。否则，你会得到编译器的报错：&ldquo;virtual outside class declaration&rdquo;。 </p><p>对于TEST_F()中定义的每个测试，Google Test将会： </p><ol><li>在运行时创建一个<em>全新</em>的测试固件 </li><li>马上通过SetUp()初始化它， </li><li>运行测试 </li><li>调用TearDown()来进行清理工作 </li><li>删除测试固件。注意，同一测试案例中，不同的测试拥有不同的测试固件。Google Test在创建下一个测试固件前总是会对现有固件进行删除。Google Test不会对多个测试重用一个测试固件。测试对测试固件的改动并不会影响到其他测试。</li></ol><p>例如，让我们为一个名为Queue的FIFO队列类编写测试，该类的接口如下： </p>&nbsp; <div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码 </div></div><ol class="dp-cpp"><li><span><span class="keyword">template</span><span>&nbsp;&lt;</span><span class="keyword">typename</span><span>&nbsp;E&gt;&nbsp;</span><span class="comment">//&nbsp;E为元素类型 </span><span>&nbsp;&nbsp;</span></span></li><li><span class="keyword">class</span><span>&nbsp;Queue&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span class="keyword">public</span><span>: &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;Queue(); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;Enqueue(</span><span class="keyword">const</span><span>&nbsp;E&amp;&nbsp;element); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;E*&nbsp;Dequeue();&nbsp;</span><span class="comment">//&nbsp;返回&nbsp;NULL&nbsp;如果队列为空. </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="datatypes"><strong><span style="color: #2e8b57">size_t</span></strong></span><span>&nbsp;size()&nbsp;</span><span class="keyword">const</span><span>; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;... &nbsp;&nbsp;</span></li><li><span>&#125;;&nbsp;&nbsp;</span></li></ol></div><p>首先，定义一个固件类。习惯上，你应该把它的名字定义为FooTest，这里的Foo是被测试的类。 </p>&nbsp; <div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span class="keyword">class</span><span>&nbsp;QueueTest&nbsp;:&nbsp;</span><span class="keyword">public</span><span>&nbsp;testing::Test&nbsp;&#123; &nbsp;&nbsp;</span></span></li><li><span class="keyword">protected</span><span>: &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">virtual</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;SetUp()&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;q1_.Enqueue(1); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;q2_.Enqueue(2); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;q2_.Enqueue(3); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;virtual&nbsp;void&nbsp;TearDown()&nbsp;&#123;&#125; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;Queue&lt;</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&gt;&nbsp;q0_; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;Queue&lt;</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&gt;&nbsp;q1_; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;Queue&lt;</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&gt;&nbsp;q2_; &nbsp;&nbsp;</span></li><li><span>&#125;;&nbsp;&nbsp;</span></li></ol></div><p>在这个案例中，我们不需要TearDown()，因为每个测试后除了析构函数外不需要进行其它的清理工作了。 </p><p></p><p>接下来我们使用TEST_F()和这个固件来编写测试。 </p><p></p><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span>TEST_F(QueueTest,&nbsp;IsEmptyInitially)&nbsp;&#123; &nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(0,&nbsp;q0_.size()); &nbsp;&nbsp;</span></li><li><span>&#125; &nbsp;&nbsp;</span></li><li><span>TEST_F(QueueTest,&nbsp;DequeueWorks)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>*&nbsp;n&nbsp;=&nbsp;q0_.Dequeue(); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(NULL,&nbsp;n); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;n&nbsp;=&nbsp;q1_.Dequeue(); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;ASSERT_TRUE(n&nbsp;!=&nbsp;NULL); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(1,&nbsp;*n); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(0,&nbsp;q1_.size()); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">delete</span><span>&nbsp;n; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;n&nbsp;=&nbsp;q2_.Dequeue(); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;ASSERT_TRUE(n&nbsp;!=&nbsp;NULL); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(2,&nbsp;*n); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(1,&nbsp;q2_.size()); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">delete</span><span>&nbsp;n; &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span>&nbsp; </li></ol></div><p>上面这段代码既使用了ASSERT_*断言，又使用了EXPECT_*断言。经验上讲，如果你想要断言失败后，测试能够继续进行以显示更多的错误时，你应该使用EXPECT_*断言；使用ASSERT_*如果该断言失败后继续往下执行毫无意义。例如，Dequeue测试中的第二个断言是ASSERT_TURE(n!= NULL)，因为我们随后会n指针解引用，如果n指针为空的话，会导致一个段错误。 </p><p></p><p>当这些测试开始时，会发生如下情况： </p><ol><li>Google Test创建一个QueueTest对象（我们把它叫做t1）。 </li><li>t1.SetUp()初始化t1。 </li><li>第一个测试（IsEmptyInitiallly）在t1上运行。 </li><li>测试完成后，t1.TearDown()进行一些清理工作。 </li><li>t1被析构。 </li><li>以上步骤在另一个QueueTest对象上重复进行，这回会运行DequeueWorks测试。</li></ol><p>有效平台：Linux、Windows、Mac。 </p><p></p><p>注意：当一个测试对象被构造时，Google Test会自动地保存所有的Google Test变量标识，对象析构后进行恢复。 </p><p></p><p><strong>调用测试</strong> </p><p></p><p>TEST()和TEST_F()向Google Test隐式注册它们的测试。因此，与很多其他的C++测试框架不同，你不需要为了运行你定义的测试而将它们全部再列出来一次。 </p><p></p><p>在定义好测试后，你可以通过RUN_ALL_TESTS()来运行它们，如果所有测试成功，该函数返回0，否则会返回1.注意RUN_ALL_TESTS()会运行你链接到的所有测试&mdash;&mdash;它们可以来自不同的测试案例，甚至是来自不同的文件。 </p><p></p><p>当被调用时，RUN_ALL_TESTS()宏会： </p><ol><li>保存所有的Google Test标志。 </li><li>为一个侧测试创建测试固件对象。 </li><li>调用SetUp()初始化它。 </li><li>在固件对象上运行测试。 </li><li>调用TearDown()清理固件。 </li><li>删除固件。 </li><li>恢复所有Google Test标志的状态。 </li><li>重复上诉步骤，直到所有测试完成。</li></ol><p>此外，如果第二步时，测试固件的构造函数产生一个致命错误，继续执行3至5部显然没有必要，所以它们会被跳过。与之相似，如果第3部产生致命错误，第4部也会被跳过。 </p><p></p><p>重要：你不能忽略掉RUN_ALL_TESTS()的返回值，否则gcc会报一个编译错误。这样设计的理由是自动化测试服务会根据测试退出返回码来决定一个测试是否通过，而不是根据其stdout/stderr输出；因此你的main()函数必须返回RUN_ALL_TESTS()的值。 </p><p></p><p>而且，你应该只调用RUN_ALL_TESTS()一次。多次调用该函数会与Google Test的一些高阶特性（如线程安全死亡测试thread-safe death tests）冲突，因而是不被支持的。 </p><p></p><p>有效平台：Linux、Windows、Mac。 </p><p></p><p><strong>编写</strong><strong>main()</strong><strong>函数</strong> </p><p></p><p>你可以从下面这个样板开始: </p><p></p><div class="dp-highlighter"><div class="bar"><div class="tools">Cpp代码</div></div><ol class="dp-cpp"><li><span><span class="preprocessor">#include&nbsp;&quot;this/package/foo.h&quot; </span><span>&nbsp;&nbsp;</span></span></li><li><span class="preprocessor">#include&nbsp;&lt;gtest/gtest.h&gt; </span><span>&nbsp;&nbsp;</span></li><li><span class="keyword">namespace</span><span>&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span class="comment">//&nbsp;测试Foo类的测试固件 </span><span>&nbsp;&nbsp;</span></li><li><span class="keyword">class</span><span>&nbsp;FooTest&nbsp;:&nbsp;</span><span class="keyword">public</span><span>&nbsp;testing::Test&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span class="keyword">protected</span><span>: &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;You&nbsp;can&nbsp;remove&nbsp;any&nbsp;or&nbsp;all&nbsp;of&nbsp;the&nbsp;following&nbsp;functions&nbsp;if&nbsp;its&nbsp;body </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;is&nbsp;empty. </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;FooTest()&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;You&nbsp;can&nbsp;do&nbsp;set-up&nbsp;work&nbsp;for&nbsp;each&nbsp;test&nbsp;here. </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">virtual</span><span>&nbsp;~FooTest()&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;You&nbsp;can&nbsp;do&nbsp;clean-up&nbsp;work&nbsp;that&nbsp;doesn't&nbsp;throw&nbsp;exceptions&nbsp;here. </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;If&nbsp;the&nbsp;constructor&nbsp;and&nbsp;destructor&nbsp;are&nbsp;not&nbsp;enough&nbsp;for&nbsp;setting&nbsp;up </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;and&nbsp;cleaning&nbsp;up&nbsp;each&nbsp;test,&nbsp;you&nbsp;can&nbsp;define&nbsp;the&nbsp;following&nbsp;methods: </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">virtual</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;SetUp()&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;Code&nbsp;here&nbsp;will&nbsp;be&nbsp;called&nbsp;immediately&nbsp;after&nbsp;the&nbsp;constructor&nbsp;(right </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;before&nbsp;each&nbsp;test). </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">virtual</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;TearDown()&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;Code&nbsp;here&nbsp;will&nbsp;be&nbsp;called&nbsp;immediately&nbsp;after&nbsp;each&nbsp;test&nbsp;(right </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;before&nbsp;the&nbsp;destructor). </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;Objects&nbsp;declared&nbsp;here&nbsp;can&nbsp;be&nbsp;used&nbsp;by&nbsp;all&nbsp;tests&nbsp;in&nbsp;the&nbsp;test&nbsp;case&nbsp;for&nbsp;Foo. </span><span>&nbsp;&nbsp;</span></li><li><span>&#125;; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span class="comment">//&nbsp;Tests&nbsp;that&nbsp;the&nbsp;Foo::Bar()&nbsp;method&nbsp;does&nbsp;Abc. </span><span>&nbsp;&nbsp;</span></li><li><span>TEST_F(FooTest,&nbsp;MethodBarDoesAbc)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;string&nbsp;input_filepath&nbsp;=&nbsp;</span><span class="string">&quot;this/package/testdata/myinputfile.dat&quot;</span><span>; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">const</span><span>&nbsp;string&nbsp;output_filepath&nbsp;=&nbsp;</span><span class="string">&quot;this/package/testdata/myoutputfile.dat&quot;</span><span>; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;Foo&nbsp;f; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;EXPECT_EQ(0,&nbsp;f.Bar(input_filepath,&nbsp;output_filepath)); &nbsp;&nbsp;</span></li><li><span>&#125; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span class="comment">//&nbsp;Tests&nbsp;that&nbsp;Foo&nbsp;does&nbsp;Xyz. </span><span>&nbsp;&nbsp;</span></li><li><span>TEST_F(FooTest,&nbsp;DoesXyz)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="comment">//&nbsp;Exercises&nbsp;the&nbsp;Xyz&nbsp;feature&nbsp;of&nbsp;Foo. </span><span>&nbsp;&nbsp;</span></li><li><span>&#125; &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span><span class="comment">//&nbsp;namespace </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&nbsp;main(</span><span class="datatypes"><strong><span style="color: #2e8b57">int</span></strong></span><span>&nbsp;argc,&nbsp;</span><span class="datatypes"><strong><span style="color: #2e8b57">char</span></strong></span><span>&nbsp;**argv)&nbsp;&#123; &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;testing::InitGoogleTest(&amp;argc,&nbsp;argv); &nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;RUN_ALL_TESTS(); &nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><p></p><p>testing::InitGoogleTest()函数负责解析命令行传入的Google Test标志，并删除所有它可以处理的标志。这使得用户可以通过各种不同的标志控制一个测试程序的行为。关于这一点我们会在GTestAdvanced中讲到。你必须在调用RUN_ALL_TESTS()之前调用该函数，否则就无法正确地初始化标示。 </p><p></p><p>在Windows上InitGoogleTest()可以支持宽字符串，所以它也可以被用在以UNICODE模式编译的程序中。 </p><p></p><p><strong>进阶阅读</strong> </p><p></p><p>恭喜你！你已经学到了一些Google Test基础。你可以从编写和运行几个Google Test测试开始，再阅读一下<a href="http://code.google.com/p/googletest/wiki/GoogleTestSamples">GoogleTestSamples</a>，或是继续研究<a href="http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide">GoogleTestAdvancedGuide</a>，其中描述了很多更有用的Google Test特性。 </p><p></p><p><strong>已知局限</strong> </p><p></p><p>Google Test被设计为线程安全的。但是，我们还没有时间在各种平台上实现同步原语（synchronization primitives）。因此，目前从两个线程同时使用Google Test断言是不安全的。由于通常断言是在主线程中完成的，因此在大多数测试中这都不算问题。如果你愿意帮忙，你可以试着在gtest-port.h中实现必要的同步原语。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2031</link>
<title><![CDATA[自动化测试框架指南]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Fri, 09 Mar 2012 06:57:20 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2031</guid> 
<description>
<![CDATA[ 
	<p>这是我以前写的一篇文章，用于整理自己对自动化测试的理解。当时写这个文章的目的，是因为刚刚掌握QTP，又使用自动化测试参与公司一个大项目的测试，结果发现原来掌握QTP距离自动化测试还有很遥远的路要走，原来一直以为掌握了QTP的脚本编写、可以写出所有的测试方法脚本则自动化测试就可以大功告成了。但是现实是残酷的，实际和自己所想的相差太远了&mdash;&mdash;实际的情况是需求变化快，甚至有段时间开发还没有需求变化快，自动化测试脚本的维护工作量就可想而知了。 因此我当时就咨询了一下其他的测试同行，他们都认为测试代码复用是很重要的问题，要搭建一个好的测试框架，这就是我当时写这篇文章的目的。 </p><p>但是在写了这篇文章后，因为工作原因没有用实践去验证文章里的思想，直到今天才有时间来温习以前的教训。今天来按实际来做时，发现了一个问题&mdash;&mdash;用什么方式来划分test level service function 的颗粒呢？打个比方来说，我要写一个测试函数，实现以下功能：我要测试的是登录一个系统，打开一个页面，然后新建一条记录。因为还有其他的测试函数，肯定与这个函数有相同的代码部分，比如登录就是显而易见，但是还有一些代码肯定也是重复，而且是隐藏的，那么用什么方法把它们挖掘出来，细分的原则是什么？我实在想不清楚，需要大家的指点．文章里的一些内容取自别人的帖子或与同行的交流，所以只能算是半原创．</p><p>自动化测试框架指南</p><p>以下只是测试框架的一点设想，需要以后修改；</p><p>这套方案的最终结果是实现测试自动化，但是因为目前人力、实力有限，只能逐步完善设想中的功能；最终的目的是要实现define the driver&mdash;&mdash;定义驱动测试。</p><p>本文的自动化测试以MI公司的QuickTest professional 为例</p><p>1定义：</p><ul><li>Services function :业务函数</li><li>TestCase(测试用例)：是能够从头至尾独立执行的最小测试单元</li><li>测试框架的设想</li></ul><p>1.1Services Function 的分类及分类原则</p><p>Service Function的颗粒大小需求不一，靠自己来掌握，总之应该是尽量少的Service Function满足所有Case Function的需要<br />Common level&mdash;&mdash;所有项目测试都可以使用的函数，比如验证小数精度、写测试结果到报告等等。</p><p>Common level是公用的函数库，不需要经常修改，因此可以编成DLL文件，供所有的测试脚本使用。</p><p>使用语法可以这样：<br />&lsquo;------------------------------------<br />Set object=createobject(&ldquo;&rdquo;)<br />Call object.funciton &ldquo;&rdquo;<br />&lsquo;------------------------------------</p><p>High level&mdash;&mdash;各项目专用的测试用例，是为专门的测试项目而设置的，但是这些Services Function不能单独作测试，必须配合更高一级的Test level才能使用。</p><p>Test level&mdash;&mdash;Test level可以这样理解：是对某一个用户来说，为了完成某项工作和业务，时间从头至尾相对连续的一组操作。</p><p>Test level并不是测试用例，但是它的颗粒大小却决定了其复用程度，因此需要仔细分析每个TestCase的业务逻辑，将相同的Test Level services function 总结出来。</p><p>Test level的组成：<br /><br />Function <br />Step &lsquo;测试所要进行的操作<br />Validation &lsquo;验证测试的结果<br />Return result &lsquo;返回测试的结果，validation的验证结果也应该通过这一部分的函数写入到result report中<br />End function</p><p>1.2 Test case 和Test suite</p><ul><li>Test Case：测试用例。可以这样理解：是一组人为了完成某项工作和业务，时间从头至尾相对连续的一组操作</li><li>Test suite: 是一个相同工作性质的工作部门人员，为了完成某项工作和业务，时间从头至尾相对连续的一组操作。</li></ul><p>Test case和Test suite的意义：</p><p>1、大量的Case，肯定是分模块存放的。否则就难以查询和维护、修改。</p><p>2、Test Case和Test level /high level service function的互相调用关系可以通过insight sources这个工具来查询。</p><p>3、Suite相当于一个Case模块，里面包含很多个Case；比如测试用户管理的，都放在一个Suite里，测试设备管理的，放在另一个suite里。</p><p>1.3TestCase的分类原则</p><ul><li>一般复杂Case，要牵扯到好多个模块的功能的，但是要看它的主要测试点是什么，然后按这个测试点所属模块，来确定这个Case归属哪个模块的。</li><li>有依赖关系的Case，是合并成一个Case，还是保留独立？运行起来有依赖关系,倾向于合并成一个Case，合并的好处是运行方便，但是出错时要再区分是那个小Case的错误;分开的话，就相反，运行不方便，但出错时比较明确哪个错了。</li><li>如果A是建10万个用户，要花1小时的时间，那你还会放在一块嘛，肯定是倾向分开成小Case，不然B出错了，你还得再重头跑ABCD，测试人员会气死的！所以运行麻烦、容易出错、时间较长的小case，还是保持独立，只要跟测试人员写好说明文档，让他们知道正确的运行方法，就可以了。</li><li>如果合成一个case，我应该把它放到哪个suite里呢 因为它横跨了几个页面，都是测试点，不好划分啊。放在那个Suite里啊，那都可以啊，或者你想独立一个suite也可以啊，无所谓的，只要你运行结果有正确记录，不会漏掉丢失就可以了。</li><li>测试环境可以通过重新导入数据来恢复，这样就可以将一部分运行时间长、但是又有依赖关系的Test case分离出来，避免总是要从开头进行测试。</li><li>一个Test suite里的用到的lib和OR都是相同的。</li></ul><p>1.4测试用例和Services Function命名规则<br /><br />类型 名称<br />Test case 项目名_TC_name<br />test level services function 项目名_TL_name<br />high level services function 项目名_HL_name<br />common level services function CL_name(不应包括项目名，因为此类函数是公用的)</p><p>2工作方式</p><p>并非所有的测试用例都可以用自动化来完成，因此需要对用例进行挑选，选择合适的用例作为自动化测试用例。记住！自动化测试的成本是巨大的，一般来说，一个脚本运行6~7次才算收回成本，因此不可寄予自动化测试过高期望。</p><p>2.1选择自动化测试用例</p><p>2.1.1不适合自动化测试用例的情况</p><ul><li>定制型项目（一次性的）。为客户定制的项目，维护期由客户方承担的，甚至采用的开发语言、运行环境也是客户特别要求的，即公司在这方面的测试积累就少，这样的项目不适合作自动化测试。</li><li>项目周期很短的项目。项目周期很短，测试周期很短，就不值得花精力去投资自动化测试，好不容易建立起的测试脚本，不能得到重复的利用是不现实的。</li><li>业务规则复杂的对象。业务规则复杂的对象，有很多的逻辑关系、运算关系，工具就很难测试。</li><li>美观、声音、易用性测试。人的感观方面的：界面的美观、声音的体验、易用性的测试，也只有人来测试。</li><li>测试很少运行。测试很少运行，对自动化测试就是一种浪费。自动化测试就是让它不厌其烦的、反反复复的运行才有效率。</li><li>软件不稳定。软件不稳定，则会由于这些不稳定因素导致自动化测试失败。只有当软件达到相对的稳定，没有界面性严重错误和中断错误才能开始自动化测试。</li><li>涉及物理交互。工具很难完成与物理设备的交互，比如刷卡的测试等。</li></ul><p>2.1.2适合自动化测试的情况</p><p>自动化测试之所以能在很多大公司实施起来，就是有它适合自动化测试的特点和高的投资回报率。</p><ul><li>产品型项目。产品型的项目，每个项目只改进少量的功能，但每个项目必须反反复复的测试那些没有改动过的功能。这部分测试完全可以让自动化测试来承担， 同时可以把新加入的功能的测试也慢慢地加入到自动化测试当中。</li><li>增量式开发、持续集成项目。由于这种开发模式是频繁的发布新版本进行测试，也就需要频繁的自动化测试，以便把人从中解脱出来测试新的功能。</li><li>能够自动编译、自动发布的系统。要能够完全实现自动化测试，必须具有能够自动化编译，自动化发布系统进行测试的功能。 当然，不能达到这个要求也可以在手工干预的情况下进行自动化测试。</li><li>回归测试。回归测试是自动化测试的强项，它能够很好的验证你是否引入了新的缺陷，老的缺陷是否修改过来了。在某种程度上可以把自动化测试工具叫做回归测试工具。</li><li>多次重复、机械性动作，将烦琐的任务转化为自动化测试。自动化测试最适用于多次重复、机械性动作，这样的测试对它来说从不会失败。比如要向系统输入大量的相似数据来测试压力和报表。</li><li>需要频繁运行测试。在一个项目中需要频繁的运行测试，测试周期按天算，就能最大限度的利用测试脚本，提高工作效率。</li></ul><p>2.2编写Test case和Test level</p><p>分析Test Case的业务，将Test Level services function 的颗粒从Test Case中识别出来，尽量做到用少的Service function来实现测试业务。</p><p>2.3搭建测试框架</p><p>依据测试框架，在下一节中提到。依次填入测试框架的内容。</p><p>2.4执行测试并记录bug</p><p>这时就可以开始执行测试。测试结果应该自动被记录在测试报告中，而不应该一遇到BUG就停止&mdash;&mdash;除非必须停止。这里注意以下几点</p><ul><li>测试报告功能应该在Common level中实现，这样所有的测试都可以共用。</li><li>测试框架应该具有一定的判断功能，一旦某个测试失败。测试框架可以决定停止测试，或者转入不受影响的新测试用例，Test suite分类也应该注意这一点，因为同一个Test suite一般来说是互相影响的。</li><li>测试框架可以具有某种还原测试环境的功能&mdash;&mdash;即测试结束清理的功能，这样就可以自动恢复到不受影响的测试环境中。</li></ul><p>2.5维护测试脚本</p><p>这是一项工作量很大的工作。维护脚本的难度很大程度上与团队活动有关，相关信息参考第4节。</p><p>3测试框架的构想</p><p>3.1Test Driver</p><p>测试框架的核心叫Test driver，它具有以下一些东西</p><ul><li>全局参数。</li><li>所要测试的用例集，也许叫Test suite集更合适；包括测试所要用到的参数。</li><li>对于用例的描述。</li><li>lib and tsr。</li><li>能够判断测试结果，并且决定是否调用其它的测试用例，或者停止测试。</li><li>自动生成测试报告。以及需要输出的路径。</li><li>每个测试脚本的初始设置路径</li></ul><p>4团队开展自动化测试要点</p><p>单人自动化测试与团队开展自动化测试有很大不同，因为不同的对象名、不同的函数会造成每个人的测试脚本不同，并难以合并成一个完整、统一的脚本。为了解决这个问题，应该注意以下几点：</p><ul><li>团队成员在编写脚本时应该多使用对象库，尽量少使用描述性编程。</li><li>统一对象名称，规定网页元素对象命名的统一规定，这样才可能在合并对象库时统一。</li><li>统一函数命名规定。</li><li>统一函数书写格式。</li><li>统一对同一类型操作的处理方式&mdash;&mdash;应该定期举行会议，沟通各种操作的处理方法，共同提高对系统的认识水平。</li></ul><p>5测试配置</p><p>测试配置应该尽量自动完成，减少工作量。</p><p>测试配置包括如下内容：</p><ul><li>测试工具的配置</li><li>测试环境，如数据、数据库结构</li></ul><p>6测试初始设置</p><p>一些测试用例相互依赖，本应该把它们合成一个测试用例；但是如果单个测试用例颗粒很大，那么在回归测试或再现缺陷时就会使人发疯，并且浪费了大量的测试时间。最好最可靠的解决办法看来只有一种，那就是将颗粒大的测试用例分离出来，同时为这个测试用例预备测试初始设置&mdash;&mdash;将客户端所需要的数据库结构和数据库备份，并且作为测试初始设置保存管理。</p><p>这里的测试初始设置并非只针对自动化测试，手工测试也被包括进来。</p><p>6.1测试初始设置的命名办法</p><p>TE+测试用例编号</p><p>如测试用例为TC1.2，则TE为TE1.2</p><p>6.2测试初始设置的保存</p><p>测试初始设置应保存在单独的文件夹内，初始设置的路径被链接到Test driver上。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1962</link>
<title><![CDATA[Facebook是如何做自动化测试的？]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 03 Mar 2012 07:59:14 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1962</guid> 
<description>
<![CDATA[ 
	<p><strong>导读：最近，在国外知名问答网站</strong><a href="http://www.quora.com/What-kind-of-automated-testing-does-Facebook-do" target="_blank"><strong>Quora</strong></a><strong>上有个讨论，原意是：&ldquo;Facebook是如何做自动化测试的，他们是怎样测试才能保证每周的升级都可以不出差错的呢？&rdquo; 引发了开发者们的激烈讨论。</strong></p><p>来自Facebook的Steven Grimm很好地回答了这个问题，觉得还不错，这里以第一人称翻译了一下。</p><ul><li>对于PHP的代码，我们写了非常多的基于PHPUnit测试框架的测试类，这些测试类覆盖范围比较大，从简单的判读真假的单元测试到大规模的后端服务的集成测试。开发人员把运行这些基于PHPUnit的测试用例作为他们工作中的一部分，同时这些用例也在一些专用的设备上不停地被运行（注：持续集成模式）。当开发人员对一些代码做了比较大的修改时，在开发机器上的自动化工具会运行这些测试用例的同时也会生成相应的代码覆盖率数据，对于需要提交到代码库的diff，在做代码review的时候回自动地产生一份带有覆盖率的测试报告。</li><li>对于前端的代码，我们使用Waitir（注：Waitir是前端UI的自动化测试框架）做了基于浏览器的界面自动化测试。这些测试用例涵盖了网站页面的功能，特别是针对隐私方面，比如：&ldquo;用户X发布了Y，而Y应该/不应该被用户Z看到&rdquo;，有着大量的基于浏览器级别的这种用例。（这些隐私规则当然也会使用一些更低级别的方法被测试到，但是这些规则的实现是必须要严格执行的，并有着非常高的优先级，因此这部分必须要有足够的测试用例来覆盖）</li></ul><ul><li>除了一些使用watir的全自动化用例以外，我们也有一些半自动化的测试。这些测试也使用了waitir技术，这样可以使一些表格填充或者点击button来完成整改界面上的流程的测试不太单调乏味，而且我们可以很清楚地检查和验证当前的步骤或流程是否正确合理。</li></ul><ul><li>我们也在尝试开始使用JSSpec （注：JavaScript单元测试框架）去做一些JavaScript代码的单元测试，但当前也是刚刚开始做。</li><li>对于后端服务的测试，根据不同的服务特性我们采用了许多不同的测试框架与方法。对于一些需要开源发布的项目，我们会使用开源的测试框架，像Boost和JUnit测试框架（注：Boost是针对C++/JUnit是针对Java的测试框架）；对于另外一些项目，可能永远都不会发布到外界，我们就是使用内部开发的可以很紧密地与我们build系统集成在一起的C++测试框架。还有少数项目会使用项目级别的测试工具。多数后端服务的测试都会紧紧地和持续集成/Build系统结合在一起，这些持续集成的build系统会不停地针对源代码自动地运行测试用例并生成测试结果，测试结果在存储在数据库的同时会发送到通知系统中去。</li><li>HipHop(注：HipHop for PHP是Facebook的PHP项目)有一套类似的持续集成系统，HipHop的单元测试和所有基于PHPUnit的测试都会被运行。所有的这些测试结果会和基于普通的PHP解释器的结果做对比，从而可以看到不同PHP上的行为的不同；</li></ul><p>Facebook的测试工具将测试结果存储在数据库的同时会发送一份通知邮件，这个邮件会包含执行失败的信息并且邮件的接收范围是开发同学可以自己调整的。（例如，你可以选择只有在测试连续失败一段时候的时候才接收到通知邮件，或者当一个用力失败的时候立刻收到通知）。在浏览器UI上，测试结果和 缺陷/开发任务跟踪系统会结合在一起，可以很容易的将测试失败与开发任务关联起来。</p><p>测试中一个非常重要的现象是&ldquo;导致阻塞&rdquo;，也就是一个测试用例失败有可能会阻止发布（在Facebook，有发布工程师会来评估是否可以将带有问题的代码发布到生产环境，发布工程师在必要的情况下会得到授权去阻止产品的发布）。阻止产品发布上线的事情是被认为是非常严重的问题，因为在Facebook大家对于这种快速发布的模式是深深引以为豪的。</p><p>我所在的团队是测试工程部门，主要职责是打造通用基础工具，这些工具会被上述的所有人用到，同时我们也在维护测试框架，像PHPUnit和Watir。Facebook没有专职的测试团队，所有的工程师都需要为他们的代码写自动化测试用例，并维护这些测试用例，保证产品代码改变的同时这些测试代码可以正确地运行。</p><p>Facebook的测试还处于一个初期起步尝试阶段，上面的介绍都只是我们在当前运行的方法而已。</p><p>文章出自：<a href="http://www.quora.com/What-kind-of-automated-testing-does-Facebook-do" target="_blank">quora.com</a></p><p>译文出自：<a href="http://sdet.org/?p=115" target="_blank">sdet.org</a></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1757</link>
<title><![CDATA[C++模拟测试框架 Google Mock]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 18 Feb 2012 06:28:29 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1757</guid> 
<description>
<![CDATA[ 
	<div id="p_fullcontent" class="detail"><p>Google Mock 是 Google 刚刚开源的一套 C++ Mock 框架。</p><p>Google Mock在google内部超过100个项目中使用过，由Zhanyong Wan，一个google的软件工程师(看名字大概是华裔)，从<a href="http://www.oschina.net/p/jmock" target="_blank">jMock</a>和<a href="http://www.oschina.net/p/easymock" target="_blank">EasyMock</a>中获得灵感而开发。<br /><br />这个框架能够在Linux，Windows 和Mac OS X上使用。</p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1756</link>
<title><![CDATA[C++单元测试框架 CppTest]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 18 Feb 2012 06:28:04 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1756</guid> 
<description>
<![CDATA[ 
	<p>CppTest 是 C++ 的单元测试框架。<a href="http://www.oschina.net/p/cppunit">CppUnit</a>&nbsp;简单得多，但是效果也不错。下面简要地对比这两个强大的工具：</p><ul><li><strong>创建单元测试和测试套件的简便性。</strong><span style="font-size: x-small">CppUnit</span>&nbsp;和&nbsp;<span style="font-size: x-small">CppTest</span>&nbsp;都创建类方法形式的单元测试，类本身都派生自工具提供的&nbsp;<span style="font-size: x-small">Test</span>类。但是，<span style="font-size: x-small">CppTest</span>&nbsp;的语法略微简单些，测试的注册在类构造器内进行。对于&nbsp;<span style="font-size: x-small">CppUnit</span>，需要额外的宏&nbsp;<span style="font-size: x-small">CPPUNIT_TEST_SUITE</span>&nbsp;和<span style="font-size: x-small">CPPUNIT_TEST_SUITE_ENDS</span>。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>运行测试。</strong><span style="font-size: x-small">CppTest</span>&nbsp;直接调用测试套件上的&nbsp;<span style="font-size: x-small">run</span>&nbsp;方法，而&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;使用单独的&nbsp;<span style="font-size: x-small">TestRunner</span>&nbsp;类，通过调用这个类的&nbsp;<span style="font-size: x-small">run</span>&nbsp;方法运行测试。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>扩展测试层次结构。</strong>对于&nbsp;<span style="font-size: x-small">CppTest</span>，随时可以从以前的测试套件派生新类，从而扩展测试套件。新的类定义一些新函数，这些函数成为新的单元测试。只需在新类类型的对象上调用&nbsp;<span style="font-size: x-small">run</span>&nbsp;方法。与之相反，<span style="font-size: x-small">CppUnit</span>&nbsp;需要使用&nbsp;<span style="font-size: x-small">CPPUNIT_TEST_SUB_SUITE</span>宏和类继承来实现相同的效果。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>生成格式化的输出。</strong><span style="font-size: x-small">CppTest</span>&nbsp;和&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;都允许定制输出。但是，<span style="font-size: x-small">CppTest</span>&nbsp;有预定义的 HTML 输出格式化器，而&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;没有。但是，只有&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;支持 XML 格式化。它们都支持文本和编译器式格式。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>创建测试装备。</strong>要想使用测试装备，<span style="font-size: x-small">CppUnit</span>&nbsp;要求测试类派生自&nbsp;<span style="font-size: x-small">CppUnit::TestFixture</span>。您必须提供设置和退出例程的定义。对于&nbsp;<span style="font-size: x-small">CppTest</span>，只需提供设置和退出例程的定义。这个解决方案显然更好，因为这让客户机代码更简单。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>预定义的宏支持。</strong><span style="font-size: x-small">CppTest</span>&nbsp;和&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;都提供一组用于断言、处理浮点等的宏。</li><li style="padding-bottom: 3px; margin-top: 0px; padding-right: 5px; font-family: arial, nsimsun, sans-serif; margin-bottom: 0px; padding-top: 0px"><strong>头文件。</strong>&nbsp;<span style="font-size: x-small">CppTest</span>&nbsp;只要求包含一个头文件，而&nbsp;<span style="font-size: x-small">CppUnit</span>&nbsp;客户机代码必须根据使用的特性包含多个头文件，比如 HelperMacros.h 和 TextTestRunner.h。</li></ul>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1755</link>
<title><![CDATA[C++单元测试框架 CppUnit]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 18 Feb 2012 06:27:21 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1755</guid> 
<description>
<![CDATA[ 
	<div id="p_fullcontent" class="detail"><p>CppUnit 是个基于 LGPL 的开源项目，最初版本移植自 JUnit，是一个非常优秀的开源测试框架。CppUnit 和 JUnit 一样主要思想来源于极限编程（XProgramming）。主要功能就是对单元测试进行管理，并可进行自动化测试。</p><p>测试驱动开发(TDD)是以测试作为开发过程的中心，它坚持，在编写实际代码之前，先写好基于产品代码的测试代码。开发过程的目标就是首先使测试能够通 过，然后再优化设计结构。测试驱动开发式是极限编程的重要组成部分。XUnit，一个基于测试驱动开发的测试框架，它为我们在开发过程中使用测试驱动开发 提供了一个方便的工具，使我们得以快速的进行单元测试。XUnit的成员有很多，如JUnit，PythonUnit等。CppUnit 即是XUnit家族中的一员，它是一个专门面向C++的测试框架。</p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1754</link>
<title><![CDATA[Qt的单元测试框架QTestLib----测试自定义的类]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 18 Feb 2012 06:26:09 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1754</guid> 
<description>
<![CDATA[ 
	<p>在nokia 的qt 4.7 官方文档中这个地方http://doc.qt.nokia.com/4.7/qtestlib-tutorial.html， 介绍了如何使用QTestLib框架进行单元测试。例子中多是对系统提供的类进行的测试。这里主要写下如何对自己定义的类进行单元测试。</p><p></p><h2>测试方法：</h2><p>宏：QCOMPARE, QTEST, QVERIFY, QBENCHMARK, </p><p><br />事件：<br />KeyAction(QTest::keyClick(),QTest::keyPress(), QTest::keyRelease()), <br />MouseAction(QTest::mouseClick(), QTest::mouseDClick(),QTest::mouseMove(),QTest::mousePress(),QTest::mouseRelease())</p><p><br />类：QSignalSpy, QTouchEventSequence</p><p></p><h2>保存测试结果：</h2><p>首先我们先定义一个宏，用来定义存放我们测试结果的文件。这个宏是运行在Symbian S60平台。</p><p>&bull; <strong>#ifndef</strong> S60UNITTEST_H_ </p><p>&bull; <strong>#define</strong> S60UNITTEST_H_ </p><p>&bull; <strong>#define</strong> QTEST_MAIN_S60(TestObject) / </p><p>&bull; <strong>int</strong> main( <strong>int</strong> argc, <strong>char</strong> *argv[]) / </p><p>&bull; &#123; / </p><p>&bull; <strong>char</strong> *new_argv[3]; / </p><p>&bull; QApplication app(argc, argv); / </p><p>&bull; / </p><p>&bull; QString str = &quot;C://data//&quot; + QFileInfo(QCoreApplication::applicationFilePath()).baseName() + &quot;.log&quot;; / </p><p>&bull; QByteArray bytes = str.toAscii(); / </p><p>&bull; / </p><p>&bull; <strong>char</strong> arg1[] = &quot;-o&quot;; / </p><p>&bull; / </p><p>&bull; new_argv[0] = argv[0]; / </p><p>&bull; new_argv[1] = arg1; / </p><p>&bull; new_argv[2] = bytes.data(); / </p><p>&bull; / </p><p>&bull; TestObject tc; / </p><p>&bull; <strong>return</strong> QTest::qExec(&amp;tc, 3, new_argv); / </p><p>&bull; &#125; </p><p>&bull; <strong>#endif</strong> /* S60UNITTEST_H_ */ </p><p></p><p>在定义的测试类中，使用QTEST_MAIN_S60(TestObject)代替 QTEST_MAIN(TestObject).这里TestObject是我们自定义的类的类名。 </p><p>测试结果会保存在 C://data//xxxx.log 文件里。这里xxxx是我们测试工程的名字。</p><p></p><h2>访问被测试类的保护，私有 成员变量和成员函数：</h2><p>可以用下面两中方法之一：</p><p>1， 把测试类声明成被测试函类的友元类。</p><p>2，在测试类头文件中加入下面的宏：<br />#define private public<br />#define protected public<br />#include &quot;myWidget.h&quot; //这里的myWidget.h 是我的被测试类的名字<br />#undef protected<br />#undef private</p><p></p><p></p><h2>使用QSignalSpy</h2><p>void TestObject::testEventtoMouse()<br />&#123;<br />QPushButton button;<br />QSignalSpy buttonSpy(&amp;button, SIGNAL(clicked()));<br />QTest::mouseClick(&amp;button,Qt::LeftButton);<br />QVERIFY(buttonSpy.count() == 1);<br />&#125;</p><p></p><p></p><p>然后把测试类及被测试类的头文件和实现文件(.cpp or dll)放在同一工程目录下，并把被测试类的相关文件加入到工程的pro文件中。</p><p>编译并运行测试程序，即可在C://data//目录下找到包含测试结果的log文件。</p><p>另外可以在程序中使用qDebug(&quot;this is test info&quot;)语句，输出相关测试信息。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1753</link>
<title><![CDATA[qt单元测试QTest ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[测试]]></category>
<pubDate>Sat, 18 Feb 2012 06:25:38 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1753</guid> 
<description>
<![CDATA[ 
	QTestLib框架提供了一个简单易用的单元测试框架，需要在工程文件中添加Qt+=testlib。先看一个<strong>简单的例子</strong>： <p><strong>C/C++ code</strong></p><div><p>#include &lt;QtTest/QtTest&gt;&nbsp; </p><p>class TestQString: public QObject&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; Q_OBJECT&nbsp; </p><p>private slots:&nbsp; </p><p>&nbsp; // 每个private slot函数都是会被自动调用的测试函数&nbsp; </p><p>&nbsp; void testToLower();&nbsp; </p><p>&nbsp; // 以&ldquo;_data&rdquo;结尾的函数向对应的测试函数提供测试数据&nbsp; </p><p>&nbsp; void testToLower_data();&nbsp; </p><p>&#125;;&nbsp; </p><p></p><p>void TestQString::testToLower()&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; // 获取测试数据&nbsp; </p><p>&nbsp; QFETCH(QString, string);&nbsp; </p><p>&nbsp; QFETCH(QString, result);&nbsp; </p><p>&nbsp; // 如果输入的两个参数不同，则会被认为测试失败&nbsp; </p><p>&nbsp; QCOMPARE(string.toLower(), result);&nbsp; </p><p>&#125;&nbsp; </p><p>void TestQString::testToLower_data()&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; // 添加数据列&nbsp; </p><p>&nbsp; QTest::addColumn&lt;QString&gt;(&quot;string&quot;);&nbsp; </p><p>&nbsp; QTest::addColumn&lt;QString&gt;(&quot;result&quot;);&nbsp; </p><p>&nbsp; // 添加测试数据&nbsp; </p><p>&nbsp; QTest::newRow(&quot;lower&quot;) &lt;&lt; &quot;hello&quot; &lt;&lt; &quot;hello&quot;;&nbsp; </p><p>&nbsp; QTest::newRow(&quot;mixed&quot;) &lt;&lt; &quot;HeLlO&quot; &lt;&lt; &quot;hello&quot;;&nbsp; </p><p>&nbsp; QTest::newRow(&quot;upper&quot;) &lt;&lt; &quot;HELLO&quot; &lt;&lt; &quot;hello&quot;;&nbsp; </p><p>&#125;&nbsp; </p><p>// 用于构建可执行的测试程序&nbsp; </p><p>QTEST_MAIN(TestQString)&nbsp; </p><p>#include &quot;testqstring.moc&quot;</p><p></p></div><p><br /><br />此外，Qt还提供了以下四个会被自动调用的</p><p>private slot：<br />initTestCase()：在测试开始前被调用<br />cleanupTestCase()：在测试结束后被调用<br />init()：每个测试函数执行前被调用<br />cleanup()：每个测试函数执行后被调用<br /><br />测试完成后输出的结果如下所示：</p><p><strong>JScript code</strong></p><div><p>********* Start testing of TestQString *********&nbsp; </p><p>Config: Using QTest library 4.5.3, Qt 4.5.3&nbsp; </p><p>PASS&nbsp;&nbsp; : TestQString::initTestCase()&nbsp; </p><p>PASS&nbsp;&nbsp; : TestQString::testToLower()&nbsp; </p><p>PASS&nbsp;&nbsp; : TestQString::cleanupTestCase()&nbsp; </p><p>Totals: 3 passed, 0 failed, 0 skipped&nbsp; </p><p>********* Finished testing of TestQString *********&nbsp; </p><p></p></div><p><br /><br />为了<strong>测试GUI组件 </strong>，可以使用诸如QTest::keyClick()函数，通过内部事件传递，来模拟本地窗口系统的事件。例如：</p><p><strong>C/C++ code</strong></p><div><p>// 代码取自 <u>http://qt.nokia.com/doc/qtestlib-tutorial4-testgui-cpp.html</u>&nbsp; </p><p>#include &lt;QtGui&gt;&nbsp; </p><p>#include &lt;QtTest/QtTest&gt;&nbsp; </p><p>class TestGui: public QObject&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; Q_OBJECT&nbsp; </p><p>private slots:&nbsp; </p><p>&nbsp; void testGui_data();&nbsp; </p><p>&nbsp; void testGui();&nbsp; </p><p>&#125;;&nbsp; </p><p></p><p>void TestGui::testGui_data()&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; QTest::addColumn&lt;QTestEventList&gt;(&quot;events&quot;);&nbsp; </p><p>&nbsp; QTest::addColumn&lt;QString&gt;(&quot;expected&quot;);&nbsp; </p><p>&nbsp; // 添加按键事件&nbsp; </p><p>&nbsp; QTestEventList list1;&nbsp; </p><p>&nbsp; list1.addKeyClick('a');&nbsp; </p><p>&nbsp; QTest::newRow(&quot;char&quot;) &lt;&lt; list1 &lt;&lt; &quot;a&quot;;&nbsp; </p><p></p><p>&nbsp; QTestEventList list2;&nbsp; </p><p>&nbsp; list2.addKeyClick('a');&nbsp; </p><p>&nbsp; list2.addKeyClick(Qt::Key_Backspace);&nbsp; </p><p>&nbsp; QTest::newRow(&quot;there and back again&quot;) &lt;&lt; list2 &lt;&lt; &quot;&quot;;&nbsp; </p><p>&#125;&nbsp; </p><p>void TestGui::testGui()&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; QFETCH(QTestEventList, events);&nbsp; </p><p>&nbsp; QFETCH(QString, expected);&nbsp; </p><p>&nbsp; QLineEdit lineEdit;&nbsp; </p><p>&nbsp; // 模拟按键事件，并比较结果&nbsp; </p><p>&nbsp; events.simulate(&amp;lineEdit);&nbsp; </p><p>&nbsp; QCOMPARE(lineEdit.text(), expected);&nbsp; </p><p>&#125;&nbsp; </p><p>QTEST_MAIN(TestGui)&nbsp; </p><p>#include &quot;testgui.moc&quot;</p><p></p></div><p><br /><br />最后看看如何<strong>测试benchmark</strong>：</p><p><strong>C/C++ code</strong></p><div><p>void TestQString::testBenchmark()&nbsp; </p><p>&#123;&nbsp; </p><p>&nbsp; QString str(&quot;HeLlO&quot;);&nbsp; </p><p>&nbsp; // 以下代码被测试benchmark&nbsp; </p><p>&nbsp; QBENCHMARK&nbsp; </p><p>&nbsp; &#123;&nbsp; </p><p>&nbsp;&nbsp;&nbsp; str.toLower();&nbsp; </p><p>&nbsp; &#125;&nbsp; </p><p>&#125;&nbsp; </p><p></p></div><p><br />得到如下输出：</p><p><strong>JScript code</strong></p><div><p>RESULT : TestQString::testBenchmark():&nbsp; </p><p>0.00062 msec per iteration (total: 41, iterations: 65536)</p></div>
]]>
</description>
</item>
</channel>
</rss>