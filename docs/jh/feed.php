<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?7527</link>
<title><![CDATA[mysql优化之索引优化]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Thu, 01 Sep 2016 12:56:02 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7527</guid> 
<description>
<![CDATA[ 
	<p style="margin: 10px auto; padding: 0px; font-size: 14px; line-height: 21px"><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=931" title="mysql优化系列">第一篇 序章</a><br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=950" title="mysql优化之连接优化">第二篇 连接优化</a><br />第三篇 索引优化<br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=990" title="mysql优化之查询优化">第四篇 查询优化</a><br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=784" title="mysql优化之从实践中来，到实战中去">第五篇 到实战中去</a></p><h1 style="margin: 0px; padding: 0px; font-size: 28px">索引优化</h1><p style="margin: 10px auto; padding: 0px; font-size: 14px; line-height: 21px">索引优化涉及到几个方面，包括了索引的类型、如何让查询使用索引，查询是索引算法的选择等等操作。<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=961"><span style="margin: 0px; padding: 0px" class="copyme">(原文链接http://ddbiz.com/?p=961)</span></a><br />涉及到数据库的查询时，大多数情况都是要建立索引的，MySQL的索引类型以及创建索引方式，可以参考其<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/doclib/mysql/cn51/optimization.html#indexes" target="_blank">文档</a>或者<a style="margin: 0px; padding: 0px; color: black" href="http://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html" target="_blank">这里</a>。</p><ol style="margin: 0px; padding: 0px 0px 0px 40px; font-size: 14px; line-height: 21px"><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="server-options"></a>服务器参数设置</h1><p style="margin: 10px auto; padding: 0px">在于索引有关系的数据库参数中，有一些特别重要，如下：</p><ol style="margin: 0px; padding: 0px 0px 0px 40px"><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_buffer_size"></a>key_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_buffer_size=#<br />ini/cnf参数: key_buffer_size<br />mysql 变量: key_buffer_size<br />全局变量，可动态调整，取值范围 8到4G(32bitOS), 在64bitOS上可以设置更高，只要你的系统有那么多物理内存。</p><p style="margin: 10px auto; padding: 0px">key_buffer_size 主要作用于MyISAM表的索引。我们知道，MyISAM的索引句柄是对全部连接用户共享的。状态参数 key_read_requests(响应用户请求时从缓存中获取的数据)和key_reads(响应用户请求时从文件中加载的数据) 可以用来检测key_buffer_size是否太小，根据<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/doclib/mysql/en55/server-administration.html#statvar_Key_read_requests" target="_blank">文档</a>, key_reads/key_read_request 应该远小于0.01(当然我们的测试环境可能完全无法达到此设定，只能尽量接近了). 如果一个MyISAM的数据表的索引文件过G，除非物理内存远远高于索引大小，否则让key_reads/key_read_request接近0.01也是一件不可能的任务。</p><p style="margin: 10px auto; padding: 0px">MySQL还支持把索引提前加载到内存，本节后面将<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#load-index-into-cache">描述此方法及其限制</a>.</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">受如下参数影响: 系统内存<br />将影响如下参数: 无<br />调整触发条件: key_reads/key_read_request &gt;0.01</p></blockquote></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_block_size"></a>key_cache_block_size</h2><p style="margin: 10px auto; padding: 0px">与key_buffer_size相关联的另外一个参数是 key_cache_block_size<br />命令行参数: &ndash;key_cache_block_size=#<br />ini/cnf参数: key_cache_block_size<br />mysql 变量: key_cache_block_size<br />全局变量，可动态调整，取值范围 512bytes到16k。</p><p style="margin: 10px auto; padding: 0px">key_cache_block_size表明key_buffer_size被分割的区域的大小。可以通过 show status 来判断当前key_buffer_size被分为多少个块：</p><p style="margin: 10px auto; padding: 0px">Key_blocks_unused, 目前剩余可用的索引缓存空间<br />Key_blocks_used(历史上的最大峰值)</p><p style="margin: 10px auto; padding: 0px">对于一个key_buffer_size=4G的数据库来说， key_cache_block_size*Key_blocks_unused 就是剩余的可用的缓存空间。只要这个空间允许，我们都应该尽可能的把索引预装入缓存中（见<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#load-index-into-cache">LOAD INDEX INTO CACHE</a></p><p style="margin: 10px auto; padding: 0px">理论上讲，key_cache_block_size与操作系统的I/O buffer相同大小时工作（读取、写入）效率最高，比如linux中i/o缓存一般为1k. 对于mysql来说，可以通过&nbsp;<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#myisam-block-size">&ndash;myisam-block-size</a>来定义MyISAM索引文件的块大小，其最小为1k。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_division_limit"></a>key_cache_division_limit</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_cache_division_limit=1~100<br />配置文件参数: key_cache_division_limit=#<br />MySQL变量: key_cache_division_limit<br />全局可调整变量，默认为100(即LRU队列)。<br />当MyISAM的key_buffer_size中设置了key_cache_division_limit(</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_age_threshold"></a>key_cache_age_threshold</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_cache_age_threshold=100~4G(32bitOS)或者100~~(64bitOS)<br />配置文件参数: key_cache_age_threshold=#<br />MySQL变量: key_cache_age_threshold<br />全局可调整变量，默认为300。<br />当MyISAM的key_buffer_size被分为热链和温链时，key_cache_age_threshold就被用来控制什么样的情况下处于热链的数据会被转移到温链中。key_cache_age_threshold是指的block个数，如果在最近的 （key_cache_age_threshold * key_cache_division_limit/100）次访问中，处于热链顶部的block没有被访问到，那么这些块将被移到温链的顶部（处于温链顶部的block会很快被移除出key cache）。</p><p style="margin: 10px auto; padding: 0px"><span style="margin: 0px; padding: 0px" class="warning">说明:<br />key_buffer_size, key_cache_block_size, key_cache_division_limit, key_cache_age_threshold 这4个变量是一个结构变量中的一组变量。本文后续有部分<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#cache_index">详细介绍</a>.</span></p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="read_buffer_size"></a>read_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;read_buffer_size=#<br />ini/cnf参数: read_buffer_size<br />mysql 变量: read_buffer_size<br />全局变量，可动态调整，默认128k，取值范围8k到2G.</p><p style="margin: 10px auto; padding: 0px">read_buffer_size主要作用于顺序读取一批数据时，减少数据库文件访问的次数。</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">受如下参数影响:<br />将影响如下参数: KEY_BLOCK_SIZE（表创建时的参数）<br />调整触发条件:</p></blockquote></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="read_rnd_buffer_size"></a>read_rnd_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;read_rnd_buffer_size=#<br />ini/cnf参数: read_rnd_buffer_size<br />mysql 变量: read_rnd_buffer_size<br />全局变量，可动态调整，默认256k，取值范围8k到4G.</p><p style="margin: 10px auto; padding: 0px">read_rnd_buffer_size用于<strong style="margin: 0px; padding: 0px">使用键/索引进行排序时</strong>的磁盘文件预读，一个足够大的read_rnd_buffer_size对ORDER BY语句会有很大影响。<br /><span style="margin: 0px; padding: 0px" class="notice">注意:read_rnd_buffer_size是和每一个session相关的，因此其大小需要谨慎处理，当并发连接很大时，尤其要小心。</span></p></li></ol></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="load-index-into-cache"></a>LOAD CACHE INTO CACHE</h1><p style="margin: 10px auto; padding: 0px">MySQL可以把索引文件预先加载到<strong style="margin: 0px; padding: 0px">指定</strong>的缓存中:</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">LOAD INDEX INTO CACHE table_name;<br />LOAD INDEX INTO CACHE table_name INDEX (index_name_1, index_name_2);<br />LOAD INDEX INTO CACHE table_name INDEX (index_name_1, index_name_2) IGNORE LEAVES;</p></blockquote><p style="margin: 10px auto; padding: 0px">对于查询型的超大型的表，当没有足够的内存时，可以使用 IGNORE LEAVES 的方式加载索引到缓存。比如一个接近1Billion的数据表，其索引可能也是几G大小的。下面这个例子就显示了当预先加载数据索引时，查询的速度变化，这个数据表有接近1亿条记录，3个索引，有超过3G的大小，对于同一个查询：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">#mysql&gt; select * from tbigdatatable where username in (&lsquo;ABCDEF&rsquo;, &lsquo;19740821&rsquo;)</p></blockquote><p style="margin: 10px auto; padding: 0px">在非预先加载索引以及预载索引的情况下，查询的响应区别:</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">#mysqld_safe &ndash;key-buffer-cache=1073741824<br />####不预载索引#### 5 rows in set (0.65 sec)<br />######预载索引#### 5 rows in set (1.94 sec)</p></blockquote><p style="margin: 10px auto; padding: 0px">当然一个查询有很大的偶然性，不过从一个大量的查询平均来看，这个效果还是有很大的差别的。</p><p style="margin: 10px auto; padding: 0px">如果一个表的索引包含不同的key_block_size,那么这个预装载将会遇到困难, 如：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">alter table tbigdatatable add index idx_bigdatatable_username(username) key_block_size=8192, add index idx_bigdatatable_email(email) key_block_size=8192, add index idx_bigdatatable_id(id) key_block_size=1024;<br />load index into cache tbigdatatable index (idx_bigdatatable_username, idx_bigdatatable_email) ignore leaves;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br />&#124; Table &#124; Op &#124; Msg_type &#124; Msg_text &#124;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; error &#124; Indexes use different block sizes &#124;<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; error &#124; Subpartition p178sp0 returned error &#124;<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; status &#124; Operation failed &#124;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+</p></blockquote><p style="margin: 10px auto; padding: 0px">因为.MYI中包含不同block_size的索引，所以无法预加载！</p><p style="margin: 10px auto; padding: 0px"><span style="margin: 0px; padding: 0px" class="notice">MySQL 5.1 对分区表不能预装载索引：<br />preload_keys &#124; note &#124; The storage engine for the table doesn&rsquo;t support preload_keys<br />真是不幸, 这些版本包括: 5.1.47, 5.1.61-community-log</span></p><p style="margin: 10px auto; padding: 0px">因为手头上没有MySQL5.5的数据库可供使用，所以关于预装载索引到内存的方法只能暂时放一放，这也导致了我的另外一个测试项目差点夭折：9千万数据的<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/%e6%b3%84%e5%af%86%e7%94%a8%e6%88%b7%e6%a3%80%e7%b4%a2" target="_blank">分区表查询</a>，每个查询要耗时1m左右，伤不起啊。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="cache_index"></a>CACHE INDEX</h1><p style="margin: 10px auto; padding: 0px">LOAD INDEX INTO CACHE可以把索引装入缓存中，除此外，MySQL还可以更有针对性的把索引装入制定的缓存中。key_buffer_size是一个结构中一个变量，这个结构是系统的默认缓存空间，我们还可以设定其他的缓存空间，比如：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">set global key1.key_buffer_size=128*1024*1024;<br />set global key2.key_buffer_size=512*1024*1024;</p></blockquote><p style="margin: 10px auto; padding: 0px">这样我们就能定义不同的缓存空间，配合 CACHE INDEX IN cache_region语句，就可以把不同的索引放入不同的缓存中。</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">(接上)<br />cache index table_name index (index_name_1) in key1;<br />cache index table_name index (index_name_2) in key2;<br />load cache into cache table_name index (index_name_1);<br />load cache into cache table_name index (index_name_2) ignore leaves;</p></blockquote><p style="margin: 10px auto; padding: 0px">上面的语句就把 index_name_1放入了 key1, 把 index_name_2放入了 key2;至于何时使用不同的缓存，我们在后面的实战中再做讨论。</p><p style="margin: 10px auto; padding: 0px">结构化的变量，在mysql中没办法用 show variables like &lsquo;structure_name_1.key_buffer%&rsquo; ; 的方式来查询。假如我们定义了不同的结构变量（创建不同的缓存空间的）: staticdb.*，则可以用下面的方式来查询该空间的设置情况：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">set global staticdb.key_buffer_size=1000*1024*1024;<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />mysql&gt; select @@global.staticdb.key_buffer_size KBS<br />, @@global.staticdb.key_cache_division_limit KCDL<br />, @@global.staticdb.key_cache_age_threshold KCAT<br />, @@global.staticdb.key_cache_block_size KCBS;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />&#124; KBS &#124; KCDL &#124; KCAT &#124; KCBS &#124;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />&#124; 1048576000 &#124; 100 &#124; 300 &#124; 1024 &#124;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />1 row in set (0.00 sec)</p></blockquote><p style="margin: 10px auto; padding: 0px">目前我还没有办法查看指定一个结构空间的使用情况，如果你知道如何查看的话，请留言给我。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="summary"></a>要点总结</h2><p style="margin: 10px auto; padding: 0px">本节的要点是：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">对于MyISAM来说：设置尽可能大的缓存，最好把MyISAM表的索引能够全部装入缓存中</p></blockquote></li></ol>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7526</link>
<title><![CDATA[Mysql limit 优化，百万至千万级快速分页，--复合索引的引用并应用于轻量级框架]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Thu, 01 Sep 2016 12:55:28 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7526</guid> 
<description>
<![CDATA[ 
	<p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">MySql 性能到底能有多高？用了php半年多，真正如此深入的去思考这个问题还是从前天开始。有过痛苦有过绝望，到现在充满信心！MySql 这个数据库绝对是适合dba级的高手去玩的，一般做一点1万篇新闻的小型系统怎么写都可以，用xx框架可以实现快速开发。可是数据量到了10万，百万至千 万，他的性能还能那么高吗？一点小小的失误，可能造成整个系统的改写，甚至更本系统无法正常运行！好了，不那么多废话了。用事实说话，看例子：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">数据表 collect ( id, title ,info ,vtype) 就这4个字段，其中 title 用定长，info 用text, id 是逐渐，vtype是tinyint，vtype是索引。这是一个基本的新闻系统的简单模型。现在往里面填充数据，填充10万篇新闻。</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">最后collect 为 10万条记录，数据库表占用硬盘1.6G。OK ,看下面这条sql语句：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id,title from collect limit 1000,10; 很快；基本上0.01秒就OK，再看下面的</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id,title from collect limit 90000,10; 从9万条开始分页，结果？</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">8-9秒完成，my god 哪出问题了？？？？其实要优化这条数据，网上找得到答案。看下面一条语句:</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id from collect order by id limit 90000,10; 很快，0.04秒就OK。 为什么？因为用了id主键做索引当然快。网上的改法是：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">这就是用了id做索引的结果。可是问题复杂那么一点点，就完了。看下面的语句</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id from collect where vtype=1 order by id limit 90000,10; 很慢，用了8-9秒！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">到了这里我相信很多人会和我一样，有崩溃感觉！vtype 做了索引了啊？怎么会慢呢？vtype做了索引是不错，你直接 select id from collect where vtype=1 limit 1000,10; 是很快的，基本上0.05秒，可是提高90倍，从9万开始，那就是0.05*90=4.5秒的速度了。和测试结果8-9秒到了一个数量级。从这里开始有人 提出了分表的思路，这个和discuz 论坛是一样的思路。思路如下：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">建一个索引表： t (id,title,vtype) 并设置成定长，然后做分页，分页出结果再到 collect 里面去找info 。 是否可行呢？实验下就知道了。</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">10万条记录到 t(id,title,vtype) 里，数据表大小20M左右。用</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id from t where vtype=1 order by id limit 90000,10; 很快了。基本上0.1-0.2秒可以跑完。为什么会这样呢？我猜想是因为collect 数据太多，所以分页要跑很长的路。limit 完全和数据表的大小有关的。其实这样做还是全表扫描，只是因为数据量小，只有10万才快。OK， 来个疯狂的实验，加到100万条，测试性能。</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">加了10倍的数据，马上t表就到了200多M，而且是定长。还是刚才的查询语句，时间是0.1-0.2秒完成！分表性能没问题？错！因为我们的limit还是9万，所以快。给个大的，90万开始</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id from t where vtype=1 order by id limit 900000,10; 看看结果，时间是1-2秒！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">why ?? 分表了时间还是这么长，非常之郁闷！有人说定长会提高limit的性能，开始我也以为，因为一条记录的长度是固定的，mysql 应该可以算出90万的位置才对啊？ 可是我们高估了mysql 的智能，他不是商务数据库，事实证明定长和非定长对limit影响不大？ 怪不得有人说 discuz到了100万条记录就会很慢，我相信这是真的，这个和数据库设计有关！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1"><strong>难道MySQL 无法突破100万的限制吗？？？到了100万的分页就真的到了极限？？？</strong></p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1"><strong>答案是： NO !!!! 为什么突破不了100万是因为不会设计mysql造成的。下面介绍非分表法，来个疯狂的测试！一张表搞定100万记录，并且10G 数据库，如何快速分页！</strong></p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">好了，我们的测试又回到 collect表，开始测试结论是： 30万数据，用分表法可行，超过30万他的速度会慢道你无法忍受！当然如果用分表+我这种方法，那是绝对完美的。但是用了我这种方法后，不用分表也可以完美解决！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">答案就是：复合索引！ 有一次设计mysql索引的时候，无意中发现索引名字可以任取，可以选择几个字段进来，这有什么用呢？开始的select id from collect order by id limit 90000,10; 这么快就是因为走了索引，可是如果加了where 就不走索引了。抱着试试看的想法加了 search(vtype,id) 这样的索引。然后测试</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select id from collect where vtype=1 limit 90000,10; 非常快！0.04秒完成！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">再测试: select id ,title from collect where vtype=1 limit 90000,10; 非常遗憾，8-9秒，没走search索引！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">再测试：search(id,vtype)，还是select id 这个语句，也非常遗憾，0.5秒。</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1"><strong>综上：如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键！</strong></p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">完美解决了分页问题了。可以快速返回id就有希望优化limit ， 按这样的逻辑，百万级的limit 应该在0.0x秒就可以分完。看来mysql 语句的优化和索引时非常重要的！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">好了，回到原题，如何将上面的研究成功快速应用于开发呢？如果用复合查询，我的轻量级框架就没的用了。分页字符串还得自己写，那多麻烦？这里再看一个例子，思路就出来了：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">select * from collect where id in (9000,12,50,7000); 竟然 0秒就可以查完！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">mygod ，mysql 的索引竟然对于in语句同样有效！看来网上说in无法用索引是错误的！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">有了这个结论，就可以很简单的应用于轻量级框架了：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">代码如下：</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">$db=dblink();<br />$db-&gt;pagesize=20;</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">$sql=&quot;select id from collect where vtype=$vtype&quot;;</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">$db-&gt;execute($sql);<br />$strpage=$db-&gt;strpage(); //将分页字符串保存在临时变量，方便输出<br />while($rs=$db-&gt;fetch_array())&#123;<br />&nbsp;&nbsp; $strid.=$rs['id'].',';<br />&#125;<br />$strid=substr($strid,0,strlen($strid)-1); //构造出id字符串<br />$db-&gt;pagesize=0; //很关键，在不注销类的情况下，将分页清空，这样只需要用一次数据库连接，不需要再开；<br />$db-&gt;execute(&quot;select id,title,url,sTime,gTime,vtype,tag from collect where id in ($strid)&quot;);</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">&lt;?php while($rs=$db-&gt;fetch_array()): ?&gt;<br />&lt;tr&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['id'];?&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['url'];?&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['sTime'];?&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['gTime'];?&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['vtype'];?&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;a xhref=&quot;?act=show&amp;id=&lt;?php echo $rs['id'];?&gt;&quot; target=&quot;_blank&quot;&gt;&lt;?php echo $rs['title'];?&gt;&lt;/a&gt;&lt;/td&gt;<br />&nbsp;&nbsp;&nbsp; &lt;td&gt;&amp;nbsp;&lt;?php echo $rs['tag'];?&gt;&lt;/td&gt;<br />&lt;/tr&gt;<br />&lt;?php endwhile; ?&gt;<br />&lt;/table&gt;<br />&lt;?php<br />echo $strpage;</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">通过简单的变换，其实思路很简单：1）通过优化索引，找出id，并拼成 &quot;123,90000,12000&quot; 这样的字符串。2）第2次查询找出结果。</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">小小的索引+一点点的改动就使mysql 可以支持百万甚至千万级的高效分页！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">通过这里的例子，我反思了一点：对于大型系统，PHP千万不能用框架，尤其是那种连sql语句都看不到的框架！因为开始对于我的轻量级框架都差点崩 溃！只适合小型应用的快速开发，对于ERP,OA，大型网站，数据层包括逻辑层的东西都不能用框架。如果程序员失去了对sql语句的把控，那项目的风险将 会成几何级数增加！尤其是用mysql 的时候，mysql 一定需要专业的dba 才可以发挥他的最佳性能。一个索引所造成的性能差别可能是上千倍！</p><p style="line-height: 28px; margin: 0px 0px 10px; padding: 0px; color: #443e39; font-family: 'Hiragino Sans GB W3', 'Hiragino Sans GB', Arial, Helvetica, simsun, u5b8bu4f53; font-size: 16px; background-color: #f9f7f1">PS: 经过实际测试，到了100万的数据，160万数据，15G表，190M索引，就算走索引，limit都得0.49秒。所以<strong>分页最好别让别人看到10万条以后的数据</strong>， 要不然会很慢！就算用索引。经过这样的优化，mysql到了百万级分页是个极限！但有这样的成绩已经很不错，如果你是用sqlserver肯定卡死！而 160万的数据用 id in (str) 很快，基本还是0秒。如果这样，千万级的数据，mysql应该也很容易应付。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7525</link>
<title><![CDATA[mysql sql语句执行时间查询]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Thu, 01 Sep 2016 12:55:05 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7525</guid> 
<description>
<![CDATA[ 
	<p style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: #3d464d; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, 'WenQuanYi Micro Hei', SimSun, sans-serif; font-size: 16px; line-height: 30px">第一种：</p><p style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; margin-bottom: 16px; color: #3d464d; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, 'WenQuanYi Micro Hei', SimSun, sans-serif; font-size: 16px; line-height: 30px">开启profile</p><pre class="brush:shell; toolbar: true; auto-links: false; hljs bash" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; overflow-x: auto; padding: 2px; color: #777777; border-radius: 3px; line-height: 1.4; word-wrap: normal; background: #fdf6e3">mysql&gt; <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #dc322f" class="hljs-built_in">set</span> profiling=1; Query OK, 0 rows affected (0.00 sec)</pre><span style="font-size: 16px; line-height: 30px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, 'WenQuanYi Micro Hei', SimSun, sans-serif; color: #3d464d">eg：</span><pre class="brush:shell; toolbar: true; auto-links: false; hljs lua" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; overflow-x: auto; padding: 2px; color: #777777; border-radius: 3px; line-height: 1.4; word-wrap: normal; background: #fdf6e3">mysql&gt; <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #dc322f" class="hljs-built_in">select</span> * from test_1; mysql&gt; show profiles; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------+------------+----------------------+</span> &#124; Query_ID &#124; Duration&nbsp;&nbsp; &#124; Query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#124; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------+------------+----------------------+</span> &#124;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">1</span> &#124; <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">0.84718100</span> &#124; <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #dc322f" class="hljs-built_in">select</span> * from test_1 &#124; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------+------------+----------------------+</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">1</span> row <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">in</span> set (<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">0.00</span> sec)</pre><span style="font-size: 16px; line-height: 30px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', STHeiti, 'WenQuanYi Micro Hei', SimSun, sans-serif; color: #3d464d">第二种：(通过时间差查看)</span><pre class="hljs sql" style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; overflow-x: auto; padding: 2px; color: #777777; border-radius: 3px; line-height: 1.4; word-wrap: normal; background: #fdf6e3"><span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent">delimiter //</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">set</span> @d=<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">now</span>(); <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">select</span> * <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">from</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">comment</span>; <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">select</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">timestampdiff</span>(<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">second</span>,@d,<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">now</span>()); delimiter ;&nbsp;&nbsp; Query OK, 0 rows affected (1 min 55.58 sec)&nbsp;&nbsp; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------------------------------+</span> &#124; timestampdiff(second, @d, now()) &#124; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------------------------------+</span> &#124; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &#124; +<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #93a1a1" class="hljs-comment">----------------------------------+</span> 1 row in <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">set</span> (<span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">1</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #859900" class="hljs-keyword">min</span> <span style="box-sizing: inherit; -webkit-tap-highlight-color: transparent; color: #2aa198" class="hljs-number">55.58</span> sec) </pre>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7524</link>
<title><![CDATA[GeoHash核心原理解析]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[算法]]></category>
<pubDate>Thu, 01 Sep 2016 12:54:34 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7524</guid> 
<description>
<![CDATA[ 
	http://blog.jobbole.com/80633/<div><br /></div><div><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><span style="border: 0px; margin: 0px; padding: 0px"><strong style="border: 0px; margin: 0px; padding: 0px">引子</strong></span></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">机机是个好动又好学的孩子，平日里就喜欢拿着手机地图点点按按来查询一些好玩的东西。某一天机机到北海公园游玩，肚肚饿了，于是乎打开手机地图，搜索北海公园附近的餐馆，并选了其中一家用餐。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww2.sinaimg.cn/mw690/7178f37ejw1emyk4vz60oj20930793z3.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">饭饱之后机机开始反思了，地图后台如何根据自己所在位置查询来查询附近餐馆的呢？苦思冥想了半天，机机想出了个方法：计算所在位置P与北京所有餐馆的距离，然后返回距离&lt;=1000米的餐馆。小得意了一会儿，机机发现北京的餐馆何其多啊，这样计算不得了，于是想了，既然知道经纬度了，那它应该知道自己在西城区，那应该计算所在位置P与西城区所有餐馆的距离啊，机机运用了递归的思想，想到了西城区也很多餐馆啊，应该计算所在位置P与所在街道所有餐馆的距离，这样计算量又小了，效率也提升了。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">机机的计算思想很朴素，就是通过过滤的方法来减小参与计算的餐馆数目，从某种角度上讲，机机在使用索引技术。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">一提到索引，大家脑子里马上浮现出B树索引，因为大量的数据库（如MySQL、oracle、PostgreSQL等）都在使用B树。B树索引本质上是对索引字段进行排序，然后通过类似二分查找的方法进行快速查找，即它要求索引的字段是可排序的，一般而言，可排序的是一维字段，比如时间、年龄、薪水等等。但是对于空间上的一个点（二维，包括经度和纬度），如何排序呢？又如何索引呢？解决的方法很多，下文介绍一种方法来解决这一问题。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">思想：</strong>如果能通过某种方法将二维的点数据转换成一维的数据，那样不就可以继续使用B树索引了嘛。那这种方法真的存在嘛，答案是肯定的。目前很火的GeoHash算法就是运用了上述思想，下面我们就开始GeoHash之旅吧。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">一、感性认识GeoHash</strong></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">首先来点感性认识，<a style="border: 0px; margin: 0px; padding: 0px; text-decoration: none; color: #0099cc" href="http://openlocation.org/geohash/geohash-js/">http://openlocation.org/geohash/geohash-js/</a>&nbsp;提供了在地图上显示geohash编码的功能。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">1）GeoHash将二维的经纬度转换成字符串，比如下图展示了北京9个区域的GeoHash字符串，分别是WX4ER，WX4G2、WX4G3等等，每一个字符串代表了某一矩形区域。也就是说，这个矩形区域内所有的点（经纬度坐标）都共享相同的GeoHash字符串，这样既可以保护隐私（只表示大概区域位置而不是具体的点），又比较容易做缓存，<strong style="border: 0px; margin: 0px; padding: 0px">比如左上角这个区域内的用户不断发送位置信息请求餐馆数据</strong>，由于这些用户的GeoHash字符串都是WX4ER，所以可以把WX4ER当作key，把该区域的餐馆信息当作value来进行缓存，而如果不使用GeoHash的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww1.sinaimg.cn/mw690/7178f37ejw1emyk4wbz4bj206i06lt9b.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">2）字符串越长，表示的范围越精确。如图所示，5位的编码能表示10平方千米范围的矩形区域，而6位编码能表示更精细的区域（约0.34平方千米）</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww4.sinaimg.cn/mw690/7178f37ejw1emyk4wmjhsj208z065aad.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">3）字符串相似的表示距离相近（特殊情况后文阐述），这样可以利用字符串的前缀匹配来查询附近的POI信息。如下两个图所示，一个在城区，一个在郊区，城区的GeoHash字符串之间比较相似，郊区的字符串之间也比较相似，而城区和郊区的GeoHash字符串相似程度要低些。</p><table border="0" cellspacing="0" cellpadding="0" style="border: 1px solid #e8e8e8; margin: 0px 0px 20px; padding: 0px 5px; font-size: 15px; border-collapse: collapse; border-spacing: 0px; width: 599px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><tbody><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww4.sinaimg.cn/mw690/7178f37ejw1emyk4wyfg1j206i06lt9b.jpg" border="0" /></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww2.sinaimg.cn/mw690/7178f37ejw1emyk4xfxhfj206006s0t6.jpg" border="0" /></td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">城区</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">郊区</td></tr></tbody></table><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">通过上面的介绍我们知道了GeoHash就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近，回到我们的案例，根据所在位置查询来查询附近餐馆时，只需要将所在位置经纬度转换成GeoHash字符串，并与各个餐馆的GeoHash字符串进行前缀匹配，匹配越多的距离越近。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">二、GeoHash算法的步骤</strong></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">下面以北海公园为例介绍GeoHash算法的计算步骤</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww3.sinaimg.cn/mw690/7178f37ejw1emyk4xsu0sj208h06nt94.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">2.1. 根据经纬度计算GeoHash二进制编码</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码:</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">1）区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1；</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">2）接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0；</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">3）递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">4）如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">根据纬度算编码</p><table border="0" cellspacing="0" cellpadding="0" style="border: 1px solid #e8e8e8; margin: 0px 0px 20px; padding: 0px 5px; font-size: 15px; border-collapse: collapse; border-spacing: 0px; width: 599px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><tbody><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">bit</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">min</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">mid</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">max</strong></td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">-90.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">90.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">45.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">90.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">22.500</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">45.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">22.500</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">33.750</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">45.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">33.7500</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">45.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">42.188</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">45.000</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">40.7815</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">42.188</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">40.07825</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">40.7815</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.726625</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">40.07825</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.726625</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">39.9024375</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">40.07825</td></tr></tbody></table><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">同理，地球经度区间是[-180,180]，可以对经度116.389550进行编码。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">根据经度算编码</p><table border="0" cellspacing="0" cellpadding="0" style="border: 1px solid #e8e8e8; margin: 0px 0px 20px; padding: 0px 5px; font-size: 15px; border-collapse: collapse; border-spacing: 0px; width: 599px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><tbody><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">bit</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">min</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">mid</strong></td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center"><strong style="border: 0px; margin: 0px; padding: 0px">max</strong></td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">-180</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">180</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0.000</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">90</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">180</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">90</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">135</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">180</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">90</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">112.5</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">135</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">112.5</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">123.75</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">135</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">112.5</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">118.125</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">123.75</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">112.5</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">115.3125</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">118.125</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">0</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">115.3125</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.71875</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">118.125</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">115.3125</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.015625</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.71875</td></tr><tr style="border-width: 0px 0px 1px; border-bottom-style: solid; border-bottom-color: #e8e8e8; margin: 0px; padding: 0px"><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">1</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.015625</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.3671875</td><td valign="top" style="border-width: 0px 1px 0px 0px; border-right-style: solid; border-right-color: #e8e8e8; margin: 0px; padding: 5px; font-size: 15px; vertical-align: middle; text-align: center">116.71875</td></tr></tbody></table><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">2.2. 组码</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。同理，将编码转换成经纬度的解码算法与之相反，具体不再赘述。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww1.sinaimg.cn/mw690/7178f37ejw1emyk4yfexpj20hj04tmy1.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">三、GeoHash Base32编码长度与精度</strong></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">下表摘自维基百科：<a style="border: 0px; margin: 0px; padding: 0px; text-decoration: none; color: #0099cc" href="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</a></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">可以看出，当geohash base32编码长度为8时，精度在19米左右，而当编码长度为9时，精度在2米左右，编码长度需要根据数据情况进行选择。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww3.sinaimg.cn/mw690/7178f37ejw1emyk4yr021j20dc09omy4.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">三、GeoHash算法</strong></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">上文讲了GeoHash的计算步骤，仅仅说明是什么而没有说明为什么？为什么分别给经度和维度编码？为什么需要将经纬度两串编码交叉组合成一串编码？本节试图回答这一问题。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">如图所示，我们将二进制编码的结果填写到空间中，当将空间划分为四块时候，编码的顺序分别是左下角00，左上角01，右下脚10，右上角11，也就是类似于Z的曲线，当我们递归的将各个块分解成更小的子块时，编码的顺序是自相似的（分形），每一个子快也形成Z曲线，这种类型的曲线被称为Peano空间填充曲线。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">这种类型的空间填充曲线的优点是将二维空间转换成一维曲线（事实上是分形维），对大部分而言，编码相似的距离也相近， 但Peano空间填充曲线最大的缺点就是突变性，有些编码相邻但距离却相差很远，比如0111与1000，编码是相邻的，但距离相差很大。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww1.sinaimg.cn/mw690/7178f37ejw1emyk4z1nk0j20ip07z0ta.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">除Peano空间填充曲线外，还有很多空间填充曲线，如图所示，其中效果公认较好是Hilbert空间填充曲线，相较于Peano曲线而言，Hilbert曲线没有较大的突变。为什么GeoHash不选择Hilbert空间填充曲线呢？可能是Peano曲线思路以及计算上比较简单吧，事实上，Peano曲线就是一种四叉树线性编码方式。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww4.sinaimg.cn/mw690/7178f37ejw1emyk4zds00j20e908igmv.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><strong style="border: 0px; margin: 0px; padding: 0px">四、使用注意点</strong></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">1）由于GeoHash是将区域划分为一个个规则矩形，并对每个矩形进行编码，这样在查询附近POI信息时会导致以下问题，比如红色的点是我们的位置，绿色的两个点分别是附近的两个餐馆，但是在查询的时候会发现距离较远餐馆的GeoHash编码与我们一样（因为在同一个GeoHash区域块上），而较近餐馆的GeoHash编码与我们不一致。这个问题往往产生在边界处。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><img style="border: 0px; margin: auto; padding: 0px; font-size: 0px; color: transparent; vertical-align: middle; max-width: 100%; height: auto; display: block; clear: both" src="http://ww1.sinaimg.cn/mw690/7178f37ejw1emyk4zpab1j205l062gm1.jpg" border="0" /></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">解决的思路很简单，我们查询时，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，这样可以避免这个问题。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">2）我们已经知道现有的GeoHash算法使用的是Peano空间填充曲线，这种曲线会产生突变，造成了编码虽然相似但距离可能相差很大的问题，因此在查询附近餐馆时候，首先筛选GeoHash编码相似的POI点，然后进行实际距离计算。</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px">参考文献：</p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><a style="border: 0px; margin: 0px; padding: 0px; text-decoration: none; color: #0099cc" rel="nofollow" href="http://en.wikipedia.org/wiki/Geohash" target="_blank">http://en.wikipedia.org/wiki/Geohash</a></p><p style="border: 0px; margin: 0px 0px 20px; padding: 0px; font-size: 15px; color: #2e2e2e; font-family: 'Microsoft YaHei', 宋体, 'Myriad Pro', Lato, 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 24px"><a style="border: 0px; margin: 0px; padding: 0px; text-decoration: none; color: #0099cc" rel="nofollow" href="http://openlocation.org/geohash/geohash-js/" target="_blank">http://openlocation.org/geohash/geohash-js/</a></p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7523</link>
<title><![CDATA[如何实现按距离排序、范围查找]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Thu, 01 Sep 2016 12:53:46 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7523</guid> 
<description>
<![CDATA[ 
	<h1 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px">简介</h1><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">现在几乎所有的O2O应用中都会存在&ldquo;按范围搜素、离我最近、显示距离&rdquo;等等基于位置的交互，那这样的功能是怎么实现的呢？本文提供的实现方式，适用于所有数据库。</p><h1 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t1"></a>实现</h1><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">为了方便下面说明，先给出一个初始表结构，我使用的是<a style="color: #df3434; text-decoration: none; box-sizing: border-box; font-weight: bold" href="http://lib.csdn.net/base/14" target="_blank" title="undefined" class="replace_word">MySQL</a>：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">CREATE</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">TABLE</span> <span style="box-sizing: border-box; color: #008800" class="hljs-string">`customer`</span> (&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`id`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">INT</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">11</span>) UNSIGNED <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'自增主键'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`name`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">VARCHAR</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">5</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'名称'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`lon`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">DOUBLE</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">9</span>,<span style="box-sizing: border-box; color: #006666" class="hljs-number">6</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'经度'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`lat`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">DOUBLE</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">8</span>,<span style="box-sizing: border-box; color: #006666" class="hljs-number">6</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'纬度'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">PRIMARY</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">KEY</span> (<span style="box-sizing: border-box; color: #008800" class="hljs-string">`id`</span>) ) COMMENT=<span style="box-sizing: border-box; color: #008800" class="hljs-string">'商户表'</span> CHARSET=utf8mb4 ENGINE=InnoDB ;</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">实现过程主要分为四步：&nbsp;<br />1. 搜索&nbsp;<br />在数据库中搜索出接近指定范围内的商户，如：搜索出1公里范围内的。&nbsp;<br />2. 过滤&nbsp;<br />搜索出来的结果可能会存在超过1公里的，需要再次过滤。如果对精度没有严格要求，可以跳过。&nbsp;<br />3. 排序&nbsp;<br />距离由近到远排序。如果不需要，可以跳过。&nbsp;<br />4. 分页&nbsp;<br />如果需要2、3步，才需要对分页特殊处理。如果不需要，可以在第1步直接SQL分页。</p><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">第1步数据库完成，后3步应用程序完成。</p><h2 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t2"></a>step1 搜索</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">搜索可以用下面两种方式来实现。</p><h3 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t3"></a>区间查找</h3><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">customer表中使用两个字段存储了经度和纬度，如果提前计算出经纬度的范围，然后在这两个字段上加上索引，那搜索性能会很不错。&nbsp;<br />那怎么计算出经纬度的范围呢？已知条件是移动设备所在的经纬度，还有满足业务要求的半径，这很像初中的一道平面几何题：给定圆心坐标和半径，求该圆外切正方形四个顶点的坐标。而我们面对的是一个球体，可以使用<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="https://github.com/locationtech/spatial4j">spatial4j</a>来计算。</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">dependency</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">groupId</span>&gt;</span>com.spatial4j<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">groupId</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">artifactId</span>&gt;</span>spatial4j<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">artifactId</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">version</span>&gt;</span>0.5<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">version</span>&gt;</span> <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">dependency</span>&gt;</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li></ul></pre><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)">// 移动设备经纬度 double lon = <span style="box-sizing: border-box; color: #006666" class="hljs-number">116.312528</span>, lat = <span style="box-sizing: border-box; color: #006666" class="hljs-number">39.983733</span><span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> // 千米 int radius = <span style="box-sizing: border-box; color: #006666" class="hljs-number">1</span><span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span>&nbsp;&nbsp;SpatialContext geo = SpatialContext<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.GEO</span><span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> Rectangle rectangle = geo<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getDistCalc</span>()<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.calcBoxByDistFromPt</span>(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; geo<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.makePoint</span>(lon, lat), radius * DistanceUtils<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.KM</span>_TO_DEG, geo, null)<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> System<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.out</span><span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.println</span>(rectangle<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getMinX</span>() + <span style="box-sizing: border-box; color: #008800" class="hljs-string">&quot;-&quot;</span> + rectangle<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getMaxX</span>())<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;// 经度范围</span> System<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.out</span><span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.println</span>(rectangle<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getMinY</span>() + <span style="box-sizing: border-box; color: #008800" class="hljs-string">&quot;-&quot;</span> + rectangle<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getMaxY</span>())<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;// 纬度范围</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">计算出经纬度范围之后，SQL是这样：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">SELECT</span> id, name <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">FROM</span> customer <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">WHERE</span> (lon BETWEEN ? <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">AND</span> ?) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">AND</span> (lat BETWEEN ? <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">AND</span> ?);</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">需要给lon、lat两个字段建立联合索引：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)">INDEX <span style="box-sizing: border-box" class="hljs-escape">`i</span>dx_lon_lat<span style="box-sizing: border-box" class="hljs-escape">` </span>(<span style="box-sizing: border-box" class="hljs-escape">`l</span>on<span style="box-sizing: border-box" class="hljs-escape">`,</span> <span style="box-sizing: border-box" class="hljs-escape">`l</span>at<span style="box-sizing: border-box" class="hljs-escape">`)</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li></ul></pre><h3 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t4"></a>geohash</h3><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">geohash的原理不讲了，详细可以看<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://www.cnblogs.com/LBSer/p/3310455.html">这篇文章</a>，讲的很详细。geohash算法能把二维的经纬度编码成一维的字符串，它的特点是越相近的经纬度编码后越相似，所以可以通过前缀like的方式去匹配周围的商户。&nbsp;<br />customer表要增加一个字段，来存储每个商户的geohash编码，并且建立索引。</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">CREATE</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">TABLE</span> <span style="box-sizing: border-box; color: #008800" class="hljs-string">`customer`</span> (&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`id`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">INT</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">11</span>) UNSIGNED <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'自增主键'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`name`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">VARCHAR</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">5</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'名称'</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">COLLATE</span> <span style="box-sizing: border-box; color: #008800" class="hljs-string">'latin1_swedish_ci'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`lon`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">DOUBLE</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">9</span>,<span style="box-sizing: border-box; color: #006666" class="hljs-number">6</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'经度'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`lat`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">DOUBLE</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">8</span>,<span style="box-sizing: border-box; color: #006666" class="hljs-number">6</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'纬度'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #008800" class="hljs-string">`geo_code`</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">CHAR</span>(<span style="box-sizing: border-box; color: #006666" class="hljs-number">12</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NOT</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">NULL</span> COMMENT <span style="box-sizing: border-box; color: #008800" class="hljs-string">'geohash编码'</span>,&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">PRIMARY</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">KEY</span> (<span style="box-sizing: border-box; color: #008800" class="hljs-string">`id`</span>),&nbsp;&nbsp;&nbsp;&nbsp; INDEX <span style="box-sizing: border-box; color: #008800" class="hljs-string">`idx_geo_code`</span> (<span style="box-sizing: border-box; color: #008800" class="hljs-string">`geo_code`</span>) ) COMMENT=<span style="box-sizing: border-box; color: #008800" class="hljs-string">'商户表'</span> CHARSET=utf8mb4 ENGINE=InnoDB ;</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li><li style="box-sizing: border-box; padding: 0px 5px">12</li><li style="box-sizing: border-box; padding: 0px 5px">13</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li><li style="box-sizing: border-box; padding: 0px 5px">12</li><li style="box-sizing: border-box; padding: 0px 5px">13</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">在新增或修改一个商户的时候，维护好geo_code，那geo_code怎么计算呢？<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="https://github.com/locationtech/spatial4j">spatial4j</a>也提供了一个工具类GeohashUtils.encodeLatLon(lat, lon)，默认精度是12位。这个存储做好后，就可以通过geo_code去搜索了。拿到移动设备的经纬度，计算geo_code，这时可以指定精度计算，那指定多长呢？我们需要一个geo_code长度和距离的对照表：</p><table border="0" style="box-sizing: border-box; width: 708px; border-collapse: collapse; border-spacing: 0px; border: 1px solid #eeeeee; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px"><thead><tr style="box-sizing: border-box"><th style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">geohash length</th><th style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">width</th><th style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">height</th></tr></thead><tbody><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">1</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">5,009.4km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4,992.6km</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">2</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">1,252.3km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">624.1km</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">3</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">156.5km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">156km</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">39.1km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">19.5km</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">5</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4.9km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4.9km</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">6</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">1.2km</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">609.4m</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">7</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">152.9m</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">152.4m</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">8</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">38.2m</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">19m</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">9</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4.8m</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">4.8m</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">10</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">1.2m</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">59.5cm</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">11</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">14.9cm</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">14.9cm</td></tr><tr style="box-sizing: border-box"><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">12</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">3.7cm</td><td style="box-sizing: border-box; padding: 8px; line-height: 20px; vertical-align: top; border: 1px solid #eeeeee">1.9cm</td></tr></tbody></table><blockquote style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 15px 20px; border-left-width: 10px; border-left-style: solid; border-left-color: rgba(128, 128, 128, 0.0745098); border-radius: 0px 5px 5px 0px; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px; background-color: rgba(128, 128, 128, 0.0470588)"><p style="box-sizing: border-box; margin: 0px; line-height: 1.25"><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="https://en.wikipedia.org/wiki/Geohash#Cell_Dimensions">https://en.wikipedia.org/wiki/Geohash#Cell_Dimensions</a></p></blockquote><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">假设我们的需求是1公里范围内的商户，geo_code的长度设置为5就可以了，GeohashUtils.encodeLatLon(lat, lon, 5)。计算出移动设备经纬度的geo_code之后，SQL是这样：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">SELECT</span> id, name <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">FROM</span> customer <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">WHERE</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>);</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">这样会比区间查找快很多，并且得益于geo_code的相似性，可以对热点区域做缓存。但这样使用geohash还存在一个问题，geohash最终是在地图上铺上了一个网格，每一个网格代表一个geohash值，当传入的坐标接近当前网格的边界时，用上面的搜索方式就会丢失它附近的数据。比如下图中，在绿点的位置搜索不到白家大院，绿点和白家大院在划分的时候就分到了两个格子中。&nbsp;<br /><img style="border: none; box-sizing: border-box; max-width: 100%" src="http://img.blog.csdn.net/20160715101657127" border="0" alt="这里写图片描述" />&nbsp;<br />解决这个问题思路也比较简单，我们查询时，除了使用绿点的geohash编码进行匹配外，还使用周围8个网格的geohash编码，这样可以避免这个问题。那怎么计算出周围8个网格的geohash呢，可以使用<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="https://github.com/kungfoo/geohash-java">geohash-java</a>来解决。</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">dependency</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">groupId</span>&gt;</span>ch.hsr<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">groupId</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">artifactId</span>&gt;</span>geohash<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">artifactId</span>&gt;</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;<span style="box-sizing: border-box; color: #000088" class="hljs-title">version</span>&gt;</span>1.3.0<span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">version</span>&gt;</span> <span style="box-sizing: border-box; color: #006666" class="hljs-tag">&lt;/<span style="box-sizing: border-box; color: #000088" class="hljs-title">dependency</span>&gt;</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li></ul></pre><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)">// 移动设备经纬度 double lon = <span style="box-sizing: border-box; color: #006666" class="hljs-number">116.312528</span>, lat = <span style="box-sizing: border-box; color: #006666" class="hljs-number">39.983733</span><span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> GeoHash geoHash = GeoHash<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.withCharacterPrecision</span>(lat, lon, <span style="box-sizing: border-box; color: #006666" class="hljs-number">10</span>)<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> // 当前 System<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.out</span><span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.println</span>(geoHash<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.toBase</span>32())<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> // N, NE, E, SE, S, SW, W, NW GeoHash[] adjacent = geoHash<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.getAdjacent</span>()<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> for (GeoHash hash : adjacent) &#123;&nbsp;&nbsp;&nbsp;&nbsp; System<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.out</span><span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.println</span>(hash<span style="box-sizing: border-box; color: #444444" class="hljs-preprocessor">.toBase</span>32())<span style="box-sizing: border-box; color: #880000" class="hljs-comment">;</span> &#125;<ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">最终我们的sql变成了这样：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">SELECT</span> id, name <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">FROM</span> customer <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">WHERE</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>) <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">OR</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">LIKE</span> CONCAT(?, <span style="box-sizing: border-box; color: #008800" class="hljs-string">'%'</span>);</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li><li style="box-sizing: border-box; padding: 0px 5px">10</li><li style="box-sizing: border-box; padding: 0px 5px">11</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">原来的1次查询变成了9次查询，性能肯定会下降，这里可以优化下。还用上面的需求场景，搜索1公里范围内的商户，从上面的表格知道，geo_code长度为5时，网格宽高是4.9KM，用9个geo_code查询时，范围太大了，所以可以将geo_code长度设置为6，即缩小了查询范围，也满足了需求。还可以继续优化，在存储geo_code时，只计算到6位，这样就可以将sql变成这样：</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box" class="hljs-operator"><span style="box-sizing: border-box; color: #000088" class="hljs-keyword">SELECT</span> id, name <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">FROM</span> customer <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">WHERE</span> geo_code <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">IN</span> (?, ?, ?, ?, ?, ?, ?, ?, ?);</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">这样将前缀匹配换成了直接匹配，速度会提升很多。</p><h2 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t5"></a>step2 过滤</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">上面两种搜索方式，都不是精确搜索，只是尽量缩小搜索范围，提升响应速度。所以需要在应用程序中做过滤，把距离大于1公里的商户过滤掉。计算距离同样使用<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="https://github.com/locationtech/spatial4j">spatial4j</a>。</p><pre class="prettyprint" style="white-space: nowrap; word-wrap: break-word; box-sizing: border-box; position: relative; overflow-y: hidden; overflow-x: auto; margin-top: 0px; margin-bottom: 1.1em; font-family: 'Source Code Pro', monospace; padding: 5px 5px 5px 60px; font-size: 14px; line-height: 1.45; word-break: break-all; color: #333333; border: 1px solid rgba(128, 128, 128, 0.0745098); border-radius: 0px; background-color: rgba(128, 128, 128, 0.0470588)"><span style="box-sizing: border-box; color: #880000" class="hljs-comment">// 移动设备经纬度</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">double</span> lon1 = <span style="box-sizing: border-box; color: #006666" class="hljs-number">116.3125333347639</span>, lat1 = <span style="box-sizing: border-box; color: #006666" class="hljs-number">39.98355521792821</span>; <span style="box-sizing: border-box; color: #880000" class="hljs-comment">// 商户经纬度</span> <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">double</span> lon2 = <span style="box-sizing: border-box; color: #006666" class="hljs-number">116.312528</span>, lat2 = <span style="box-sizing: border-box; color: #006666" class="hljs-number">39.983733</span>;&nbsp;&nbsp;SpatialContext geo = SpatialContext.GEO; <span style="box-sizing: border-box; color: #000088" class="hljs-keyword">double</span> <span style="box-sizing: border-box; color: #660066" class="hljs-built_in">distance</span> = geo.calcDistance(geo.makePoint(lon1, lat1), geo.makePoint(lon2, lat2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* DistanceUtils.DEG_TO_KM; System.<span style="box-sizing: border-box; color: #000088" class="hljs-keyword">out</span>.println(<span style="box-sizing: border-box; color: #660066" class="hljs-built_in">distance</span>);<span style="box-sizing: border-box; color: #880000" class="hljs-comment">// KM</span><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li></ul><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: #dddddd; list-style: none; text-align: right; background-color: #eeeeee"><li style="box-sizing: border-box; padding: 0px 5px">1</li><li style="box-sizing: border-box; padding: 0px 5px">2</li><li style="box-sizing: border-box; padding: 0px 5px">3</li><li style="box-sizing: border-box; padding: 0px 5px">4</li><li style="box-sizing: border-box; padding: 0px 5px">5</li><li style="box-sizing: border-box; padding: 0px 5px">6</li><li style="box-sizing: border-box; padding: 0px 5px">7</li><li style="box-sizing: border-box; padding: 0px 5px">8</li><li style="box-sizing: border-box; padding: 0px 5px">9</li></ul></pre><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">过滤代码就不写了，遍历一遍搜索结果即可。</p><h2 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t6"></a>step3 排序</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">同样，排序也需要在应用程序中处理。排序基于上面的过滤结果做就可以了Collections.sort(list, comparator)。</p><h2 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t7"></a>step4 分页</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">如果需要2、3步，只能在内存中分页，做法也很简单，可以参考<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://blog.csdn.net/ghsau/article/details/7243540">这篇文章</a>。</p><h1 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t8"></a>总结</h1><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">全文的重点都在于搜索如何实现，更好的利用数据库的索引，两种搜索方式以百万数据量为分割线，第一种适用于百万以下，第二种适用于百万以上，未经过严格验证。可能有人会有疑问，过滤和排序都在应用层做，内存占用会不会很严重？这是个潜在问题，但大多数情况下不会。看我们大部分的应用场景，都是单一种类POI(Point Of Interest)的搜索，如酒店、美食、KTV、电影院等等，这种数据密度是很小，1公里内的酒店，能有多少家，50家都算多的，所以最终要看具体业务数据密度。本文没有分析原理，只讲了具体实现，有关分析的文章可以看参考链接。</p><hr style="box-sizing: border-box; margin: 2em 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: solid; border-top-color: rgba(128, 128, 128, 0.0980392); color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px" /><h1 style="margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: #333333; font-family: 'microsoft yahei'; line-height: 26px"><a style="color: #336699; box-sizing: border-box" name="t9"></a>参考</h1><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px"><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://www.infoq.com/cn/articles/depth-study-of-Symfony2">http://www.infoq.com/cn/articles/depth-study-of-Symfony2</a>&nbsp;<br /><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://tech.meituan.com/lucene-distance.html">http://tech.meituan.com/lucene-distance.html</a>&nbsp;<br /><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://blog.csdn.net/liminlu0314/article/details/8553926">http://blog.csdn.net/liminlu0314/article/details/8553926</a>&nbsp;<br /><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates">http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates</a>&nbsp;<br /><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://www.cnblogs.com/LBSer/p/3310455.html">http://www.cnblogs.com/LBSer/p/3310455.html</a>&nbsp;<br /><a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://cevin.net/geohash/">http://cevin.net/geohash/</a></p><p style="box-sizing: border-box; margin: 0px 0px 1.1em; color: #333333; font-family: 'microsoft yahei'; font-size: 14px; line-height: 26px">本文来自：<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://blog.csdn.net/ghsau">高爽&#124;Coder</a>，原文地址：<a style="color: #336699; text-decoration: none; box-sizing: border-box" href="http://blog.csdn.net/ghsau/article/details/50591932">http://blog.csdn.net/ghsau/article/details/50591932</a>，转载请注明。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7522</link>
<title><![CDATA[康托尔、哥德尔、图灵——永恒的金色对角线(rev#2)]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[编译原理]]></category>
<pubDate>Wed, 31 Aug 2016 15:27:03 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7522</guid> 
<description>
<![CDATA[ 
	<p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>我看到了它，却不敢相信它</em><sup>[1]</sup><em>。</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>&mdash;&mdash;</em><em>康托尔</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>计算机是数学家一次失败思考的产物。</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>&mdash;&mdash;</em><em>无名氏</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><a style="color: #313428" href="http://en.wikipedia.org/wiki/Kurt_Godel">哥德尔</a>的<a style="color: #313428" href="http://www.answers.com/topic/g-del-s-incompleteness-theorems">不完备性定理</a>震撼了20世纪数学界的天空，其数学意义颠覆了<a style="color: #313428" href="http://en.wikipedia.org/wiki/David_Hilbert">希尔伯特</a>的形式化数学的宏伟计划，其哲学意义直到21世纪的今天仍然不断被延伸到各个自然学科，深刻影响着人们的思维。<a style="color: #313428" href="http://www.alanturing.net/">图灵</a>为了解决希尔伯特著名的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Hilbert's_tenth_problem">第十问题</a>而提出有效计算模型，进而作出了<a style="color: #313428" href="http://en.wikipedia.org/wiki/Computability_theory_(computation)">可计算理论</a>和现代计算机的奠基性工作，著名的停机问题给出了机械计算模型的能力极限，其深刻的意义和漂亮的证明使它成为可计算理论中的标志性定理之一。<a style="color: #313428" href="http://en.wikipedia.org/wiki/Alonzo_Church">丘齐</a>，跟图灵同时代的天才，则从另一个抽象角度提出了<a style="color: #313428" href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda算子</a>的思想，与<a style="color: #313428" href="http://en.wikipedia.org/wiki/Turing_machine">图灵机</a>抽象的倾向于硬件性不同，丘齐的lambda算子理论是从数学的角度进行抽象，不关心运算的机械过程而只关心运算的抽象性质，只用最简洁的几条公理便建立起了与图灵机<a style="color: #313428" href="http://en.wikipedia.org/wiki/Turing_machine#Models_equivalent_to_the_Turing_machine_model">完全等价</a>的计算模型，其体现出来的数学抽象美开出了<a style="color: #313428" href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程语言</a>这朵奇葩，<a style="color: #313428" href="http://en.wikipedia.org/wiki/Lisp_programming_language">Lisp</a>、<a style="color: #313428" href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>、<a style="color: #313428" href="http://www.haskell.org/">Haskell</a>&hellip; 这些以抽象性和简洁美为特点的语言至今仍然活跃在计算机科学界，虽然由于其本质上源于lambda算子理论的抽象方式不符合人的思维习惯从而注定无法成为主流的编程语言<sup>[2]</sup>，然而这仍然无法妨碍它们成为编程理论乃至计算机学科的最佳教本。而诞生于函数式编程语言的神奇的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Y_combinator">Y combinator</a>至今仍然让人们陷入深沉的震撼和反思当中&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">然而，这一切的一切，看似不很相关却又有点相关，认真思考其关系却又有点一头雾水的背后，其实隐隐藏着一条线，这条线把它们从本质上串到了一起，而顺着时光的河流逆流而上，我们将会看到，这条线的尽头，不是别人，正是只手拨开被不严密性问题困扰的19世纪数学界阴沉天空的天才数学家<a style="color: #313428" href="http://en.wikipedia.org/wiki/Georg_Cantor">康托尔</a>，康托尔创造性地将一一对应和对角线方法运用到无穷集合理论的建立当中，这个被希尔伯特称为&ldquo;谁也无法将我们从康托尔为我们创造的乐园中驱逐出去&rdquo;、被罗素称为&ldquo;19世纪最伟大的智者之一&rdquo;的人，他在<a style="color: #313428" href="http://www.amazon.com/Contributions-Founding-Theory-Transfinite-Numbers/dp/0875481574/ref=sr_1_4/103-3576835-0834231?ie=UTF8&amp;s=books&amp;qid=1177237889&amp;sr=8-4">集合论方面的工作</a>终于驱散了不严密性问题带来的阴霾，仿佛一道金色的阳光刺破乌云，19世纪的数学终于看到了真正严格化的曙光，数学终于得以站在了前所未有的坚固的基础之上；集合论至今仍是数学里最基础和最重要的理论之一。而康托尔当初在研究无穷集合时最具天才的方法之一&mdash;&mdash;对角线方法&mdash;&mdash;则带来了极其深远的影响，其纯粹而直指事物本质的思想如洪钟大吕般响彻数学和哲学的每一个角落<sup>[3]</sup>。随着本文的展开，你将会看到，刚才提到的一切，歌德尔的不完备性定理，图灵的停机问题，lambda算子理论中神奇的Y combinator、乃至著名的罗素悖论、理发师悖论等等，其实都源自这个简洁、纯粹而同时又是最优美的数学方法，反过来说，从康托尔的对角线方法出发，我们可以轻而易举地推导出哥德尔的不完备性定理，而由后者又可以轻易导出停机问题和Y combinator，实际上，我们将会看到，后两者也可以直接由康托尔的对角线方法导出。尤其是Y combinator，这个形式上绕来绕去，本质上捉摸不透，看上去神秘莫测的算子，其实只是一个非常自然而然的推论，如果从哥德尔的不完备性定理出发，它甚至比停机问题还要来得直接简单。总之，你将会看到这些看似深奥的理论是如何由一个至为简单而又至为深刻的数学方法得出的，你将会看到最纯粹的数学美。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>图灵的停机问题</strong><strong>(The Halting Problem)</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>了解停机问题的可以直接跳过这一节，到下一节&ldquo;Y Combinator&rdquo;，了解后者的再跳到下一节&ldquo;哥德尔的不完备性定理&rdquo;</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们还是从图灵著名的停机问题说起，一来它相对来说是我们要说的几个定理当中最简单的，二来它也最贴近程序员。实际上，我以前曾写过<a style="color: #313428" href="http://blog.csdn.net/pongba/archive/2006/03/11/621723.aspx">一篇关于图灵机的文章</a>，有兴趣的读者可以从那篇开始，那篇主要是从理论上阐述，所以这里我们打算避开抽象的理论，换一种符合程序员思维习惯的直观方式来加以解释。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>停机问题</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">那么，如何来证明这个停机问题呢？反证。假设我们某一天真做出了这么一个极度聪明的万能算法（就叫God_algo吧），你只要给它一段程序（二进制描述），再给它这段程序的输入，它就能告诉你这段程序在这个输入上会不会结束（停机），我们来编写一下我们的这个算法吧：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">bool God_algo(char* program, char* input)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&#123;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">if(<em>&lt;program</em>&gt;&nbsp;<em>halts on&nbsp;</em>&lt;<em>input</em>&gt;)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return true;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return false;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&#125;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这里我们假设if的判断语句里面是你天才思考的结晶，它能够像上帝一样洞察一切程序的宿命。现在，我们从这个God_algo出发导出一个新的算法：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">bool Satan_algo(char* program)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&#123;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">if(&nbsp;<em>God_algo</em>(program, program) )&#123;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">while(1); // loop forever!</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return false; // can never get here!</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&#125;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">else</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return true;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&#125;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">正如它的名字所暗示的那样，这个算法便是一切邪恶的根源了。当我们把这个算法运用到它自身身上时，会发生什么呢？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Satan_algo(Satan_algo);</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们来分析一下这行简单的调用：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">显然，Satan_algo(Satan_algo)这个调用要么能够运行结束返回（停机），要么不能返回（loop forever）。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>如果它能够结束</em>，那么Santa_algo算法里面的那个if判断就会成立（因为God_algo(Santa_algo,Santa_algo)将会返回true），从而程序便进入那个包含一个无穷循环while(1);的if分支，于是这个Satan_algo(Satan_algo)调用<em>便永远不会返回（结束）了</em>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">而<em>如果</em><em>Satan_algo(Satan_algo)</em><em>不能结束（停机）呢</em>，则if判断就会失败，从而选择另一个if分支并返回true，即<em>Satan_algo(Satan_algo)</em><em>又</em><em>能够返回（停机）</em>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">总之，我们有：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>Satan_algo(Satan_algo)</em><em>能够停机</em><em>&nbsp;</em><em>=&gt;&nbsp;</em><em>它不能停机</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>Satan_algo(Satan_algo)</em><em>不能停机</em><em>&nbsp;</em><em>=&gt;&nbsp;</em><em>它能够停机</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">所以它停也不是，不停也不是。左右矛盾。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">于是，我们的假设，即God_algo算法的存在性，便不成立了。正如<a style="color: #313428" href="http://en.wikipedia.org/wiki/Joseph_Louis_Lagrange">拉格朗日</a>所说：&ldquo;陛下，我们不需要（上帝）这个假设&rdquo;<sup>[4]</sup>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个证明相信每个程序员都能够容易的看懂。然而，这个看似不可捉摸的技巧背后其实隐藏着深刻的数学原理（甚至是哲学原理）。在没有认识到这一数学原理之前，至少我当时是对于图灵如何想出这一绝妙证明感到无法理解。但后面，在介绍完了与图灵的停机问题&ldquo;同构&rdquo;的Y combinator之后，我们会深入哥德尔的不完备性定理，在理解了哥德尔不完备性定理之后，我们从这一同样绝妙的定理出发，就会突然发现，离停机问题和神奇的Y combinator只是咫尺之遥而已。当然，最后我们会回溯到一切的尽头，康托尔那里，看看停机问题、Y combinator、以及不完备性定理是如何自然而然地由康托尔的对角线方法推导出来的，我们将会看到这些看似神奇的构造性证明的背后，其实是一个简洁优美的数学方法在起作用。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>Y Combinator</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>了解</em><em>Y combinator</em><em>的请直接跳过这一节，到下一节</em><em>&ldquo;</em><em>哥德尔的不完备性定理</em><em>&rdquo;</em><em>。</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">让我们暂且搁下但记住绕人的图灵停机问题，走进函数式编程语言的世界，走进由跟图灵机理论等价的lambda算子发展出来的另一个平行的语言世界。让我们来看一看被人们一代一代吟唱着的神奇的Y Combinator&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">关于Y Combinator的文章可谓数不胜数，这个由师从希尔伯特的著名逻辑学家<a style="color: #313428" href="http://en.wikipedia.org/wiki/Haskell_Curry">Haskell B.Curry</a>（Haskell语言就是以他命名的，而函数式编程语言里面的Curry手法也是以他命名）&ldquo;发明&rdquo;出来的组合算子（Haskell是研究<a style="color: #313428" href="http://en.wikipedia.org/wiki/Combinatory_logic">组合逻辑(combinatory logic)</a>的）仿佛有种神奇的魔力，它能够算出给定lambda表达式（函数）的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Fixed_point">不动点</a>。从而使得递归成为可能。事实上，我们待会就会看到，Y Combinator在神奇的表面之下，其实隐藏着深刻的意义，其背后体现的意义，曾经开出过历史上最灿烂的数学之花，所以MIT的计算机科学系将它做成系徽也就不足为奇了<sup>[5]</sup>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">当然，要了解这个神奇的算子，我们需要一点点lambda算子理论的基础知识，不过别担心，lambda算子理论是我目前见过的最简洁的公理系统，这个系统仅仅由三条非常简单的公理构成，而这三条公理里面我们又只需要关注前两条。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>以下小节</em><em>&mdash;&mdash;lambda calculus&mdash;&mdash;</em><em>纯粹是为了没有接触过</em><em>lambda</em><em>算子理论的读者准备的，并不属于本文重点讨论的东西，然而要讨论</em><em>Y combinator</em><em>就必须先了解一下</em><em>lambda</em><em>（当然，以编程语言来了解也行，但是你会看到，丘齐最初提出的</em><em>lambda</em><em>算子理论才是最最简洁和漂亮的，学起来也最省事。）所以我单独准备了一个小节来介绍它。如果你已经知道，可以跳过这一小节。不知道的读者也可以跳过这一小节去</em><em>wikipedia</em><em>上面看，这里的介绍使用了</em><em>wikipedia</em><em>上的方式</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>lambda calculus</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">先来看一下lambda表达式的基本语法(BNF)：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&lt;expr&gt; ::= &lt;identifier&gt;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&lt;expr&gt; ::=&nbsp;<em>lambda</em>&nbsp;&lt;identifier-list&gt;. &lt;expr&gt;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&lt;expr&gt; ::= (&lt;expr&gt; &lt;expr&gt;)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">前两条语法用于生成lambda表达式（lambda函数），如：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>lambda</em>&nbsp;x y. x + y</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>haskell</em><em>里面为了简洁起见用</em><em>&ldquo;&#92;&rdquo;</em><em>来代替希腊字母</em><em>lambda</em><em>，它们形状比较相似。故而上面的定义也可以写成：</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>&#92; x y. x + y</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这是一个匿名的加法函数，它接受两个参数，返回两值相加的结果。当然，这里我们为了方便起见赋予了lambda函数直观的计算意义，而实际上lambda calculus里面一切都只不过是文本替换，有点像C语言的宏。并且这里的&ldquo;+&rdquo;我们假设已经是一个具有原子语义的运算符<sup>[6]</sup>，此外，为了方便我们使用了中缀表达（按照lambda calculus系统的语法实际上应该写成&ldquo;(+ x y)&rdquo;才对&mdash;&mdash;参考第三条语法）。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">那么，函数定义出来了，怎么使用呢？最后一条规则就是用来调用一个lambda函数的：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">((<em>lambda</em>&nbsp;x y. x + y) 2 3)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">以上这一行就是把刚才定义的加法函数运用到2和3上（这个调用语法形式跟<a style="color: #313428" href="http://en.wikipedia.org/wiki/Imperative_programming">命令式语言(imperative language)</a>惯用的调用形式有点区别，后者是&ldquo;f(x, y)&rdquo;，而这里是&ldquo;(f x y)&rdquo;，不过好在顺序没变:) ）。为了表达简洁一点，我们可以给(<em>lambda</em>&nbsp;x y. x + y)起一个名字，像这样：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let Add = (<em>lambda</em>&nbsp;x y. x + y)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这样我们便可以使用Add来表示该lambda函数了：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">(Add 2 3)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">不过还是为了方便起见，后面调用的时候一般用&ldquo;Add(2, 3)&rdquo;，即我们熟悉的形式。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">有了语法规则之后，我们便可以看一看这个语言系统的两条简单至极的公理了：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>Alpha</em><em>转换公理</em>：例如，&ldquo;lambda x y. x + y&rdquo;转换为&ldquo;lambda a b. a + b&rdquo;。换句话说，函数的参数起什么名字没有关系，可以随意替换，只要函数体里面对参数的使用的地方也同时注意相应替换掉就是了。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>Beta</em><em>转换公理</em>：例如，&ldquo;(lambda x y. x + y) 2 3&rdquo;转换为&ldquo;2 + 3&rdquo;。这个就更简单了，也就是说，当把一个lambda函数用到参数身上时，只需用实际的参数来替换掉其函数体中的相应变量即可。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">就这些。是不是感觉有点太简单了？但事实就是如此，lambda算子系统从根本上其实就这些东西，然而你却能够从这几个简单的规则中推演出神奇无比的Y combinator来。我们这就开始！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>递归的迷思</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">敏锐的你可能会发现，就以上这两条公理，我们的lambda语言中无法表示递归函数，为什么呢？假设我们要计算经典的阶乘，递归描述肯定像这样：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">f(n):</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">if n == 0 return 1</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return n*f(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">当然，上面这个程序是假定n为正整数。这个程序显示了一个特点，f在定义的过程中用到了它自身。那么如何在lambda算子系统中表达这一函数呢？理所当然的想法如下：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>lambda</em>&nbsp;n. If_Else n==0 1 n*&lt;<em>self</em>&gt;(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">当然，上面的程序假定了If_Else是一个已经定义好的三元操作符（你可以想象C的&ldquo;?:&rdquo;操作符，后面跟的三个参数分别是判断条件、成功后求值的表达式、失败后求值的表达式。那么很显然，这个定义里面有一个地方没法解决，那就是&lt;<em>self</em>&gt;那个地方我们应该填入什么呢？很显然，熟悉C这类命令式语言的人都知道应该填入这个函数本身的名字，然而lambda算子系统里面的lambda表达式（或称函数）是没有名字的。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">怎么办？难道就没有办法实现递归了？或者说，丘齐做出的这个lambda算子系统里面根本没法实现递归从而在计算能力上面有重大的缺陷？显然不是。马上你就会看到Y combinator是如何把一个看上去非递归的lambda表达式像变魔术那样变成一个递归版本的。在成功之前我们再失败一次，注意下面的尝试：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let F =&nbsp;<em>lambda</em>&nbsp;n. IF_Else n==0 1 n*F(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">看上去不错，是吗？可惜还是不行。因为let F只是起到一个<a style="color: #313428" href="http://en.wikipedia.org/wiki/Syntactic_sugar">语法糖</a>的作用，在它所代表的lambda表达式还没有完全定义出来之前你是不可以使用F这个名字的。更何况实际上丘齐当初的lambda算子系统里面也并没有这个语法元素，这只是刚才为了简化代码而引入的语法糖。当然，了解这个let语句还是有意义的，后面还会用到。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>一次成功的尝试</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">在上面几次失败的尝试之后，我们是不是就一筹莫展了呢？别忘了软件工程里面的一条黄金定律：&ldquo;任何问题都可以通过增加一个间接层来解决&rdquo;。不妨把它沿用到我们面临的递归问题上：没错，我们的确没办法在一个lambda函数的定义里面直接（按名字）来调用其自身。但是，可不可以间接调用呢？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们回顾一下刚才不成功的定义：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>lambda</em>&nbsp;n. If_Else n==0 1 n*&lt;<em>self</em>&gt;(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在&lt;self&gt;处不是缺少&ldquo;这个函数自身&rdquo;嘛，既然不能直接填入&ldquo;这个函数自身&rdquo;，我们可以增加一个参数，也就是说，把&lt;self&gt;参数化：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>lambda</em>&nbsp;<strong>self</strong>&nbsp;n. If_Else n==0 1 n*<strong>self</strong>(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">上面这个lambda算子总是合法定义了吧。现在，我们调用这个函数的时候，只要加传一个参数self，这个参数不是别人，正是这个函数自身。还是为了简单起见，我们用let语句来给上面这个函数起个别名：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let P =&nbsp;<em>lambda</em>&nbsp;self n. If_Else n==0 1 n*self(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们这样调用，比如说我们要计算3的阶乘：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>P</strong>(<strong>P</strong>, 3)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">也就是说，把P自己作为P的第一个参数（注意，调用的时候P已经定义完毕了，所以我们当然可以使用它的名字了）。这样一来，P里面的self处不就等于是P本身了吗？自身调用自身，递归！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">可惜这只是个美好的设想，还差一点点。我们分析一下P(P, 3)这个调用。利用前面讲的Beta转换规则，这个函数调用展开其实就是（你可以完全把P当成一个宏来进行展开！）：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">IF_Else n==0 1 n*<strong>P</strong>(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">看出问题了吗？这里的<strong>P</strong>(n-1)虽然调用到了P，然而只给出了一个参数；而从P的定义来看，它是需要两个参数的（分别为<strong>self</strong>和n）！也就是说，为了让<strong>P</strong>(n-1)变成良好的调用，我们得加一个参数才行，所以我们得稍微修改一下P的定义：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let P =&nbsp;<em>lambda</em>&nbsp;<strong>self</strong>&nbsp;n. If_Else n==0 1 n*<strong>self</strong>(<strong>self</strong>, n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">请注意，我们在P的函数体内调用self的时候增加了一个参数。现在当我们调用P(P, 3)的时候，展开就变成了：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">IF_Else 3==0 1 3*<strong>P</strong>(<strong>P</strong>, 3-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">而<strong>P</strong>(<strong>P</strong>, 3-1)是对P合法的递归调用。这次我们真的成功了！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>不动点原理</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">然而，看看我们的P的定义，是不是很丑陋？&ldquo;n*<strong>self</strong>(<strong>self</strong>, n-1)&rdquo;？什么玩意？为什么要多出一个多余的self？<a style="color: #313428" href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>！怎么办呢？我们想起我们一开始定义的那个失败的P，虽然行不通，但最初的努力往往是大脑最先想到的最直观的做法，我们来回顾一下：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let P =&nbsp;<em>lambda</em>&nbsp;self n. If_Else n==0 1 n*<strong>self</strong>(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个P的函数体就非常清晰，没有冗余成分，虽然参数列表里面多出一个self，但我们其实根本不用管它，看函数体就行了，self这个名字已经可以说明一切了对不对？但很可惜这个函数不能用。我们再来回想一下为什么不能用呢？因为当你调用P(P, n)的时候，里面的self(n-1)会展开为P(n-1)而P是需要两个参数的。唉，要是这里的self是一个&ldquo;真正&rdquo;的，只需要一个参数的递归阶乘函数，那该多好啊。为什么不呢？干脆我们假设出一个&ldquo;真正&rdquo;的递归阶乘函数：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">power(n):</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">if(n==0) return 1;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return n*power(n-1);</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">但是，前面不是说过了，这个理想的版本无法在lambda算子系统中定义出来吗（由于lambda函数都是没名字的，无法自己内部调用自己）？不急，我们并不需要它被定义出来，我们只需要在头脑中&ldquo;假设&rdquo;它以&ldquo;某种&rdquo;方式被定义出来了，现在我们把这个真正完美的power传给P，这样：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">P(<strong>power</strong>, 3)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">注意它跟P(P, 3)的不同，P(P, 3)我们传递的是一个有缺陷的P为参数。而P(power, 3)我们则是传递的一个真正的递归函数power。我们试着展开P(power, 3):</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">IF_Else 3==0 1 3*<strong>power</strong>(3-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">发生了什么？？power(3-1)将会计算出2的阶乘（别忘了，power是我们设想的完美递归函数），所以这个式子将会忠实地计算出3的阶乘！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">回想一下我们是怎么完成这项任务的：我们设想了一个以某种方式构造出来的完美的能够内部自己调用自己的递归阶乘函数power，我们发现把这个power传给P的话，P(power, n)的展开式就是真正的递归计算n阶乘的代码了。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">你可能要说：废话！都有了power了我们还要费那事把它传给P来个P(power, n)干嘛？直接power(n)不就得了？! 别急，之所以设想出这个power只是为了引入不动点的概念，而不动点的概念将会带领我们发现Y combinator。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">什么是不动点？一点都不神秘。让我们考虑刚才的power与P之间的关系。一个是真正可递归的函数，一个呢，则是以一个额外的self参数来试图实现递归的伪递归函数，我们已经看到了把power交给P为参数发生了什么，对吧？不，似乎还没有，我们只是看到了，&ldquo;把power加上一个n一起交给P为参数&rdquo;能够实现真正的递归。现在我们想考虑power跟P之间的关系，直接把power交给P如何？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">P(power)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这是什么？这叫函数的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Partial_evaluation"><em>部分求值</em>(<em>partial evaluation</em>)</a>。换句话说，第一个参数是给出来了，但第二个参数还悬在那里，等待给出。那么，光给一个参数得到的是什么呢？是&ldquo;还剩一个参数待给的一个新的函数&rdquo;。其实也很简单，只要按照Beta转换规则做就是了，把P的函数体里面的self出现处皆替换为power就可以了。我们得到：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">IF_Else n==0 1 n*power(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">当然，这个式子里面还有一个变量没有绑定，那就是n，所以这个式子还不能求值，你需要给它一个n才能具体求值，对吧。这么说，这可不就是一个以n为参数的函数么？实际上就是的。在lambda算子系统里面，如果给一个lambda函数的参数不足，则得到的就是一个新的lambda函数，这个新的lambda函数所接受的参数也就是你尚未给出的那些参数。换句话来说，调用一个lambda函数可以分若干步来进行，每次只给出一部分参数，而只有等所有参数都给齐了，函数的求值结果才能出来，否则你得到的就是一个&ldquo;中间函数&rdquo;。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">那么，这跟不动点定理有什么关系？关系大了，刚才不是说了，P(power)返回的是一个新的&ldquo;中间函数&rdquo;嘛？这个&ldquo;中间函数&rdquo;的函数体我们刚才已经看到了，就是简单地展开P(power)而已，回顾一遍：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">IF_Else n==0 1 n*power(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们已经知道，这是个函数，参数n待定。因此我们不妨给它加上一个&ldquo;lambda n&rdquo;的帽子，这样好看一点：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>lambda</em>&nbsp;n. IF_Else n==0 1 n*power(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这是什么呢？这可不就是power本身的定义？（当然，如果我们能够定义power的话）。不信我们看看power如果能够定义出来像什么样子：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let power =&nbsp;<em>lambda</em>&nbsp;n. IF_Else n==0 1 n*power(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">一模一样！也就是说，P(power)展开后跟power是一样的。即：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>P(power) = power</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">以上就是所谓的<em>不动点</em>。即对于函数P来说power是这样一个&ldquo;点&rdquo;：当把P用到power身上的时候，得到的结果仍然还是power，也就是说，power这个&ldquo;点&rdquo;在P的作用下是&ldquo;不动&rdquo;的。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">可惜的是，这一切居然都是建立在一个不存在的power的基础上的，又有什么用呢？可别过早提&ldquo;不存在&rdquo;这个词，你觉得一样东西不存在或许只是你没有找到使它存在的正确方法。我们已经看到power是跟P有着密切联系的。密切到什么程度呢？对于伪递归的P，存在一个power，满足P(power)=power。注意，这里所说的&ldquo;伪递归&rdquo;的P，是指这样的形式：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let P =&nbsp;<em>lambda</em>&nbsp;self n. If_Else n==0 1 n*<strong>self</strong>(n-1) // 注意，不是self(self,n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">一般化的描述就是，对任一伪递归F（回想一下伪递归的F如何得到&mdash;&mdash;是我们为了解决lambda函数不能引用自身的问题，于是给理想的f加一个self参数从而得到的），必存在一个理想f（F就是从这个理想f演变而来的），满足F(f) = f。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">那么，现在的问题就归结为如何针对F找到它的f了。根据F和f之间的密切联系（F就比f多出一个self参数而已），我们可以从F得出f吗？假设我们可以（又是假设），也就是说假设我们找到了一根魔棒，把它朝任意一个伪递归的F一挥，眼前一花，它就变成了真正的f了。这根魔棒如果存在的话，它具有什么性质？我们假设这个神奇的函数叫做Y，把Y用到任何伪递归的函数F上就能够得到真正的f，也就是说：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Y(F) = f</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">结合上面的F(f) = f，我们得到：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Y(F) = f = F(f) = F(Y(F))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">也就是说，Y具有性质：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>Y(F) = F(Y(F))</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">性质倒是找出来了，怎么构造出这个Y却又成了难题。一个办法就是使用抽象法，这是从工程学的思想的角度，也就是通过不断迭代、重构，最终找到问题的解。然而对于这里的Y combinator，接近问题解的过程却显得复杂而费力，甚至过程中的有些点上的思维跳跃有点如羚羊挂角无迹可寻。然而，在这整个Y combinator介绍完了之后我们将会介绍著名的哥德尔不完备性定理，然后我们就会发现，通过哥德尔不完备性定理证明中的一个核心构造式，只需一步自然的推导就能得出我们的Y combinator。而且，最美妙的是，还可以再往下归约，把一切都归约到康托尔当初提出的对角线方法，到那时我们就会发现原来同样如羚羊挂角般的哥德尔的证明其实是对角线方法的一个自然推论。数学竟是如此奇妙，我们由简单得无法再简单的lambda calculus系统的两条公理居然能够导出如此复杂如此令人目眩神迷的Y Combinator，而这些复杂性其实也只是荡漾在定理海洋中的涟漪，拨开复杂性的迷雾我们重又发现它们居然寓于极度的简洁之中。这就是数学之美。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">让我们先来看一看Y combinator的费力而复杂的工程学构造法，我会尽量让这个过程显得自然而流畅<sup>[7]</sup>：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们再次回顾一下那个伪递归的求阶乘函数：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let P =&nbsp;<em>lambda</em>&nbsp;self n. If_Else n==0 1 n*<strong>self</strong>(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们的目标是找出P的不动点power，根据不动点的性质，只要把power传给P，即P(power)，便能够得到真正的递归函数了。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在，关键的地方到了，由于：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">power = P(power) // 不动点原理</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这就意味着，power作为一个函数（lambda calculus里面一切都是函数），它是自己调用了自己的。那么，我们如何实现这样一个能够自己调用自己的power呢？回顾我们当初成功的一次尝试，要实现递归，我们是通过增加一个间接层来进行的：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let power_gen =&nbsp;<em>lambda</em>&nbsp;self. P(<strong>self</strong>(<strong>self</strong>))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">还记得<strong>self</strong>(<strong>self</strong>)这个形式吗？我们在成功实现出求阶乘递归函数的时候不就是这么做的？那么对于现在这个power_gen，怎么递归调用？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">power_gen(power_gen)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">不明白的话可以回顾一下前面我们调用P(P, n)的地方。这里power_gen(power_gen)展开后得到的是什么呢？我们根据刚才power_gen的定义展开看一看，原来是：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>P</strong>(power_gen(power_gen))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">看到了吗？也就是说：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">power_gen(power_gen) =&gt;&nbsp;<strong>P</strong>(power_gen(power_gen))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在，我们把power_gen(power_gen)当成整体看，不妨令为power，就看得更清楚了：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">power =&gt;&nbsp;<strong>P</strong>(power)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这不正是我们要的答案么？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">OK，我们<em>总结一下</em>：对于给定的P，只要构造出一个相应的power_gen如下：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let power_gen =&nbsp;<em>lambda</em>&nbsp;self. P(<strong>self</strong>(<strong>self</strong>))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们就会发现，power_gen(power_gen)这个调用展开后正是P(power_gen(power_gen))。也就是说，我们的power_gen(power_gen)就是我们苦苦寻找的不动点了！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>铸造</strong><strong>Y Combinator</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在我们终于可以铸造我们的Y Combinator了，Y Combinator只要生成一个形如power_gen的lambda函数然后把它应用到自身，就大功告成：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let&nbsp;<strong>Y</strong>&nbsp;=&nbsp;<em>lambda</em>&nbsp;F.</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let&nbsp;<strong><em>f_gen</em></strong>&nbsp;=&nbsp;<em>lambda</em>&nbsp;self. F(<strong>self</strong>(<strong>self</strong>))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return&nbsp;<strong>f_gen</strong>(<strong>f_gen</strong>)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">稍微解释一下，Y是一个lambda函数，它接受一个伪递归F，在内部生成一个f_gen（还记得我们刚才看到的power_gen吧），然后把f_gen应用到它自身（记得power_gen(power_gen)吧），得到的这个f_gen(f_gen)也就是F的不动点了（因为f_gen(f_gen) = F(f_gen(f_gen))），而根据不动点的性质，F的不动点也就是那个对应于F的真正的递归函数！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">如果你还觉得不相信，我们稍微展开一下看看，还是拿阶乘函数说事，首先我们定义阶乘函数的伪递归版本：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let Pwr =&nbsp;<em>lambda</em>&nbsp;self n. If_Else n==0 1 n*self(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">让我们把这个Pwr交给<strong>Y</strong>，看会发生什么（根据刚才Y的定义展开吧）：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Y(Pwr) =&gt;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">let f_gen =&nbsp;<em>lambda</em>&nbsp;self.&nbsp;<strong>Pwr</strong>(self(self))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">return f_gen(f_gen)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Y(Pwr)的求值结果就是里面返回的那个f_gen(f_gen)，我们再根据f_gen的定义展开f_gen(f_gen)，得到：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Pwr(f_gen(f_gen))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">也就是说：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Y(Pwr) =&gt; f_gen(f_gen) =&gt; Pwr(f_gen(f_gen))</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们来看看得到的这个Pwr(f_gen(f_gen))到底是不是真有递归的魔力。我们展开它（注意，因为Pwr需要两个参数，而我们这里只给出了一个，所以Pwr(f_gen(f_gen))得到的是一个单参（即n）的函数）：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Pwr(<strong>f_gen</strong>(<strong>f_gen</strong>)) =&gt; If_Else n==0 1 n*<strong>f_gen</strong>(<strong>f_gen</strong>) (n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">而里面的那个<strong>f_gen</strong>(<strong>f_gen</strong>)，根据f_gen的定义，又会展开为Pwr(f_gen(f_gen))，所以：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>Pwr(f_gen(f_gen))</strong>&nbsp;=&gt; If_Else n==0 1 n*&nbsp;<strong>Pwr(f_gen(f_gen))</strong>&nbsp;(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">看到加粗的部分了吗？因为<strong>Pwr(f_gen(f_gen))</strong>是一个接受n为参数的函数，所以不妨把它令成f（f的参数是n），这样上面的式子就是：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>f</strong>&nbsp;=&gt; If_Else n==0 1 n*<strong>f</strong>(n-1)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">完美的阶乘函数！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>哥德尔的不完备性定理</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><em>了解哥德尔不完备性定理的可以跳到下一节，</em><em>&ldquo;</em><em>大道至简</em><em>&mdash;&mdash;</em><em>康托尔的天才</em><em>&rdquo;</em></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">然而，漫长的Y Combinator征途仍然并非本文的最终目的，对于Y combinator的构造和解释，只是给不了解lambda calculus或Y combinator的读者看的。关键是马上你会看到Y combinator可以由哥德尔不完备性定理证明的一个核心构造式一眼瞧出来！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">让我们的思绪回到1931年，那个数学界风起云涌的年代，一个名不经传的20出头的学生，在他的博士论文中证明了一个惊天动地的结论。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">在那个年代，希尔伯特的数学天才就像太阳的光芒一般夺目，在关于数学严格化的大纷争中希尔伯特带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持。希尔伯特希望借助于形式化的手段，抽掉数学证明中的意义，把数学证明抽象成一堆无意义的符号转换，就连我们人类赖以自豪的逻辑推导，也不过只是一堆堆符号转换而已（想起lambda calculus系统了吧：）)。这样一来，一个我们日常所谓的，带有直观意义和解释的数学系统就变成了一个纯粹由无意义符号表达的、公理加上推导规则所构成的形式系统，而数学证明呢，只不过是在这个系统内玩的一个文字游戏。令人惊讶的是，这样一种做法，真的是可行的！数学的意义，似乎竟然真的可以被抽掉！另一方面，一个形式系统具有非常好的性质，平时人们证明一个定理所动用的推导，变成了纯粹机械的符号变换。希尔伯特希望能够证明，在任一个无矛盾的形式系统中所能表达的所有陈述都要么能够证明要么能够证伪。这看起来是个非常直观的结论，因为一个结论要么是真要么是假，而它在它所处的领域/系统中当然应该能够证明或证伪了（只要我们能够揭示出该系统中足够多的真理）。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">然而，哥德尔的证明无情的击碎了这一企图，哥德尔的证明揭示出，任何足够强到蕴含了皮亚诺算术系统（PA）的一致（即无矛盾）的系统都是不完备的，所谓不完备也就是说在系统内存在一个为真但无法在系统内推导出的命题。这在当时的数学界揭起了轩然大波，其证明不仅具有数学意义，而且蕴含了深刻的哲学意义。从那时起这一不完备性定理就被引申到自然科学乃至人文科学的各个角落&hellip;至今还没有任何一个数学定理居然能够产生这么广泛而深远的影响。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">哥德尔的证明非常的长，达到了200多页纸，但其中很大的成分是用在了一些辅助性的工作上面，比如占据超过1/3纸张的是关于一个形式系统如何映射到自然数，也就是说，如何把一个形式系统中的所有公式都表示为自然数，并可以从一自然数反过来得出相应的公式。这其实就是编码，在我们现在看来是很显然的，因为一个程序就可以被编码成二进制数，反过来也可以解码。但是在当时这是一个全新的思想，也是最关键的辅助性工作之一，另一方面，这正是&ldquo;程序即数据&rdquo;的最初想法。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在我们知道，要证明哥德尔的不完备性定理，只需在假定的形式系统T内表达出一个为真但无法在T内推导出（证明）的命题。于是哥德尔构造了这样一个命题，用自然语言表达就是：命题P说的是&ldquo;<em>P</em><em>不可在系统</em><em>T</em><em>内证明</em>&rdquo;（这里的系统T当然就是我们的命题P所处的形式系统了），也就是说&ldquo;<em>我不可以被证明</em>&rdquo;，跟著名的说谎者悖论非常相似，只是把&ldquo;说谎&rdquo;改成了&ldquo;不可以被证明&rdquo;。我们注意到，一旦这个命题能够在T内表达出来，我们就可以得出&ldquo;P为真但无法在T内推导出来&rdquo;的结论，从而证明T的不完备性。为什么呢？我们假设T可以证明出P，而因为P说的就是P不可在系统T内证明，于是我们又得到T无法证明出P，矛盾产生，说明我们的假设&ldquo;T可以证明P&rdquo;是错误的，根据排中律，我们得到T不可以证明P，而由于P说的正是&ldquo;T不可证明P&rdquo;，所以P就成了一个正确的命题，同时无法由T内证明！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">如果你足够敏锐，你会发现上面这番推理本身不就是证明吗？其证明的结果不就是P是正确的？然而实际上这番证明是位于T系统之外的，它用到了一个关于T系统的假设&ldquo;T是一致（无矛盾）的&rdquo;，这个假设并非T系统里面的内容，所以我们刚才其实是在T系统<em>之外</em>推导出了P是正确的，这跟P不能在T<em>之</em><em>内</em>推导出来并不矛盾。所以别担心，一切都正常。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">那么，剩下来最关键的问题就是如何用形式语言在T内表达出这个P，上面的理论虽然漂亮，但若是P根本没法在T内表达出来，我们又如何能证明&ldquo;T内存在这个为真但无法被证明的P&rdquo;呢？那一切还不是白搭？</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">于是，就有了哥德尔证明里面最核心的构造，哥德尔构造了这样一个公式：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>N(n) is unprovable in T</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个公式由两部分构成，n是这个公式的自由变量，它是一个自然数，一旦给定，那么这个公式就变成一个明确的命题。而N则是从n解码出的货真价实的（即我们常见的符号形式的）公式（记得哥德尔的证明第一部分就是把公式编码吗？）。&rdquo;is unprovable in T&rdquo;则是一个谓词，这里我们没有用形式语言而是用自然语言表达出来的，但哥德尔证明了它是可以用形式语言表达出来的，大致思路就是：一个形式系统中的符号数目是有限的，它们构成这个形式系统的符号表。于是，我们可以依次枚举出所有长度为1的串，长度为2的串，长度为3的串&hellip; 此外根据形式系统给出的语法规则，我们可以检查每个串是否是良构的公式（well formed formula，简称wff，其实也就是说，是否符合语法规则，前面我们在介绍lambda calculus的时候看到了，一个形式系统是需要语法规则的，比如逻辑语言形式化之后我们就会看到P-&gt;Q是一个wff，而-&gt;PQ则不是），因而我们就可以枚举出所有的wff来。最关键的是，我们观察到形式系统中的证明也不过就是由一个个的wff构成的序列（想想推导的过程，不就是一个公式接一个公式嘛）。而wff构成的序列本身同样也是由符号表内的符号构成的串。所以我们只需枚举所有的串，对每一个串检查它是否是一个由wff构成的序列（证明），如果是，则记录下这个wff序列（证明）的最后一个wff，也就是它的结论。这样我们便枚举出了所有的可由T推导出的定理。然后为了表达出&rdquo;X is unprovable in T&rdquo;，本质上我们只需说&ldquo;不存在这样一个自然数S，它所解码出来的wff序列以X为终结&rdquo;！这也就是说，我们表达出了&ldquo;is unprovable in T&rdquo;这个谓词。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们用UnPr(X)来表达&ldquo;X is unprovable in T&rdquo;，于是哥德尔的公式变成了：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">UnPr( N(n) )</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在，到了最关键的部分，首先我们把这个公式简记为G(n)&mdash;&mdash;别忘了G内有一个自由变量n，所以G现在还不是一个命题，而只是一个公式，所以谈不上真假：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">G(n): UnPr( N(n) )</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">又由于G也是个wff，所以它也有自己的编码g，当然g是一个自然数，现在我们把g作为G的参数，也就是说，把G里面的自由变量n替换为g，我们于是得到一个真正的命题：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">G(g): UnPr( G(g) )</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">用自然语言来说，这个命题G(g)说的就是&ldquo;<em>我是不可在</em><em>T</em><em>内证明的</em>&rdquo;。看，我们在形式系统T内表达出了&ldquo;我是不可在T内证明的&rdquo;这个命题。而我们一开始已经讲过了如何用这个命题来推断出G(g)为真但无法在T内证明，于是这就证明了哥德尔的不完备性定理<sup>[8]</sup>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">哥德尔的不完备性定理被称为20世纪数学最重大的发现（不知道有没有&ldquo;之一&rdquo;:) ）现在我们知道为真但无法在系统内证明的命题不仅仅是这个诡异的&ldquo;哥德尔命题&rdquo;，还有很多真正有意义的明确命题，其中最著名的就是<a style="color: #313428" href="http://en.wikipedia.org/wiki/Continuum_hypothesis">连续统假设</a>，此外哥德巴赫猜想也有可能是个没法在数论系统中证明的真命题。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>从哥德尔公式到</strong><strong>Y Combinator</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">哥德尔的不完备性定理证明了数学是一个未完结的学科，永远有需要我们以人的头脑从系统之外去用我们独有的直觉发现的东西。罗杰&middot;彭罗斯在<a style="color: #313428" href="http://www.amazon.com/Emperors-New-Mind-Roger-Penrose/dp/0140145346">《The Emperor&rsquo;s New Mind》</a>中用它来证明人工智能的不可实现。当然，这个结论是很受质疑的。但哥德尔的不完备性定理的确还有很多很多的有趣推论，数学的和哲学上的。哥德尔的不完备性定理最深刻的地方就是它揭示了自指（或称自引用，递归调用自身等等）结构的普遍存在性，我们再来看一看哥德尔命题的绝妙构造：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">G(n): UnPr( N(n) )</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们注意到，这里的UnPr其实是一个形式化的谓词，它不一定要说&ldquo;X在T内可证明&rdquo;，我们可以把它泛化为一个一般化的谓词，P：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>G(n): P( N(n) )</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">也就是说，对于任意一个单参的谓词P，都存在上面这个哥德尔公式。然后我们算出这个哥德尔公式的自然数编码g，然后把它扔给G，就得到：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">G(g): P( G(g) )</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">是不是很熟悉这个结构？我们的Y Combinator的构造不就是这样一个形式？我们把G和P都看成一元函数，G(g)可不正是P这个函数的不动点么！于是，<strong>我们从哥德尔的证明里面直接看到了</strong><strong>Y Combinator</strong>！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">至于如何从哥德尔的证明联系到停机问题，就留给你去解决吧:) 因为更重要的还在后面，我们看到，哥德尔的证明虽然巧妙至极，然而其背后的思维过程仍然飘逸而不可捉摸，至少我当时看到G(n)的时候，&ldquo;乃大惊&rdquo;&ldquo;不知所从出&rdquo;，他怎么想到的？难道是某一个瞬间&ldquo;灵光一现&rdquo;？一般我是不信这一说的，已经有越来越多的科学研究表明一瞬间的&ldquo;灵感&rdquo;往往是潜意识乃至表层意识长期思考的结果。哥德尔天才的证明也不例外，我们马上就会看到，在这个神秘的构造背后，其实隐藏着某种更深的东西，这就是康托尔在19世纪80年代研究无穷集合和超限数时引入的对角线方法。这个方法仿佛有种神奇的力量，能够揭示出某种自指的结构来，而同时，这又是一个极度简单的手法，通过它我们能够得到数学里面一些非常奇妙的性质。无论是哥德尔的不完备性定理还是再后来丘齐建立的lambda calculus，抑或我们非常熟悉的图灵机理论里的停机问题，其实都只是这个手法简单推演的结果！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>大道至简</strong><strong>&mdash;&mdash;</strong><strong>康托尔的天才</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&ldquo;大道至简&rdquo;这个名词或许更多出现在文学和哲学里面，一般用在一些模模糊糊玄玄乎乎的哲学观点上。然而，用在这里，数学上，这个名词才终于适得其所。大道至简，看上去最复杂的理论其实建立在一个最简单最纯粹的道理之上。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">康托尔在无穷集合和超限数方面的工作主要集中在两篇突破性的论文上，这也是我所见过的最纯粹最美妙的数学论文，现代的数学理论充斥了太多复杂的符号和概念，很多时候让人看不到最本质的东西，当然，不否认这些东西很多也是有用的，然而，要领悟真正的数学美，像集合论和数论这种纯粹的东西，真的非常适合。不过这里就不过多谈论数学的细节了，只说康托尔引入对角线方法的动机和什么是对角线方法。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>神奇的一一对应</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">康托尔在研究无穷集合的时候，富有洞察性地看到了对于无穷集合的大小问题，我们不能再使用直观的&ldquo;所含元素的个数&rdquo;来描述，于是他创造性地将一一对应引入进来，两个无穷集合&ldquo;大小&rdquo;一样当且仅当它们的元素之间能够构成一一对应。这是一个非常直观的概念，一一对应嘛，当然个数相等了，是不是呢？然而这同时就是它不直观的地方了。对于无穷集合，我们日常的所谓&ldquo;个数&rdquo;的概念不管用了，因为无穷集合里面的元素个数本就是无穷多个。不信我们来看一个小小的例子。我们说自然数集合能够跟偶数集合构成一一对应，从而<em>自然数集合跟偶数集合里面元素</em><em>&ldquo;</em><em>个数</em><em>&rdquo;</em><em>是一样多的</em>。怎么可能？偶数集合是自然数集合的真子集，所有偶数都是自然数，但自然数里面还包含奇数呢，说起来应该是二倍的关系不是？不是！我们只要这样来构造一一对应：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">1 2 3 4 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">2 4 6 8 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">用函数来描述就是 f(n) = 2n。检验一下是不是一一对应的？不可思议对吗？还有更不可思议的，<em>自然数集是跟有理数集一一对应的</em>！对应函数的构造就留给你解决吧，提示，按如下方式来挨个数所有的有理数：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">1/1 1/2 2/1 1/3 2/2 3/1 1/4 2/3 3/2 4/1 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">用这种一一对应的手法还可以得到很多惊人的结论，如<em>一条直线上所有的点跟一个平面上所有的点构成一一对应</em>（也就是说<em>复数集合跟实数集合构成一一对应</em>）。以致于连康托尔自己都不敢相信自己的眼睛了，这也就是为什么他在给戴得金的信中会说&ldquo;我看到了它，却不敢相信它&rdquo;的原因。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">然而，除了一一对应之外，还有没有不能构成一一对应的两个无穷集合呢？有。<em>实数集合就比自然数集合要</em><em>&ldquo;</em><em>大</em><em>&rdquo;</em>，它们之间实际上无法构成一一对应。这就是康托尔的对角线方法要解决的问题。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>实数集和自然数集无法构成一一对应？！</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们只需将实数的小数位展开，并且我们假设实数集能够与自然数集一一对应，也就是说假设实数集<a style="color: #313428" href="http://en.wikipedia.org/wiki/Countable">可列</a>，所以我们把它们与自然数一一对应列出，如下：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">1 a<sub>10</sub>.a<sub>11</sub>a<sub>12</sub>a<sub>13</sub>&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">2 a<sub>20</sub>.a<sub>21</sub>a<sub>22</sub>a<sub>23</sub>&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">3 a<sub>30</sub>.a<sub>31</sub>a<sub>32</sub>a<sub>33</sub>&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">4 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">5 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">（注：aij里面的ij是下标）</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">现在，我们构造一个新的实数，它的第i位小数不等于aii。也就是说，它跟上面列出的每一个实数都至少有一个对应的小数位不等，也就是说它不等于我们上面列出的所有实数，这跟我们上面假设已经列出了所有实数的说法相矛盾。所以实数集只能是不可列的，即不可与自然数集一一对应！这是对角线方法的最简单应用。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>对角线方法</strong><strong>&mdash;&mdash;</strong><strong>停机问题的深刻含义</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">对角线方法有很多非常奇妙的结论。其中之一就是文章一开始提到的停机问题。我想绝大多数人刚接触停机问题的时候都有一个问题，图灵怎么能够想到这么诡异的证明，怎么能构造出那个诡异的&ldquo;说停机又不停机，说不停机又停机&rdquo;的悖论机器。马上我们就会看到，这其实只是对角线方法的一个直接结论。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">还是从反证开始，我们假设存在这样一个图灵机，他能够判断任何程序在任何输入上是否停机。由于所有图灵机构成的集合是一个可列集（也就是说，我们可以逐一列出所有的图灵机，严格证明见我以前的一篇文章《<a style="color: #313428" href="http://blog.csdn.net/pongba/archive/2006/03/11/621723.aspx">图灵机杂思</a>》），所以我们可以很自然地列出下表，它表示每个图灵机分别在每一个可能的输入（1,2,3,&hellip;）下的输出，N表示无法停机，其余数值则表示停机后的输出：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp; 2&nbsp; 3&nbsp; 4 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">M1&nbsp; N&nbsp; 1&nbsp; N&nbsp; N &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">M2&nbsp; 2&nbsp; 0&nbsp; N&nbsp; 0 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">M3&nbsp; 0&nbsp; 1&nbsp; 2&nbsp; 0 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">M4&nbsp; N&nbsp; 0&nbsp; 5&nbsp; N &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">M1，M2，M3 &hellip; 是逐一列出的图灵机，并且，注意，由于程序即数据，每个图灵机都有唯一编码，所以我们规定在枚举图灵机的时候Mi其实就代表编码为i的图灵机，当然这里很多图灵机将会是根本没用的玩意，但这不要紧。此外，最上面的一行1 2 3 4 &hellip; 是输入数据，如，矩阵的第一行代表M1分别在1，2，3，&hellip;上面的输出，不停机的话就是N。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们刚才假设存在这样一个图灵机H，它能够判断任何程序在任何输入上能否停机，换句话说，H(i,j)（i是Mi的编码）能够给出&ldquo;Mi(j)&rdquo;是N（不停）呢还是给出一个具体的结果（停）。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们现在来运用康托尔的对角线方法，我们构造一个新的图灵机P，P在1上的输出行为跟M1(1)&ldquo;不一样&rdquo;，在2上的输出行为跟M2(2)&ldquo;不一样&rdquo;，&hellip;总之P在输入i上的输出跟Mi(i)不一样。只需利用一下我们万能的H，这个图灵机P就不难构造出来，如下：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">P(i):</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">if(&nbsp;<strong>H</strong>(i, i) == 1 ) then // Mi(i) halts</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp; return 1 + Mi(i)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">else // if H(i, i) == 0 (Mi(i) doesn&rsquo;t halt)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp; return 0</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">也就是说，如果Mi(i)停机，那么P(i)的输出就是Mi(i)+1，如果Mi(i)不停机的话，P(i)就停机且输出0。这就保证了P(i)的输出行为跟Mi(i)反正不一样。现在，我们注意到P本身是一个图灵机，而我们上面已经列出了所有的图灵机，所以必然存在一个k，使得Mk = P。而两个图灵机相等当且仅当它们对于所有的输入都相等，也就是说对于任取的n，有Mk(n) = P(n)，现在令n=k，得到Mk(k)=P(k)，根据上面给出的P的定义，这实际上就是：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">Mk(k) = P(k) =</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp; 1+Mk(k) if Mk(k) halts</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp; 0 if Mk(k) doesn&rsquo;t halt</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">看到这个式子里蕴含的矛盾了吗？如果Mk(k)停机，那么Mk(k)=1+Mk(k)；如果Mk(k)不停机，则Mk(k)=0（给出结果0即意味着Mk(k)停机）；不管哪种情况都是矛盾。于是我们得出，不存在那样的H。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个对角线方法实际上说明了，无论多聪明的H，总存在一个图灵机的停机行为是它无法判断的。这跟哥德尔定理&ldquo;无论多&lsquo;完备&rsquo;的形式化公理系统，都存在一个&lsquo;哥德尔命题&rsquo;是无法在系统内推导出来的&rdquo;从本质上其实是一模一样的。只不过我们一般把图灵的停机问题称为&ldquo;可判定问题&rdquo;，而把数学的称为&ldquo;可证明问题&rdquo;。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">等等！如果我们把那个无法判定是否停机的图灵机作为算法的特例纳入到我们的H当中呢？我们把得到的新的判定算法记为H<sub>1</sub>。然而，可惜的是，在H<sub>1</sub>下，我们又可以相应地以同样的手法从H<sub>1</sub>构造出一个无法被它（H<sub>1</sub>）判定的图灵机来。你再加，我再构造，无论你加多少个特例进去，我都可以由同样的方式构造出来一个你无法够到的图灵机，以彼之矛，攻彼之盾。其实这也是哥德尔定理最深刻的结论之一，哥德尔定理其实就说明了无论你给出多少个公理，即无论你建立多么完备的公理体系，这个系统里面都有由你的那些公理出发所推导不到的地方，这些黑暗的角落，就是人类直觉之光才能照射到的地方！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">本节我们从对角线方法证明了图灵的停机问题，我们看到，对角线方法能够揭示出某种自指结构，从而构造出一个&ldquo;悖论图灵机&rdquo;。实际上，对角线方法是一种有深远影响的方法，哥德尔的证明其实也是这个方法的一则应用。证明与上面的停机问题证明如出一辙，只不过把Mi换成了一个形式系统内的公式fi，具体的证明就留给聪明的你吧:)我们现在来简单的看一下这个奇妙方法的几个不那么明显的推论。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>罗素悖论</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">学过逻辑的人大约肯定是知道著名的罗素悖论的，罗素悖论用数学的形式来描述就是：</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">R = &#123;X:X不属于X&#125;;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个悖论最初是从康托尔的无穷集合论里面引申出来的。当初康托尔在思考无穷集合的时候发现可以称&ldquo;一切集合的集合&rdquo;，这样一个集合由于它本身也是一个集合，所以它就属于它自身。也就是说，我们现在可以称世界上存在一类属于自己的集合，除此之外当然就是不属于自己的集合了。而我们把所有不属于自己的集合收集起来做成一个集合R，这就是上面这个著名的罗素悖论了。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们来看R是否属于R，如果R属于R，根据R的定义，R就不应该属于R。而如果R不属于R，则再次根据R的定义，R就应该属于R。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这个悖论促使了集合论的公理化。后来策梅罗公理化的集合论里面就不允许X属于X（不过可惜的是，尽管如此还是没法证明这样的集合论不可能产生出新的悖论。而且永远没法证明&mdash;&mdash;这就是哥德尔第二不完备性定理的结论&mdash;&mdash;一个包含了PA的形式化公理系统永远无法在内部证明其自身的一致（无矛盾）性。从而希尔伯特想从元数学推出所有数学系统的一致性的企图也就失败了，因为元数学的一致性又得由元元数学来证明，后者的一致性又得由元元元数学来证明&hellip;）。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">这里我们只关心罗素是如何想出这个绝妙的悖论的。还是对角线方法！我们罗列出所有的集合，S1,S2,S3 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S1&nbsp; S2&nbsp; S3 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">S1&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">S2&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 0 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">S3&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; 0 &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">&hellip; &hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">右侧纵向列出所有集合，顶行横向列出所有集合。0/1矩阵的(i,j)处的元素表示Si是否包含Sj，记为Si(j)。现在我们只需构造一个新的0/1序列L，它的第i位与矩阵的(i,i)处的值恰恰相反：L(i) = 1-Si(i)。我们看到，这个新的序列其实对应了一个集合，不妨也记为L，L(i)表示L是否包含Si。根据L的定义，如果矩阵的(i,i)处值为0（也就是说，如果Si不包含Si），那么L这个集合就包含Si,否则就不包含。我们注意到这个新的集合L肯定等于某个Sk（因为我们已经列出了所有的集合），L = Sk。既然L与Sk是同一集合，那么它们肯定包含同样的元素，从而对于任意n，有L(n) = Sk(n)。于是通过令n=k，得到L(k) = Sk(k)，而根据L的定义，L(k) = 1- Sk(k)。这就有Sk(k) = 1-Sk(k)，矛盾。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">通过抽象简化以上过程，我们看到，我们构造的L其实是&ldquo;包含了所有不包含它自身的集合的集合&rdquo;，用数学的描述正是罗素悖论！</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">敏锐的你可能会注意到所有集合的数目是不可数的从而根本不能S1,S2&hellip;的一一列举出来。没错，但通过假设它们可以列举出来，我们发现了一个与可列性无关的悖论。所以这里的对角线方法其实可以说是一种启发式方法。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">同样的手法也可以用到证明P(A)（A的所有子集构成的集合，也叫幂集）无法跟A构成一一对应上面。证明就留给聪明的你了:)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>希尔伯特第十问题结出的硕果</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">希尔伯特是在1900年巴黎数学家大会上提出著名的希尔伯特第十问题的，简言之就是<em>是否存在一个算法，能够计算任意</em><em><a style="color: #313428" href="http://en.wikipedia.org/wiki/Diophantine_equation">丢番图方程</a></em><em>是否有整根</em>。要解决这个问题，就得先严格定义&ldquo;算法&rdquo;这一概念。为此图灵和丘齐分别提出了图灵机和lambda calculus这两个概念，它们从不同的角度抽象出了&ldquo;有效（机械）计算&rdquo;的概念，著名的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Church-Turing_thesis">图灵&mdash;&mdash;丘齐命题</a>就是说<em>所有可以有效计算出来的问题都可以由图灵机计算出来</em>。实际上我们已经看到，丘齐的lambda calculus其实就是数学推理系统的一个形式化。而图灵机则是把这个数学概念物理化了。而也正因为图灵机的概念隐含了实际的物理实现，所以冯&middot;诺依曼才据此提出了奠定现代计算机体系结构的<a style="color: #313428" href="http://en.wikipedia.org/wiki/Von_Neumann_architecture">冯&middot;诺依曼体系结构</a>，其遵循的，正是图灵机的概念。而&ldquo;程序即数据&rdquo;的理念，这个发端于数学家哥德尔的不完备性定理的证明之中的理念，则早就在黑暗中预示了可编程机器的必然问世。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>对角线方法</strong><strong>&mdash;&mdash;</strong><strong>回顾</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">我们看到了对角线方法是如何简洁而深刻地揭示出自指或递归结构的。我们看到了著名的不完备性定理、停机问题、Y Combinator、罗素悖论等等等等如何通过这一简洁优美的方法推导出来。这一诞生于康托尔的天才的手法如同一条金色的丝线，把位于不同年代的伟大发现串联了起来，并且将一直延续下去&hellip;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">P.S</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">1. lambda calculus里面的&ldquo;停机问题&rdquo;</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">实际上lambda calculus里面也是有&ldquo;停机问题&rdquo;的等价版本的。其描述就是：不存在一个算法能够判定任意两个lambda函数是否等价。所谓等价当然是对于所有的n,有f(n)=g(n)了。这个问题的证明更加能够体现对角线方法的运用。仍然留给你吧。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">2.&nbsp;<a style="color: #313428" href="http://blog.csdn.net/g9yuayon">负喧琐话</a>(<a style="color: #313428" href="http://blog.csdn.net/g9yuayon">http://blog.csdn.net/g9yuayon</a>)是个非常不错的blog:)。g9的文字轻松幽默，而且有很多名人八卦可以养眼，真的灰常&hellip;灰常&hellip;不错哦。此外g9老兄还是个理论功底非常扎实的牛。所以，anyway，看了他的blog就知道啦！最初这篇文章的动机也正是看了上面的一篇<a style="color: #313428" href="http://blog.csdn.net/g9yuayon/archive/2006/09/24/1271319.aspx">关于Y Combinator的铸造过程的介绍</a>，于是想揭示一些更深的东西，于是便有了本文。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">3. 文章起名《康托尔、哥德尔、图灵&mdash;&mdash;永恒的金色对角线》其实是为了纪念看过的一本好书GEB，即《Godel、Escher、Bach-An Eternal Golden Braid》中文译名《哥德尔、埃舍尔、巴赫&mdash;&mdash;集异璧之大成》&mdash;&mdash;商务印书馆出版。对于一本定价50元居然能够在douban上卖到100元的二手旧书，我想无需多说。另，幸福的是，电子版可以找到:)</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">4. 其实很久前想写的是一篇《从哥德尔到图灵》，但那篇写到1/3不到就搁下了，一是由于事务，二是总觉得少点什么。呵呵，如今把康托尔扯进来，也算是完成当时扔掉的那一篇吧。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">5. 这恐怕算是写得最曲折的一篇文章了。不仅自己被这些问题搞得有点晕头转向（还好总算走出来），更因为要把这些东西自然而然的串起来，也颇费周章。很多时候是利用吃饭睡觉前或走路的时间思考本质的问题以及如何表达等等，然后到纸上一气呵成。不过同时也锻炼了不拿纸笔思考数学的能力，呵呵。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">6. 关于图灵的停机问题、Y Combinator、哥德尔的不完备性定理以及其它种种与康托尔的对角线之间的本质联系，几乎查不到完整系统的深入介绍，一些书甚至如《The Emperor&rsquo;s New Mind》也只是介绍了与图灵停机问题之间的联系（已经非常的难得了），google和baidu的结果也是基本没有头绪。很多地方都是一带而过让人干着急。所以看到很多地方介绍这些定理和构造的时候都是弄得人晕头转向的，绝大部分人在面对如Y Combinator、不完备性定理、停机问题的时候都把注意力放在力图理解它是怎么运作的上面了，却使人看不到其本质上从何而来，于是人们便对这些东东大为惊叹。这使我感到很不痛快，如隔靴搔痒般。这也是写这篇文章的主要动机之一。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px"><strong>Reference</strong></p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[1] 《数学&mdash;&mdash;确定性的丧失》</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[2] 也有观点认为函数式编程语言之所以没有广泛流行起来是因为一些实际的商业因素。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[3] Douglas R.Hofstadter的著作《Godel, Escher, Bach: An Eternal Golden Braid》（《哥德尔、艾舍尔、巴赫&mdash;&mdash;集异璧之大成》）就是围绕这一思想写出的一本奇书。非常建议一读。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[4] 《数学&mdash;&mdash;确定性的丧失》</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[5] 虽然我觉得那个系徽做得太复杂，要表达这一简洁优美的思想其实还能有更好的方式。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[6] 关于如何在lambda calculus系统里实现&ldquo;+&rdquo;操作符以及自然数等等，可参见<a style="color: #313428" href="http://blog.csdn.net/g9yuayon/archive/2006/05/29/759778.aspx">这里</a>，<a style="color: #313428" href="http://blog.csdn.net/g9yuayon/archive/2006/06/12/790953.aspx">这里</a>，和<a style="color: #313428" href="http://blog.csdn.net/g9yuayon/archive/2006/08/14/1062514.aspx">这里</a>。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[7] g9的blog（负暄琐话）<a style="color: #313428" href="http://blog.csdn.net/g9yuayon/">http://blog.csdn.net/g9yuayon/</a>&nbsp;上有一系列介绍lambda calculus的文章（当然，还有其它好文章:)），非常不错，强烈推荐。最近的两篇就是介绍Y combinator的。其中有一篇以javaScript语言描述了迭代式逐步抽象出Y Combinator的过程。</p><p style="line-height: 21px; margin: 0px 0px 1.25em; padding: 0px; color: #333333; font-family: 'Lucida Grande', Arial, Helvetica, sans-serif; font-size: 14px">[8] 实际上这只是第一不完备性定理，它还有一个推论，被称为第二不完备性定理，说的是任一个系统T内无法证明这个系统本身的一致性。这个定理的证明核心思想如下：我们前面证明第一不完备性定理的时候用的推断其实就表明 Con/T -&gt; G(g) （自然语言描述就是，由系统T的无矛盾，可以推出G(g)成立），而这个&ldquo;Con/T -&gt; G(g)&rdquo;本身又是可以在T内表达且证明出来的（具体怎么表达就不再多说了）&mdash;&mdash;只需要用排中律即可。于是我们立即得到，T里面无法推出Con/T，因为一旦推出Con/T就立即推出G(g)从而推出UnPr(G(g))，这就矛盾了。所以，Con/T无法在T内推出（证明）。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7521</link>
<title><![CDATA[lambda演算与函数式编程 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[编译原理]]></category>
<pubDate>Wed, 31 Aug 2016 15:26:28 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7521</guid> 
<description>
<![CDATA[ 
	<span style="font-size: 14px; line-height: 21px; font-family: simsun; color: #494949; background-color: #eb735a">前几天开始看&lt;程序设计语言概念&gt;（&nbsp;</span><a style="text-decoration: none; color: #99481f; font-family: simsun; font-size: 14px; line-height: 21px; background-color: #eb735a" href="http://www.amazon.com/exec/obidos/ASIN/0521780985/qid=1129186290/sr=11-1/ref=sr_11_1/103-3929732-9947012" target="_blank"><strong>Concepts in Programming Languages</strong></a><span style="font-size: 14px; line-height: 21px; font-family: simsun; color: #494949; background-color: #eb735a">&nbsp;），里面一开始就讲了计算系统，但不是图灵机，而是&lambda;演算。以前看SICP的时候有一题Church计数，既在&lambda;演算中，计算系统用函数的嵌套次数来计数（以及对应的scheme定义）：</span><br /><table border="0" cellspacing="1" cellpadding="1" style="margin: 0px; padding: 0px; color: #494949; font-family: simsun; font-size: 14px; background-color: #eb735a"><tbody><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px"><table border="0" cellspacing="1" cellpadding="1" style="margin: 0px; padding: 0px"><tbody><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small"><strong>0</strong>&nbsp;&equiv;&nbsp;&lambda;f.&lambda;x. x</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">(define&nbsp;zero&nbsp;(lambda&nbsp;(f) (lambda&nbsp;(x)&nbsp;x)))</span></td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small"><strong>1</strong>&nbsp;&equiv;&nbsp;&lambda;f.&lambda;x. f x</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">(define one (lambda (f) (lambda (x) (f x))))</span></td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small"><strong>2</strong>&nbsp;&equiv;&nbsp;&lambda;f.&lambda;x. f (f x)</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">(define two (lambda (f) (lambda (x) ( f (f x)))))</span></td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small"><strong>3</strong>&nbsp;&equiv;&nbsp;&lambda;f.&lambda;x. f (f (f x))</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">(define three (lambda (f) (lambda (x) (f (f (f x))))))</span></td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">...</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">...<br /></span></td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small"><strong>n</strong>&nbsp;&equiv;&nbsp;&lambda;f.&lambda;x. f<sup><em>n</em></sup>&nbsp;x</span></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px; color: #787878"><span style="word-wrap: normal; word-break: normal; line-height: 19.5px; font-size: x-small">...</span></td></tr></tbody></table><br />&nbsp;&nbsp;虽然计数看懂了，但是scheme的实现到现在还是没想通。。有人说对计数的lambda表达式人肉展开，我没展成功- -<br />&nbsp;&nbsp;也就是从那时候起，知道函数式编程的理论基础是&lambda;演算。正好这本书有专门的章节，在恶补了两天之后，终于知道了些皮毛。。。<br />&nbsp;<br />&nbsp;&nbsp;所谓&lambda;演算，是一套用于研究函数定义，函数应用和递归的形式系统。它包括一条变换规则（变量替换）和一条函数定义方式，Lambda演算之通用在于，任何一个可计算函数都能用这种形式来表达和求值。因而，它是等价于<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" title="图灵机">图灵机</a>的。尽管如此，Lambda演算强调的是变换规则的运用，而非实现它们的具体机器。可以认为这是一种更接近软件而 非硬件的方式。<br />&nbsp;&nbsp;（书上多次提到Lambda演算的计算能力已被证明等价于图灵机，就冲这点，我势必要把FP学好。。。）<br />&nbsp;&nbsp;对于Lambda演算的描述，wiki的非形式化定义：<br /><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">在lambda演算中，每个表达式都代表一个只有单独参数的函数，这个函数的参数本身也是一个只有单一参数的函数，同时，函数的值是又一个只有单一 参数的函数。函数是通过lambda表达式匿名地定义的，这个表达式说明了此函数将对其参数进行什么操作。例如，&ldquo;加2&rdquo;函数f(x)= x + 2可以用lambda演算表示为&lambda;x.x + 2(&lambda;y.y + 2也是一样的，参数的取名无关紧要)而f(3)的值可以写作(&lambda;x.x + 2) 3。函数的作用（application）是<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/w/index.php?title=%E5%B7%A6%E7%BB%93%E5%90%88&amp;action=edit&amp;redlink=1" title="左结合">左结合</a>的：f x y =(f x) y。考虑这么一个函数：它把一个函数作为参数，这个函数将被作用在3上：&lambda;f.f 3。如果把这个（用函数作参数的）函数作用于我们先前的&ldquo;加2&rdquo;函数上：(&lambda;f.f 3)(&lambda;x.x+2)，则明显地，下述三个表达式：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none; color: #787878"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(&lambda;f.f 3)(&lambda;x.x+2)与 (&lambda;x.x + 2) 3与3 + 2</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">是等价的。有两个参数的函数可以通过lambda演算这么表达：一个单一参数的函数的返回值又是一个单一参数的函数（参见<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/wiki/Currying" title="Currying">Currying</a>）。例如，函数f(x, y) = x - y可以写作&lambda;x.&lambda;y.x - y。下述三个表达式：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none; color: #787878"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(&lambda;x.&lambda;y.x - y) 7 2与 (&lambda;y.7 - y) 2与7 - 2</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">也是等价的。然而这种lambda表达式之间的等价性无法找到一个通用的函数来判定。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">并非所有的lambda表达式都可以规约至上述那样的确定值，考虑</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none; color: #787878"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(&lambda;x.x x)(&lambda;x.x x)</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">或</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none; color: #787878"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(&lambda;x.x x x)(&lambda;x.x x x)</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">然后试图把第一个函数作用在它的参数上。 (&lambda;x.x x)被称为&omega;&nbsp;<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91" title="组合子逻辑">组合子</a>，((&lambda;x.x x)(&lambda;x.x x))被称为&Omega;，而((&lambda;x.x x x) (&lambda;x.x x x))被称为&Omega;<sub>2</sub>，以此类推。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">若仅形式化函数作用的概念而不允许lambda表达式，就得到了<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91" title="组合子逻辑">组合子逻辑</a>。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">&nbsp;&nbsp;形式化定义用巴科斯文法描述，我看不懂- -</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">&nbsp;&nbsp;Lambda演算中有几个重要的法则，我的理解，它们分别成为了FP几个特性的理论基础：</p><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none"><span style="word-wrap: normal; word-break: normal; line-height: 21.0599994659424px">1，&alpha;-变换</span></h3><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">Alpha-变换规则表达的是，被绑定变量的名称是不重要的。比如说&lambda;x.x和&lambda;y.y是同一个函数。尽管如此，这条规则并非像它看起来这么简单， 关于被绑定的变量能否由另一个替换有一系列的限制。</p>&nbsp;&nbsp;对应LISP中，函数参数本身的名字对函数没有任何影响，Lambda表达式的定义也很好的说明了这一点。比如以下两个函数是完全等价的。<br />&nbsp;&nbsp;(define (square x) (lambda(x) (* x x)))<br />&nbsp;&nbsp;(define (square y) (lambda(y) (* y y)))<br />&nbsp;&nbsp;另外，alpha变换涉及到变量的自由出现。即被一个函数绑定的变量不能与与另一个函数绑定的变量同时变换。例如&lambda;x.(&lambda;x.x) x这样的表达式将变换为&lambda;y.(&lambda;x.x) y。举个Scheme求平方和的例子~<br />&nbsp;&nbsp;(define (square-sum square x y)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ (square x) (square y)))<br />&nbsp;&nbsp;square函数在上面定义，其中有变量x，求平方和函数自身也有名为x的变量，但两者显然可以各自变换。并且这个例子用到了高阶函数（&beta;-归约和函数的curry化），下面马上说明。<br /><br /><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none"><span style="word-wrap: normal; word-break: normal; line-height: 21.0599994659424px">2，&beta;-归约</span></h3><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">Beta-归约规则表达的是函数作用的概念。它陈述了若所有的E'的自由出现在E [V:=E']中仍然是自由的情况下，有</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none; color: #787878"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">((&lambda;V.E) E') == E [V:=E']</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">成立。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">&nbsp;&nbsp;<span style="word-wrap: normal; word-break: normal; color: #000000">虽然还是巴科斯文法，不过这个大概能看明白。我觉得beta-变换是Lambda演算最重要的部分，也是函数式编程中最重要概念--<span style="word-wrap: normal; word-break: normal; font-weight: bold">高阶函数</span>的理论基础。由于Lambda演算中，函数可以接受的参数既可以是变量，也可以是另一个函数，因此可以对其进行归约，归约到只接受一个变量的函数（Lambda演算中只定义了一元函数）。举几个例子：</span></p><p style="margin: 0cm 0cm 0pt; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; text-indent: 21pt"><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x.</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y x)(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.u)</span></u>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">&reg;</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.u)</span></p><p style="margin: 0cm 0cm 0pt; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; text-indent: 21pt"><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x x)(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.u)</span></u>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">&reg;</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.u) (</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.u)</span></p><p style="margin: 0cm 0cm 0pt; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; text-indent: 21pt"><span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y a)(<u>(</u></span><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x)(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">u.u) z)</span></u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">)</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">&reg;</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y a)(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">u.u) z)</span></p><p style="margin: 0cm 0cm 0pt; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; text-indent: 21pt"><span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y a)((</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x)(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.<u>(</u></span><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">u.u) z</span></u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">))</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">&reg;</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y a)((</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x)(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z. z))</span></p><span style="word-wrap: normal; word-break: normal; font-family: 宋体">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;<u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">y.y a)((</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x)(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.(</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span></u><u><span style="word-wrap: normal; word-break: normal; font-family: 宋体">u.u) z))</span></u>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: symbol">&reg;</span>&nbsp;<span style="word-wrap: normal; word-break: normal; font-family: 宋体">((</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">x. x)(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">z.(</span><span style="word-wrap: normal; word-break: normal; font-family: symbol">l</span><span style="word-wrap: normal; word-break: normal; font-family: 宋体">u.u) z)) a<br /><br />这样的归约计算我到现在还不太适应- -，归约计算的每一步，就是代换，把最右边的函数/变量代入到次右边的参数，同时消去左边相应的</span>&lambda;，直到不能再归约为止。<br />&nbsp;&nbsp;显然，&beta;-归约自身结合Lambda演算的定义就可以自然而然地导出高阶函数的概念。所谓高阶函数，如果一个函数满足：<span style="word-wrap: normal; word-break: normal; color: #787878">1，接受一个或多个函数作为输入；2，输出一个函数。<span style="word-wrap: normal; word-break: normal; color: #000000">那么这就是一个高阶函数。数学中可以举个对应的例子：求导，如果这一过程作为一个函数，那么它就是一个高阶函数。它接受一个函数作为参数，输出了这个函数的导函数。在求平方和的例子中，square-sum接受了求平方函数square，输出了一个求平方和的函数，高阶函数的概念可以在这里体现。<br />&nbsp;&nbsp;另外，Lambda演算中只定义了一元函数，那么多元函数怎么办？<br />&nbsp;&nbsp;为了Lambda系统能更小，Church等人当初只定义了一元函数，并且利用&beta;-归约的定义，将多元函数化为只接受单一参数的函数，这就是<span style="word-wrap: normal; word-break: normal; font-weight: bold">函数的curry化</span>。</span></span><strong>curry化</strong>是把接受多个参数<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/w/index.php?title=%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0&amp;action=edit&amp;redlink=1" title="形式参数"></a>的函数变 换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。显然，curry化本身就是一个高阶函数，也用到了&beta;-归约。那么curry化如何演算呢？很简单<br />&nbsp;&nbsp;&lambda;xy.N ==&gt; &lambda;x.&lambda;y.N<br />&nbsp;&nbsp;这个文法有点抽象~~比如说有三元函数f(x,y,z)，由于只能接受一个参数，所以对它进行curry化：<br />&nbsp;&nbsp;1，接受x，并固定它，返回二元函数g(y,z)；<br />&nbsp;&nbsp;2，接受y，并固定它，返回一元函数h(z)，这样就把一个三元函数化为一元函数来处理。<br />&nbsp;&nbsp;&beta;-归约与curry化相互组合就能产生出各种复杂的过程，也产生了威力巨大的Lambda演算！<br /><br /><h3 style="margin: 0px; padding: 0px; border: 0px; list-style: none"><span style="word-wrap: normal; word-break: normal; line-height: 21.0599994659424px">3，&eta;-变换</span></h3><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">&nbsp;&nbsp;前两条规则之后，还可以加入第三条规则，eta-变换，来形成一个新的等价关系。Eta-变换表达的是<a style="text-decoration: none; color: #99481f" href="http://zh.wikipedia.org/wiki/%E5%A4%96%E5%BB%B6%E6%80%A7" title="外延性">外延性</a>的概念，在这里外延性指的是，两个函数对于所有的参数得到的结果都一致，当且仅当它们是同一个函数。Eta-变换 可以令&lambda;x .f x和f相互转换，只要x不是f中的自由出现。下面说明了为何这条规则和外延性是等价的：</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">若f与g外延地等价，即，f a == g a对所有的lambda表达式a成立，则当取a为在f中不是自由出现的变量x时，我们有f x == g x，因此&lambda;x .f x == &lambda;x .g x，由eta-变换f == g。所以只要eta-变换是有效的，会得到外延性也是有效的。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">相反地，若外延性是有效的，则由beta-归约，对所有的y有(&lambda;x .f x) y == f y，可得&lambda;x .f x == f，即eta-变换也是有效的。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; color: #787878">&nbsp;&nbsp;<span style="word-wrap: normal; word-break: normal; color: #000000">按照我的理解，eta-变换主要关于函数的等价性，这一点我在Scheme当中感触不深，倒是Python在函数之间可以直接赋值体现得更明显。</span>&nbsp;<br /></p></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;</td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;</td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;</td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;<br />另外FP中的重要概念在Lambda演算中也有坚实的理论基础<br /><br /><span style="word-wrap: normal; word-break: normal; line-height: 27px; font-size: 18px"><span style="word-wrap: normal; word-break: normal; font-weight: bold">递归</span></span><br /></td><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;</td></tr><tr><td style="margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px">&nbsp;&nbsp;由于纯函数式编程当中没有变量，所以没有循环，类似的过程全部由递归来实现，在Lambda演算中，不能定义包含自身的函数，因此递归通过<span style="word-wrap: normal; word-break: normal; font-weight: bold">不动点组合子</span>来实现。举个例子：<br /><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">为了计算阶乘，可以开始于定义一个函数，这里叫g，它接受一个函数f作 为参数并返回接受n作为参数的另一个函数：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">g&nbsp;:= &lambda;f n.(if n = 0 then 1 else n&middot;f(n-1))。</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">函数g返回要么常量1，要么函数f对n-1的n次应用。函数g可以用lambda演算来定义。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">但是，g自身仍然不是递归的；为了使用g来建立递归函数，作为参数传递给g的f函 数必须有特殊的性质。也就是说，作为参数传递的f函数必须展开为调用带有一个参数的函数g&nbsp;-- 并且这个参数必须再次f函数!</p>换句话说，f必须展开为g(f)。这个到g的调用将接着展开为上面的阶乘函数并计算下至另 一层递归。在这个展开中函数f将再次出现，并将被再次展开为g(f)并继续递归。这种函数，这裡的f = g(f)，叫做g的不动点。<br />&nbsp;&nbsp;在Lambda演算中，最常见最简单的不动点是Y组合子，它的定义为<br />&nbsp;&nbsp;Y = &lambda;g.(&lambda;x.g(x x))(&lambda;x.g(x x))<br />&nbsp;&nbsp;对于任意函数g，有Y g = g(Y g)。（我验算过了，这是真的- -~这是Curry发现的，您就是神）。对于阶乘函数，令n = 5<br /><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(&lambda;n.(if n = 0 then 1 else n&middot;((Y g)(n-1)))) 5</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">if 5 = 0 then 1 else 5&middot;(g(Y g，5-1))</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(g(Y g)4)</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(&lambda;n.(if n = 0 then 1 else n&middot;((Y g)(n-1))) 4)</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(if 4 = 0 then 1 else 4&middot;(g(Y g，4-1)))</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(4&middot;(g(Y g)3))</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(4&middot;(&lambda;n.(if n = 0 then 1 else n&middot;((Y g)(n-1))) 3))</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(4&middot;(if 3 = 0 then 1 else 3&middot;(g(Y g，3-1))))</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">5&middot;(4&middot;(3&middot;(g(Y g)2)))</dd><dt style="margin: 0px; padding: 0px; border: 0px; list-style: none">由于Y组合子的存在，函数反复调用自身，形成了递归。（神一般的存在。。。）</dt></dl>&nbsp;<br /><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none"><span style="word-wrap: normal; word-break: normal; line-height: 27px">逻辑与谓词</span></h2><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">习惯上，下述两个定义（称为邱奇布尔值）被用作TRUE和FALSE这样的布尔值：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">TRUE&nbsp;:= &lambda;x y.x</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">FALSE&nbsp;:= &lambda;x y.y<dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">(注意FALSE等价于前面定义邱奇数零)</dd></dl></dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">接着，通过这两个&lambda;-项，我们可以定义一些逻辑运算：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">AND&nbsp;:= &lambda;p q.p q FALSE</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">OR&nbsp;:= &lambda;p q.p TRUE q</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">NOT&nbsp;:= &lambda;p.p FALSE TRUE</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">IFTHENELSE&nbsp;:= &lambda;p x y.p x y</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">我们现在可以计算一些逻辑函数，比如：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">AND TRUE FALSE<dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">&equiv;(&lambda;p q.p q FALSE) TRUE FALSE &rarr;<sub>&beta;</sub>&nbsp;TRUE FALSE FALSE</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">&equiv;(&lambda;x y.x) FALSE FALSE &rarr;<sub>&beta;</sub>&nbsp;FALSE</dd></dl></dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">我们见到AND TRUE FALSE等价于FALSE。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">&ldquo;谓词&rdquo;是指返回布尔值的函数。最基本的一个谓词是ISZERO，当且仅当其参数为零时返回真，否则返回假：</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">ISZERO&nbsp;:= &lambda;n.n(&lambda;x.FALSE) TRUE</dd></dl><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">运用谓词与上述TRUE和FALSE的定义，使得&quot;if-then-else&quot;这类语句很容易用lambda 演算写出。FP要以Lambda演算为基础,在这里谓词和逻辑语句也有了相应的Lambda定义.</p><h2 style="margin: 0px; padding: 0px; border: 0px; list-style: none"><span style="word-wrap: normal; word-break: normal; line-height: 27px">有序对</span></h2><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">在逻辑谓词定义的基础上可以轻易的定义出有序对（2-元组）。</p><dl style="margin: 0px; padding: 0px; border: 0px; list-style: none"><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">CONS&nbsp;:= &lambda;x y.&lambda;p.IF p x y</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">CAR&nbsp;:= &lambda;x.x TRUE</dd><dd style="margin: 0px; padding: 0px; border: 0px; list-style: none">CDR&nbsp;:= &lambda;x.x FALSE</dd></dl>对应Scheme程序：<br />(define (cons x y)<br />&nbsp;&nbsp;(define (dispatch m)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if m x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y)))<br />&nbsp;&nbsp;dispatch)<br /><br />(define (car z) (z #t))<br />(define (cdr z) (z #f))<br /><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">链表数据类型可以定义为，要么是为空列表保留的值（e.g.FALSE），要么是CONS一个元素和一个更小的列表。这样,Lambda演算就定义出了LISP中唯一的数据结构.</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal"><br /></p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">&nbsp;&nbsp;LISP开发得非常早，当初完全是建立在Lambda演算的基础上，所以总结的这篇文章这里也看得到Lambda演算与LISP结合得非常紧密，LISP中的各个性质和元素在Lambda演算中都有对应的定义，当初接触Functional Programming的时候，完全没想到在它背后有这么一套简单，强大，完备的理论基础，LISP/Scheme也因此简单却强大。能够深入理解Lambda演算，对FP很有帮助。</p><p style="margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal">&nbsp;&nbsp;TT喜欢FP，TT要走的路还很长很长。。。。。</p></td></tr></tbody></table>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7520</link>
<title><![CDATA[DB主从一致性架构优化4种方法]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Wed, 31 Aug 2016 12:29:22 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7520</guid> 
<description>
<![CDATA[ 
	<p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">需求缘起</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">大部分互联网的业务都是&ldquo;读多写少&rdquo;的场景，数据库层面，读性能往往成为瓶颈。如下图：业界通常采用&ldquo;一主多从，读写分离，冗余多个读库&rdquo;的数据库架构来提升数据库的读性能。</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img1.tuicool.com/3uUjaue.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">这种架构的一个潜在缺点是，业务方有可能读取到并不是最新的旧数据：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img1.tuicool.com/RJbMna.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）系统先对DB-master进行了一个写操作，写主库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）很短的时间内并发进行了一个读操作，读从库，此时主从同步没有完成，故读取到了一个旧数据</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（3）主从同步完成</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">有没有办法解决或者缓解这类&ldquo;由于主从延时导致读取到旧数据&rdquo;的问题呢，这是本文要集中讨论的问题。</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案一（半同步复制）</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">不一致是因为写完成后，主从同步有一个时间差，假设是500ms，这个时间差有读请求落到从库上产生的。有没有办法做到，等主从同步完成之后，主库上的写请求再返回呢？答案是肯定的，就是大家常说的&ldquo;半同步复制&rdquo;semi-sync：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img0.tuicool.com/umEN7zR.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）系统先对DB-master进行了一个写操作，写主库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）等主从同步完成，写主库的请求才返回</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（3）读从库，读到最新的数据（如果读请求先完成，写请求后完成，读取到的是&ldquo;当时&rdquo;最新的数据）</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案优点：利用数据库原生功能，比较简单</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案缺点：主库的写请求时延会增长，吞吐量会降低</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案二（强制读主库）</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">如果不使用&ldquo;增加从库&rdquo;的方式来增加提升系统的读性能，完全可以读写都落到主库，这样就不会出现不一致了：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img0.tuicool.com/umEN7zR.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案优点：&ldquo;一致性&rdquo;上不需要进行系统改造</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案缺点：只能通过cache来提升系统的读性能，这里要进行系统改造</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案三（数据库中间件）</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">如果有了数据库中间件，所有的数据库请求都走中间件，这个主从不一致的问题可以这么解决：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img1.tuicool.com/ne6JFf7.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）所有的读写都走数据库中间件，通常情况下，写请求路由到主库，读请求路由到从库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）记录所有路由到写库的key，在经验主从同步时间窗口内（假设是500ms），如果有读请求访问中间件，此时有可能从库还是旧数据，就把这个key上的读请求路由到主库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（3）经验主从同步时间过完后，对应key的读请求继续路由到从库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案优点：能保证绝对一致</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案缺点：数据库中间件的成本比较高</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案四（缓存记录写key法）</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">既然数据库中间件的成本比较高，有没有更低成本的方案来记录某一个库的某一个key上发生了写请求呢？很容易想到使用缓存，当写请求发生的时候：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img0.tuicool.com/IrYBVjq.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）将某个库上的某个key要发生写操作，记录在cache里，并设置&ldquo;经验主从同步时间&rdquo;的cache超时时间，例如500ms</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）修改数据库</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">而读请求发生的时候：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe" align="center"><img style="max-width: 96%; height: auto; vertical-align: middle; border: 0px none; margin: 0px auto 10px; display: block" class="alignCenter" src="http://img1.tuicool.com/iEZZJn6.png!web" border="0" /></p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）先到cache里查看，对应库的对应key有没有相关数据</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案优点：相对数据库中间件，成本较低</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">方案缺点：为了保证&ldquo;一致性&rdquo;，引入了一个cache组件，并且读写数据库时都多了一步cache操作</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">总结</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">为了解决主从数据库读取旧数据的问题，常用的方案有四种：</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（1）半同步复制</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（2）强制读主</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（3）数据库中间件</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">（4）缓存记录写key</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7519</link>
<title><![CDATA[DB主从一致性的几种解决方法]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Wed, 31 Aug 2016 12:29:00 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7519</guid> 
<description>
<![CDATA[ 
	<div class="skin_center_t" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-size: 14px; vertical-align: baseline; color: #999999; font-family: Arial, sans-serif; line-height: 22px; background: transparent"><div class="skin_list" style="box-sizing: border-box; margin: 0px; padding: 0px 20px 0px 0px; border: 0px; outline: 0px; vertical-align: baseline; max-width: 1200px; background: transparent"><dl class="list_c clearfix detail_list" style="box-sizing: border-box; margin: 0px; padding: 0px 0px 5px; font-family: 'Microsoft YaHei'; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; position: relative; background: transparent"><dd style="box-sizing: border-box; line-height: 1.42857; margin: 0px 0px 0px 95px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; max-width: 1000px; background: transparent"><div id="article_content" class="skin_detail" style="box-sizing: border-box; margin: 0px; padding: 20px 0px; border: 0px; outline: 0px; vertical-align: baseline; word-break: break-word; background: transparent"><div class="markdown_views" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; font-family: 'microsoft yahei'; background: transparent"><h1 style="box-sizing: border-box; margin: 0.8em 0px; font-size: 28px; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 30px; color: #666666; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">DB主从一致性的几种解决方法</h1><h2 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: #666666; margin: 0.8em 0px; font-size: 22px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">起源</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; font-size: 15px; vertical-align: baseline; color: #666666; line-height: 26px; background: transparent">现在基本所有的程序中都会用到数据库，而数据库其实就是对所有业务逻辑处理结果的保存，所以不论在什么情况下数据的丢失都不被允许的，最坏的情况也要最小化数据的丢失程度，所以一般情况下，数据源都会至少配有两个节点，一个业务处理使用的节点，一个甚至多个从节点，这些从节点就是我们常说的冷备，业务处理节点（主节点）和备份节点一定的时间间隔内进行数据同步，从而来保证当一个数据源坏掉之后，数据也不会丢失，或着丢失很少（主要看同步的时间间隔）。但是为了提高资源的使用效率，所以有人就提出了，可不可以让冷备也被利用起来，替主节点分担部分压力，所以就提出了读写分离的方案。</p><h2 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: #666666; margin: 0.8em 0px; font-size: 22px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">读写分离</h2><p style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; font-size: 15px; vertical-align: baseline; color: #666666; line-height: 26px; background: transparent"><img style="box-sizing: border-box; border: 0px; vertical-align: middle; outline: 0px; margin: 0px; padding: 0px; max-width: 100%; background: transparent" src="http://img.blog.csdn.net/20160519201649725" border="0" alt="这里写图片描述" />&nbsp;<br />读写分离提高了资源的利用效率的同时也引出了一个问题，就是由于延时（网络传输，操作）而引起的数据库主从不一致的问题，对于这个问题，给一下集中解决方案。</p><hr style="box-sizing: border-box; height: 1px; margin: 2em 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: solid; border-top-color: rgba(128, 128, 128, 0.0980392); width: 999.188px; background-color: #eeeeee" /><h3 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; font-size: 14px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">1-半同步复制</h3><p style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; font-size: 15px; vertical-align: baseline; color: #666666; line-height: 26px; background: transparent">主从不一致的原因是延时引起的,所以要消除这个延时的影响，可以从主库进行CUD操作时进行规避，办法就是等主从同步完成之后，主库上的写请求再返回，就是大家常说的&ldquo;半同步复制&rdquo;semi-sync。</p><div class="sequence-diagram" style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; text-align: center; background: transparent">请求请求主库主库从库从库CUD操作开始同步同步完成CUD操作完成</div><ul style="box-sizing: border-box; margin: 0px 0px 22px; padding: 0px; font-family: 'Microsoft YaHei'; list-style: square inside; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案优点：利用数据库原生功能，比较简单</strong></li><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案缺点：主库的写请求时延会增长，吞吐量会降低</strong></li></ul><hr style="box-sizing: border-box; height: 1px; margin: 2em 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: solid; border-top-color: rgba(128, 128, 128, 0.0980392); width: 999.188px; background-color: #eeeeee" /><h3 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; font-size: 14px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">2-数据库中间件</h3><h4 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">CUD操作</h4><div class="sequence-diagram" style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; text-align: center; background: transparent">请求请求中间件中间件主库主库从库从库CUD操作路由同步</div><h4 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">R操作</h4><div class="sequence-diagram" style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; text-align: center; background: transparent">请求请求中间件中间件主库主库从库从库R操作同步未完成同步完成</div><ul style="box-sizing: border-box; margin: 0px 0px 22px; padding: 0px; font-family: 'Microsoft YaHei'; list-style: square inside; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案优点：能保证绝对一致</strong></li><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案缺点：数据库中间件的成本比较高</strong></li></ul><hr style="box-sizing: border-box; height: 1px; margin: 2em 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: solid; border-top-color: rgba(128, 128, 128, 0.0980392); width: 999.188px; background-color: #eeeeee" /><h3 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; font-size: 14px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">3-缓存记录写key法</h3><h4 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">CUD操作</h4><p style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; font-size: 15px; vertical-align: baseline; color: #666666; line-height: 26px; background: transparent">（1）将某个库上的某个key要发生写操作，记录在cache里，并设置&ldquo;经验主从同步时间&rdquo;的cache超时时间，例如500ms&nbsp;<br />（2）修改数据库</p><h4 style="box-sizing: border-box; font-family: 'Microsoft YaHei'; font-weight: 100; line-height: 1.1; color: inherit; margin: 0.8em 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">R操作</h4><p style="box-sizing: border-box; margin: 0px 0px 1.1em; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; font-size: 15px; vertical-align: baseline; color: #666666; line-height: 26px; background: transparent">（1）先到cache里查看，对应库的对应key有没有相关数据&nbsp;<br />（2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据&nbsp;<br />（3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离</p><ul style="box-sizing: border-box; margin: 0px 0px 22px; padding: 0px; font-family: 'Microsoft YaHei'; list-style: square inside; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案优点：相对数据库中间件，成本较低</strong></li><li style="box-sizing: border-box; margin: 0px; padding: 0px; list-style: none; border: 0px; outline: 0px; vertical-align: baseline; background: transparent"><strong style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; background: transparent">方案缺点：方案缺点：为了保证&ldquo;一致性&rdquo;，引入了一个cache组件，并且读写数据库时都多了一步cache操作</strong></li></ul></div></div></dd></dl></div><div class="skin_nav" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: baseline; position: fixed; right: 275px; top: 70px; background: transparent"><div class="skin_edit" style="box-sizing: border-box; margin: 0px 0px 10px; padding: 0px; border: 2px solid #2f2f2f; outline: 0px; vertical-align: baseline; width: 28px; height: 28px; line-height: 24px; text-align: center; cursor: pointer; position: relative; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial"></div></div><div class="rssFix" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 2px solid #2f2f2f; outline: 0px; vertical-align: baseline; width: 28px; height: 28px; text-align: center; line-height: 24px; position: fixed; bottom: 70px; right: 275px; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial"><a style="box-sizing: border-box; color: #444444; text-decoration: none; margin: 0px; padding: 0px; font-family: 'Microsoft YaHei'; outline: none; background: transparent" href="http://blog.csdn.net/xidiancyp/rss/list" class="column"></a></div></div><div class="detail_b" style="box-sizing: border-box; margin: 0px 0px 0px 95px; padding: 0px 60px 0px 0px; border: 0px; outline: 0px; font-size: 14px; vertical-align: baseline; max-width: 1250px; color: #999999; font-family: Arial, sans-serif; line-height: 22px; background: transparent"><p style="box-sizing: border-box; margin: 0px 0px 22px; padding: 0px; font-family: 'Microsoft YaHei'; border: 0px; outline: 0px; vertical-align: baseline; color: #e96d5b; background: transparent" class="reprint_copy">版权声明：本文为博主原创文章，未经博主允许不得转载。</p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?7518</link>
<title><![CDATA[抽象：程序员必备的能力]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[置顶]]></category>
<pubDate>Tue, 30 Aug 2016 13:15:22 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?7518</guid> 
<description>
<![CDATA[ 
	<p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">2015年大热的动画片《动脑特工队》中描述了这么一个场景， 冰棒带领乐乐和忧忧抄近路去乘坐思维列车，所谓的&ldquo;近路&rdquo;就是穿过抽象思维的房间，在这个房间里， 他们先是变成了变成3D的块，就像计算机图形学里展示的那样：</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702131650312-1378132761.jpg" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702131734546-1114060500.jpg" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　然后变成平面的图形</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702131759437-822846547.jpg" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　最后只剩下一些线条了 ！</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702131831656-122919176.jpg" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff"><br />　　真是非常生动的展示了人类做抽象活动的过程。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　在软件业，抽象能力的重要性怎么说都不为过，因为软件开发是一个高度复杂的智力活动，程序员经常需要面对、处理异常复杂的业务和逻辑，如果你不具备强大的抽象能力，无法把具体变成概念，进而驾驭概念进行思考， 你就很难降低问题的复杂度，从而陷入泥潭，无法自拔。无论你学会了多么强大的程序语言，你的编程能力也很难有质的提高。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　当然抽象不仅仅是软件开发的独有概念，在别的领域可以看到更多。在自然科学领域，抽象的例子更多，开普勒定律和万有引力就是很典型的例子。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　在16世纪很多人开始相信哥白尼提出的日心说，但一直搞不清楚围绕太阳的行星到底是怎么运动的，轨道是什么样子，著名天文学家开普勒仔细的研究了他的老师&mdash;&mdash;杰出的观测家&mdash;&mdash;第谷留下的大量天文观测数据以后， 提炼出了著名的开普勒三定律， 第一次给出了天体运行规律的解释：</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　1. 所有行星分别是在大小不同的椭圆轨道上运行</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　2. 在同样的时间里行星向径在轨道平面上所扫过的面积相等</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　3. 行星公转周期的平方与它同太阳距离的立方成正比</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702132023218-1737809406.jpg" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　开普勒三定律从大量的数据中提炼出数学规律， 无疑是非常伟大的发现和抽象， 但这不是最终本质，当然也不是最终的抽象。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　行星运动的本质是万有引力定律。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　相比于开普勒定律，天才的牛顿所做的抽象向前迈进了一大步，万有引力几乎覆盖了所有大质量物体之间互相吸引和运动的规律， 即简单又优美， 配合牛顿（和莱布尼茨）发明的微积分，可以很容易推导开普勒定律。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; text-align: center; background-color: #faffff"><img style="margin: 0px; padding: 0px; font-size: 12px; border: none; max-width: 620px" src="http://images2015.cnblogs.com/kb/1/201607/1-20160702132112640-1517045020.png" border="0" /></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　如果再加上牛顿力学三定律，尤其是F=ma，整个经典物理学的架子就建起来了，后人所有的工作只是在这座大厦上进行一些装修工作，直到爱因斯坦相对论的出现，才建立一座更宏伟的大厦。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　据说爱因斯坦在评价一个研究时，会用美和丑来作为判断标准，有人拿研究成果让爱因斯坦看， 爱因斯坦不说成果的好与坏，反而说&ldquo;这东西多丑陋啊&rdquo;， &ldquo;这东西真漂亮&rdquo;。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　其实一个抽象的东西形式优美，结构简单，很有可能是正确的，很可能抓住了事物的本质。相反如果连形式都丑陋不堪，十有八九不是好的成果。 以此作为标准，万有引力定律无疑是漂亮的，正确的，当然爱因斯坦的E=mc2更加漂亮和简单。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　<strong style="margin: 0px; padding: 0px; color: #333333">抽象的例子在软件业更是数不胜数：</strong></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　文件是对I/O的抽象；虚拟存储器是对物理存储器的抽象；进程是对一个正在运行的程序的抽象；我们再增加一个新的抽象：虚拟机， 他提供了对整个计算机（包括操作系统，处理器，程序）的抽象。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　Andorid把一个移动应用程序抽象成Activity , Intent, Service, Provider......稍微注意一下就会发现：<strong style="margin: 0px; padding: 0px; color: #333333">抽象层次越高，接口的语意就越模糊，适用的范围就越广</strong>，到最后就会变成数学模型或者概念。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　<strong style="margin: 0px; padding: 0px; color: #333333">数学模型和算法</strong></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　我认为把纷杂的事物抽象到数学层面是最高的抽象，也许会有人会说哲学层面才是:-) ，但到数学层面已经非常难了。尤其是重大的科学发现，身后必然有数学的影子。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　牛顿当年为了描述天体的轨道和运动，特别创立了新的数学表示： 微积分。麦克斯韦使用一组方程对电场和磁场行为进行描述。当年爱因斯坦脑海中已经有了广义相对论，但苦于找不到合适的数学形式来描述，他特别花了几年的时间来学习非欧几何和张量分析，最后才得以成功。海森堡用矩阵理论来解释量子力学。。。程序员在开发过程中， 也许能把一个实际的业务问题抽象成数学模型，或者抽象成特定的算法，这样会让程序实现变得非常简单和有趣。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　我在之前的公司有幸遇到过一次，把针对税务领域的一个Credit, Debit等概念抽象为在一个二维坐标下点的运动， 问题一下子简化了很多，实现简单，并且非常安全可靠。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　<strong style="margin: 0px; padding: 0px; color: #333333">正交的概念</strong></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　但是抽象成数学模型和算法通常是可遇而不可求的， 这种情况下，我们需要退而求其次，试图抽象成若干个正交的概念，来降低复杂度。&ldquo;正交&rdquo;在数学上指的是线性无关，最常见的例子就是坐标系下的x轴和y轴，对于一个点来讲，它的x值的变化不会影响到y，y值得变化不会影响到x ，即x和y是正交的。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　正交的威力在于互不影响，扩展方便，单用一个坐标轴可以表示一个直线上的所有的点， 再加一个y轴就能表示平面上的所有的点， 再加一个z轴，3维空间中的所有点都能表示出来了！</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　我们人类的大脑在思考问题的时候是有容量限制的， 难以同时驾驭太多复杂的概念， 如果我们的软件系统也能做成x,y,z坐标这样，就带来了无与伦比的好处，你在处理x轴相关的事情时，不用考虑其他的y和z相关的东西，因为你知道他们不会受到影响， 这样问题的复杂度就从3维一下子下降到1维！更容易把握了。如果单单x 轴仍然很复杂，你要做的就是再次分解成更小的概念，保证正交即可。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　<strong style="margin: 0px; padding: 0px; color: #333333">接口</strong></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　如果你说了，我的整个系统还没法抽象成正交的概念， 那只好再退一步，在局部使用接口。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　在著名的《设计模式》一书中，其实在反复强调一点: 发现变化并且封装变化，针对接口编程而不是实现编程。 很多人看书是只关注具体的模式，而忽略了模式的本质目的。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　我们在开发的过程中要保持一种敏锐的感觉，发现可能的变化并且封装起来，只提供一个精心定义的接口让外界调用。这样你在接口后面所做的任何变化，外边就不受影响了。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　例如在JDK中Iterator就是一个很好的抽象， 它将集合本身和集合的遍历分开。 Stream抽象也不错，封装了对文件和网络操作，只是使用起来稍显麻烦。其实 一组定义良好的接口一定是正交的，不然的话接口之间的依赖就会让实现非常麻烦。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　<strong style="margin: 0px; padding: 0px; color: #333333">总结</strong></p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　说到底，软件设计和开发就是把现实中的问题映射成计算机的语言实现，但现实问题太复杂，细节太多，而且在不断的变化过程中，一般人很难同时对这么的细节进行思考 ，这时候就需要抽象。</p><p style="margin: 5px 0px; padding: 0px; font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; color: #232323; line-height: 28px; background-color: #faffff">　　我们只有从纷繁复杂的现象中抽取事物的本质，从具体事物提炼出正交的概念，才能驾驭这些概念，才能在一个低复杂度的世界中进行思考。</p>
]]>
</description>
</item>
</channel>
</rss>