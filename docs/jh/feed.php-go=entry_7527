<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?</link>
<title><![CDATA[mysql优化之索引优化]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Thu, 01 Sep 2016 12:56:02 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?</guid> 
<description>
<![CDATA[ 
	<p style="margin: 10px auto; padding: 0px; font-size: 14px; line-height: 21px"><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=931" title="mysql优化系列">第一篇 序章</a><br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=950" title="mysql优化之连接优化">第二篇 连接优化</a><br />第三篇 索引优化<br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=990" title="mysql优化之查询优化">第四篇 查询优化</a><br /><a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=784" title="mysql优化之从实践中来，到实战中去">第五篇 到实战中去</a></p><h1 style="margin: 0px; padding: 0px; font-size: 28px">索引优化</h1><p style="margin: 10px auto; padding: 0px; font-size: 14px; line-height: 21px">索引优化涉及到几个方面，包括了索引的类型、如何让查询使用索引，查询是索引算法的选择等等操作。<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/?p=961"><span style="margin: 0px; padding: 0px" class="copyme">(原文链接http://ddbiz.com/?p=961)</span></a><br />涉及到数据库的查询时，大多数情况都是要建立索引的，MySQL的索引类型以及创建索引方式，可以参考其<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/doclib/mysql/cn51/optimization.html#indexes" target="_blank">文档</a>或者<a style="margin: 0px; padding: 0px; color: black" href="http://dev.mysql.com/doc/refman/5.6/en/optimization-indexes.html" target="_blank">这里</a>。</p><ol style="margin: 0px; padding: 0px 0px 0px 40px; font-size: 14px; line-height: 21px"><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="server-options"></a>服务器参数设置</h1><p style="margin: 10px auto; padding: 0px">在于索引有关系的数据库参数中，有一些特别重要，如下：</p><ol style="margin: 0px; padding: 0px 0px 0px 40px"><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_buffer_size"></a>key_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_buffer_size=#<br />ini/cnf参数: key_buffer_size<br />mysql 变量: key_buffer_size<br />全局变量，可动态调整，取值范围 8到4G(32bitOS), 在64bitOS上可以设置更高，只要你的系统有那么多物理内存。</p><p style="margin: 10px auto; padding: 0px">key_buffer_size 主要作用于MyISAM表的索引。我们知道，MyISAM的索引句柄是对全部连接用户共享的。状态参数 key_read_requests(响应用户请求时从缓存中获取的数据)和key_reads(响应用户请求时从文件中加载的数据) 可以用来检测key_buffer_size是否太小，根据<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/doclib/mysql/en55/server-administration.html#statvar_Key_read_requests" target="_blank">文档</a>, key_reads/key_read_request 应该远小于0.01(当然我们的测试环境可能完全无法达到此设定，只能尽量接近了). 如果一个MyISAM的数据表的索引文件过G，除非物理内存远远高于索引大小，否则让key_reads/key_read_request接近0.01也是一件不可能的任务。</p><p style="margin: 10px auto; padding: 0px">MySQL还支持把索引提前加载到内存，本节后面将<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#load-index-into-cache">描述此方法及其限制</a>.</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">受如下参数影响: 系统内存<br />将影响如下参数: 无<br />调整触发条件: key_reads/key_read_request &gt;0.01</p></blockquote></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_block_size"></a>key_cache_block_size</h2><p style="margin: 10px auto; padding: 0px">与key_buffer_size相关联的另外一个参数是 key_cache_block_size<br />命令行参数: &ndash;key_cache_block_size=#<br />ini/cnf参数: key_cache_block_size<br />mysql 变量: key_cache_block_size<br />全局变量，可动态调整，取值范围 512bytes到16k。</p><p style="margin: 10px auto; padding: 0px">key_cache_block_size表明key_buffer_size被分割的区域的大小。可以通过 show status 来判断当前key_buffer_size被分为多少个块：</p><p style="margin: 10px auto; padding: 0px">Key_blocks_unused, 目前剩余可用的索引缓存空间<br />Key_blocks_used(历史上的最大峰值)</p><p style="margin: 10px auto; padding: 0px">对于一个key_buffer_size=4G的数据库来说， key_cache_block_size*Key_blocks_unused 就是剩余的可用的缓存空间。只要这个空间允许，我们都应该尽可能的把索引预装入缓存中（见<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#load-index-into-cache">LOAD INDEX INTO CACHE</a></p><p style="margin: 10px auto; padding: 0px">理论上讲，key_cache_block_size与操作系统的I/O buffer相同大小时工作（读取、写入）效率最高，比如linux中i/o缓存一般为1k. 对于mysql来说，可以通过&nbsp;<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#myisam-block-size">&ndash;myisam-block-size</a>来定义MyISAM索引文件的块大小，其最小为1k。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_division_limit"></a>key_cache_division_limit</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_cache_division_limit=1~100<br />配置文件参数: key_cache_division_limit=#<br />MySQL变量: key_cache_division_limit<br />全局可调整变量，默认为100(即LRU队列)。<br />当MyISAM的key_buffer_size中设置了key_cache_division_limit(</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="key_cache_age_threshold"></a>key_cache_age_threshold</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;key_cache_age_threshold=100~4G(32bitOS)或者100~~(64bitOS)<br />配置文件参数: key_cache_age_threshold=#<br />MySQL变量: key_cache_age_threshold<br />全局可调整变量，默认为300。<br />当MyISAM的key_buffer_size被分为热链和温链时，key_cache_age_threshold就被用来控制什么样的情况下处于热链的数据会被转移到温链中。key_cache_age_threshold是指的block个数，如果在最近的 （key_cache_age_threshold * key_cache_division_limit/100）次访问中，处于热链顶部的block没有被访问到，那么这些块将被移到温链的顶部（处于温链顶部的block会很快被移除出key cache）。</p><p style="margin: 10px auto; padding: 0px"><span style="margin: 0px; padding: 0px" class="warning">说明:<br />key_buffer_size, key_cache_block_size, key_cache_division_limit, key_cache_age_threshold 这4个变量是一个结构变量中的一组变量。本文后续有部分<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/blog/mysql/mysql%e4%bc%98%e5%8c%96%e4%b9%8b%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96/961#cache_index">详细介绍</a>.</span></p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="read_buffer_size"></a>read_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;read_buffer_size=#<br />ini/cnf参数: read_buffer_size<br />mysql 变量: read_buffer_size<br />全局变量，可动态调整，默认128k，取值范围8k到2G.</p><p style="margin: 10px auto; padding: 0px">read_buffer_size主要作用于顺序读取一批数据时，减少数据库文件访问的次数。</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">受如下参数影响:<br />将影响如下参数: KEY_BLOCK_SIZE（表创建时的参数）<br />调整触发条件:</p></blockquote></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="read_rnd_buffer_size"></a>read_rnd_buffer_size</h2><p style="margin: 10px auto; padding: 0px">命令行参数: &ndash;read_rnd_buffer_size=#<br />ini/cnf参数: read_rnd_buffer_size<br />mysql 变量: read_rnd_buffer_size<br />全局变量，可动态调整，默认256k，取值范围8k到4G.</p><p style="margin: 10px auto; padding: 0px">read_rnd_buffer_size用于<strong style="margin: 0px; padding: 0px">使用键/索引进行排序时</strong>的磁盘文件预读，一个足够大的read_rnd_buffer_size对ORDER BY语句会有很大影响。<br /><span style="margin: 0px; padding: 0px" class="notice">注意:read_rnd_buffer_size是和每一个session相关的，因此其大小需要谨慎处理，当并发连接很大时，尤其要小心。</span></p></li></ol></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="load-index-into-cache"></a>LOAD CACHE INTO CACHE</h1><p style="margin: 10px auto; padding: 0px">MySQL可以把索引文件预先加载到<strong style="margin: 0px; padding: 0px">指定</strong>的缓存中:</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">LOAD INDEX INTO CACHE table_name;<br />LOAD INDEX INTO CACHE table_name INDEX (index_name_1, index_name_2);<br />LOAD INDEX INTO CACHE table_name INDEX (index_name_1, index_name_2) IGNORE LEAVES;</p></blockquote><p style="margin: 10px auto; padding: 0px">对于查询型的超大型的表，当没有足够的内存时，可以使用 IGNORE LEAVES 的方式加载索引到缓存。比如一个接近1Billion的数据表，其索引可能也是几G大小的。下面这个例子就显示了当预先加载数据索引时，查询的速度变化，这个数据表有接近1亿条记录，3个索引，有超过3G的大小，对于同一个查询：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">#mysql&gt; select * from tbigdatatable where username in (&lsquo;ABCDEF&rsquo;, &lsquo;19740821&rsquo;)</p></blockquote><p style="margin: 10px auto; padding: 0px">在非预先加载索引以及预载索引的情况下，查询的响应区别:</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">#mysqld_safe &ndash;key-buffer-cache=1073741824<br />####不预载索引#### 5 rows in set (0.65 sec)<br />######预载索引#### 5 rows in set (1.94 sec)</p></blockquote><p style="margin: 10px auto; padding: 0px">当然一个查询有很大的偶然性，不过从一个大量的查询平均来看，这个效果还是有很大的差别的。</p><p style="margin: 10px auto; padding: 0px">如果一个表的索引包含不同的key_block_size,那么这个预装载将会遇到困难, 如：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">alter table tbigdatatable add index idx_bigdatatable_username(username) key_block_size=8192, add index idx_bigdatatable_email(email) key_block_size=8192, add index idx_bigdatatable_id(id) key_block_size=1024;<br />load index into cache tbigdatatable index (idx_bigdatatable_username, idx_bigdatatable_email) ignore leaves;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br />&#124; Table &#124; Op &#124; Msg_type &#124; Msg_text &#124;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; error &#124; Indexes use different block sizes &#124;<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; error &#124; Subpartition p178sp0 returned error &#124;<br />&#124; coredata.tbigdatatable &#124; preload_keys &#124; status &#124; Operation failed &#124;<br />+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+</p></blockquote><p style="margin: 10px auto; padding: 0px">因为.MYI中包含不同block_size的索引，所以无法预加载！</p><p style="margin: 10px auto; padding: 0px"><span style="margin: 0px; padding: 0px" class="notice">MySQL 5.1 对分区表不能预装载索引：<br />preload_keys &#124; note &#124; The storage engine for the table doesn&rsquo;t support preload_keys<br />真是不幸, 这些版本包括: 5.1.47, 5.1.61-community-log</span></p><p style="margin: 10px auto; padding: 0px">因为手头上没有MySQL5.5的数据库可供使用，所以关于预装载索引到内存的方法只能暂时放一放，这也导致了我的另外一个测试项目差点夭折：9千万数据的<a style="margin: 0px; padding: 0px; color: black" href="http://ddbiz.com/%e6%b3%84%e5%af%86%e7%94%a8%e6%88%b7%e6%a3%80%e7%b4%a2" target="_blank">分区表查询</a>，每个查询要耗时1m左右，伤不起啊。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h1 style="margin: 0px; padding: 0px; font-size: 28px"><a style="margin: 0px; padding: 0px" name="cache_index"></a>CACHE INDEX</h1><p style="margin: 10px auto; padding: 0px">LOAD INDEX INTO CACHE可以把索引装入缓存中，除此外，MySQL还可以更有针对性的把索引装入制定的缓存中。key_buffer_size是一个结构中一个变量，这个结构是系统的默认缓存空间，我们还可以设定其他的缓存空间，比如：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">set global key1.key_buffer_size=128*1024*1024;<br />set global key2.key_buffer_size=512*1024*1024;</p></blockquote><p style="margin: 10px auto; padding: 0px">这样我们就能定义不同的缓存空间，配合 CACHE INDEX IN cache_region语句，就可以把不同的索引放入不同的缓存中。</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">(接上)<br />cache index table_name index (index_name_1) in key1;<br />cache index table_name index (index_name_2) in key2;<br />load cache into cache table_name index (index_name_1);<br />load cache into cache table_name index (index_name_2) ignore leaves;</p></blockquote><p style="margin: 10px auto; padding: 0px">上面的语句就把 index_name_1放入了 key1, 把 index_name_2放入了 key2;至于何时使用不同的缓存，我们在后面的实战中再做讨论。</p><p style="margin: 10px auto; padding: 0px">结构化的变量，在mysql中没办法用 show variables like &lsquo;structure_name_1.key_buffer%&rsquo; ; 的方式来查询。假如我们定义了不同的结构变量（创建不同的缓存空间的）: staticdb.*，则可以用下面的方式来查询该空间的设置情况：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">set global staticdb.key_buffer_size=1000*1024*1024;<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />mysql&gt; select @@global.staticdb.key_buffer_size KBS<br />, @@global.staticdb.key_cache_division_limit KCDL<br />, @@global.staticdb.key_cache_age_threshold KCAT<br />, @@global.staticdb.key_cache_block_size KCBS;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />&#124; KBS &#124; KCDL &#124; KCAT &#124; KCBS &#124;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />&#124; 1048576000 &#124; 100 &#124; 300 &#124; 1024 &#124;<br />+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+<br />1 row in set (0.00 sec)</p></blockquote><p style="margin: 10px auto; padding: 0px">目前我还没有办法查看指定一个结构空间的使用情况，如果你知道如何查看的话，请留言给我。</p></li><li style="margin: 0px 0px 1em; padding: 0px; list-style: decimal"><h2 style="margin: 15px auto 2px; padding: 0px; font-size: 21px"><a style="margin: 0px; padding: 0px" name="summary"></a>要点总结</h2><p style="margin: 10px auto; padding: 0px">本节的要点是：</p><blockquote style="margin: 10px 0px; padding: 5px 10px; border: 2px solid #efefef; line-height: 1.6; color: #333333; background: none"><p style="margin: 10px auto; padding: 0px">对于MyISAM来说：设置尽可能大的缓存，最好把MyISAM表的索引能够全部装入缓存中</p></blockquote></li></ol>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?#blogcomment</link>
<title><![CDATA[[评论] mysql优化之索引优化]]></title> 
<author> &lt;user@domain.com&gt;</author>
<category><![CDATA[评论]]></category>
<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?#blogcomment</guid> 
<description>
<![CDATA[ 
	
]]>
</description>
</item>
</channel>
</rss>