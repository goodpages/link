<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?</link>
<title><![CDATA[require.extensions 自定义模块后缀]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[web]]></category>
<pubDate>Wed, 24 Aug 2016 11:37:28 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?</guid> 
<description>
<![CDATA[ 
	<p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">上一篇讲了模块是如何被寻找到然后加载进来的，这篇则是如何导出属性方法以及自定义模块后缀等一系列模块问题。</p><h2 style="margin: 0px 0px 0.5em; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; line-height: 1.6em; color: #333333; text-rendering: optimizeLegibility; font-size: 18px; text-indent: 1em; background-color: #fefefe">exports 对象</h2><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">这是最常见的对象了，以往导出都是这样写的。</p><pre class="prettyprint php" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6"><span style="font-style: italic; color: #999988" class="comment">// a.js</span> exports.bar = <span style="color: #dd1144" class="string">'属性'</span>; exports.fn = <span class="function"><span style="font-weight: bold" class="keyword">function</span> <span class="params">()</span> &#123;</span> <span style="font-weight: bold" class="keyword">return</span> <span style="color: #dd1144" class="string">'方法'</span> &#125;;&nbsp;&nbsp;<span style="font-style: italic; color: #999988" class="comment">// b.js</span> <span style="font-weight: bold" class="keyword">var</span> a = <span style="font-weight: bold" class="keyword">require</span>(<span style="color: #dd1144" class="string">'./a'</span>); console.log(a.bar); <span style="font-style: italic; color: #999988" class="comment">// 属性</span> console.log(a.fn()); <span style="font-style: italic; color: #999988" class="comment">// 方法</span></pre><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">一直都是这么用非常简单，但是不能直接用对象覆盖他，如下代码是不对的。</p><pre class="prettyprint php" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6"><span style="font-style: italic; color: #999988" class="comment">// a.js</span> exports = &#123;&nbsp;&nbsp; bar: <span style="color: #dd1144" class="string">'属性'</span>,&nbsp;&nbsp; fn: <span class="function"><span style="font-weight: bold" class="keyword">function</span> <span class="params">()</span> &#123;</span> <span style="font-weight: bold" class="keyword">return</span> <span style="color: #dd1144" class="string">'方法'</span> &#125; &#125;;&nbsp;&nbsp;<span style="font-style: italic; color: #999988" class="comment">// b.js</span> <span style="font-weight: bold" class="keyword">var</span> a = <span style="font-weight: bold" class="keyword">require</span>(<span style="color: #dd1144" class="string">'./a'</span>); console.log(a.bar); <span style="font-style: italic; color: #999988" class="comment">// undefined</span> console.log(a.fn()); <span style="font-style: italic; color: #999988" class="comment">// 报错</span></pre><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">为什么不能直接覆盖呢，因为&nbsp;exports&nbsp;只是&nbsp;module.exports&nbsp;对象的引用。</p><h2 style="margin: 0px 0px 0.5em; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; line-height: 1.6em; color: #333333; text-rendering: optimizeLegibility; font-size: 18px; text-indent: 1em; background-color: #fefefe">module.exports&nbsp;对象</h2><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">如果要导出一整个对象或者构造函数之类的，就需要用到&nbsp;module.exports&nbsp;对象了。</p><pre class="prettyprint php" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6"><span style="font-style: italic; color: #999988" class="comment">// a.js</span> module.exports = &#123;&nbsp;&nbsp; bar: <span style="color: #dd1144" class="string">'属性'</span>,&nbsp;&nbsp; fn: <span class="function"><span style="font-weight: bold" class="keyword">function</span> <span class="params">()</span> &#123;</span> <span style="font-weight: bold" class="keyword">return</span> <span style="color: #dd1144" class="string">'方法'</span> &#125; &#125;;&nbsp;&nbsp;<span style="font-style: italic; color: #999988" class="comment">// b.js</span> <span style="font-weight: bold" class="keyword">var</span> a = <span style="font-weight: bold" class="keyword">require</span>(<span style="color: #dd1144" class="string">'./a'</span>); console.log(a.bar); <span style="font-style: italic; color: #999988" class="comment">// 属性</span> console.log(a.fn()); <span style="font-style: italic; color: #999988" class="comment">// 方法</span></pre><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">导出构造函数：</p><pre class="prettyprint php" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6"><span style="font-style: italic; color: #999988" class="comment">// klass.js</span> <span class="function"><span style="font-weight: bold" class="keyword">function</span> <span style="font-weight: bold; color: #990000" class="title">klass</span> <span class="params">()</span> &#123;</span>&#125; klass.prototype.say = <span class="function"><span style="font-weight: bold" class="keyword">function</span> <span class="params">()</span> &#123;</span> <span style="font-weight: bold" class="keyword">return</span> <span style="color: #dd1144" class="string">'我是klass'</span> &#125;; module.exports = klass;&nbsp;&nbsp;<span style="font-style: italic; color: #999988" class="comment">// b.js</span> <span style="font-weight: bold" class="keyword">var</span> Klass = <span style="font-weight: bold" class="keyword">require</span>(<span style="color: #dd1144" class="string">'./klass'</span>); <span style="font-weight: bold" class="keyword">var</span> klass = <span style="font-weight: bold" class="keyword">new</span> Klass(); console.log(klass.say()); <span style="font-style: italic; color: #999988" class="comment">// 我是klass</span></pre><h2 style="margin: 0px 0px 0.5em; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; line-height: 1.6em; color: #333333; text-rendering: optimizeLegibility; font-size: 18px; text-indent: 1em; background-color: #fefefe">module 其他属性</h2><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">module 还有些其他属性，简单说下吧。</p><ul style="padding: 0px; margin: 0px 0px 0.75em 25px; list-style-type: none; font-size: 16px; line-height: 27.2px; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe"><li style="line-height: 1.7em; list-style-type: disc">module.id&nbsp;模块id，往往是模块路径</li><li style="line-height: 1.7em; list-style-type: disc">module.children&nbsp;子模块</li><li style="line-height: 1.7em; list-style-type: disc">module.filename&nbsp;模块路径</li><li style="line-height: 1.7em; list-style-type: disc">module.loaded&nbsp;是否加载完毕</li><li style="line-height: 1.7em; list-style-type: disc">module.parent&nbsp;父模块</li><li style="line-height: 1.7em; list-style-type: disc">module.paths&nbsp;各级 node_modules 目录路径</li></ul><h2 style="margin: 0px 0px 0.5em; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; line-height: 1.6em; color: #333333; text-rendering: optimizeLegibility; font-size: 18px; text-indent: 1em; background-color: #fefefe">require 函数</h2><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">说模块，当然离不开&nbsp;require&nbsp;函数，除了加载模块之外，他还有一些其他用法。</p><ul style="padding: 0px; margin: 0px 0px 0.75em 25px; list-style-type: none; font-size: 16px; line-height: 27.2px; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe"><li style="line-height: 1.7em; list-style-type: disc">require.resolve&nbsp;不会加载执行，只会返回模块的绝对路径。</li><li style="line-height: 1.7em; list-style-type: disc">require.cache&nbsp;缓存所有已经加载的模块，如果你要更新模块就要删除这里的缓存。</li></ul><pre class="prettyprint php" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6"><span style="font-weight: bold" class="keyword">var</span> a = <span style="font-weight: bold" class="keyword">require</span>(<span style="color: #dd1144" class="string">'./a'</span>); <span style="font-weight: bold" class="keyword">var</span> p = <span style="font-weight: bold" class="keyword">require</span>.resolve(<span style="color: #dd1144" class="string">'./a'</span>); <span style="font-style: italic; color: #999988" class="comment">// 得到模块路径</span>&nbsp;&nbsp;delete <span style="font-weight: bold" class="keyword">require</span>.cache[p]; <span style="font-style: italic; color: #999988" class="comment">// 删除模块缓存</span></pre><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">虽然不清楚什么时候用，但是至少是这么用的，删除缓存后，下次加载这个模块，就会重新加载模块文件了。</p><h2 style="margin: 0px 0px 0.5em; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; line-height: 1.6em; color: #333333; text-rendering: optimizeLegibility; font-size: 18px; text-indent: 1em; background-color: #fefefe">require.extensions&nbsp;自定义模块后缀</h2><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">还有个&nbsp;require.extensions&nbsp;非常好用的属性，但遗憾的是官方提示弃用了这个属性，不过值得庆幸的是，这个属性永远不会被移除，只是不推荐使用而已。</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">我第一次注意到这个属性是在 ejs 源码里，当时很好奇这是个什么东西，去翻了下官方文档，发现捡到宝了。后来又发现 node 命令行下的 babel 模块也注册了自定义模块，后缀分别是&nbsp;.es&nbsp;,&nbsp;.es6&nbsp;,&nbsp;.jsx&nbsp;，可以直接&nbsp;require('./a.es6')&nbsp;或者是&nbsp;require('./a.jsx')&nbsp;得到编译好的 js 代码。</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">好了，不说废话了，来看个官方简单例子吧。</p><pre class="prettyprint javascript" style="padding: 0.3em; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; color: #333333; border-radius: 4px; margin-top: 0px; margin-bottom: 1.5em; font-size: 12px; line-height: 1.5em; word-break: break-all; word-wrap: break-word; white-space: pre-wrap; border: 1px solid rgba(0, 0, 0, 0.14902); overflow-y: auto; background-color: #f6f6f6">require.extensions[<span style="color: #dd1144" class="string">'.json'</span>] = <span style="font-weight: bold" class="keyword">function</span>(module, filename) &#123;&nbsp;&nbsp; <span style="font-weight: bold" class="keyword">var</span> content = fs.readFileSync(filename, <span style="color: #dd1144" class="string">'utf8'</span>);&nbsp;&nbsp; <span style="font-weight: bold" class="keyword">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp; module.exports = JSON.parse(content);&nbsp;&nbsp; &#125; <span style="font-weight: bold" class="keyword">catch</span> (err) &#123;&nbsp;&nbsp;&nbsp;&nbsp; err.message = filename + <span style="color: #dd1144" class="string">': '</span> + err.message;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold" class="keyword">throw</span> err;&nbsp;&nbsp; &#125; &#125;;</pre><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">这是 node 源码的 json 模块实现，我只是删除了一个 stripBOM 函数，为了方便大家理解。</p><p style="margin: 0px 0px 0.75em; font-size: 16px; line-height: 27.2px; text-indent: 1em; color: #333333; font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, STXihei, 'Microsoft YaHei', 微软雅黑, sans-serif; background-color: #fefefe">当然官方不推荐这样做是有道理的，官方推荐编译为兼容的 js 代码模块运行，性能更佳，而不应该采用这样的自定义模块实现。不过看用途而定了，有时候也不一定追求极致的性能。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?#blogcomment</link>
<title><![CDATA[[评论] require.extensions 自定义模块后缀]]></title> 
<author> &lt;user@domain.com&gt;</author>
<category><![CDATA[评论]]></category>
<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?#blogcomment</guid> 
<description>
<![CDATA[ 
	
]]>
</description>
</item>
</channel>
</rss>