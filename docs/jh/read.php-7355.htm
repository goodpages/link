<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="UTF-8" />
<meta content="all" name="robots" />
<meta name="author" content="流浪的龙－个人知识管理" />
<meta name="description" content="" />
<meta name="keywords" content="bo-blog" />
<xbasehref="http://i.renjihe.com/blog/" />
<link rel="alternate" title="流浪的龙－个人知识管理" href="feed.php" type="application/rss+xml" />
<link rel="stylesheet" rev="stylesheet" href="styles.css" tppabs="http://i.renjihe.com/blog/template/default/styles.css" type="text/css" media="all" />

<title>Amit&#039;s A star Page中译文 - 流浪的龙－个人知识管理 - </title>
<script type="text/javascript" src="common.js-jsver=2.1.1.3626.3" tppabs="http://i.renjihe.com/blog/images/js/common.js?jsver=2.1.1.3626.3"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://i.renjihe.com/blog/inc/rsd.php" />
<script type="text/javascript" src="jslang.js-jsver=2.1.1.3626.3" tppabs="http://i.renjihe.com/blog/lang/zh-cn/jslang.js?jsver=2.1.1.3626.3"></script>
<script type="text/javascript" src="ajax.js-jsver=2.1.1.3626.3" tppabs="http://i.renjihe.com/blog/images/js/ajax.js?jsver=2.1.1.3626.3"></script>
<script type="text/javascript" src="swfobject.js-jsver=2.1.1.3626.3" tppabs="http://i.renjihe.com/blog/images/js/swfobject.js?jsver=2.1.1.3626.3"></script>
<script type="text/javascript">
//<![CDATA[
var moreimagepath="template/default/images";
var shutajax=0;
var absbaseurl='index.htm'/*tpa=http://i.renjihe.com/blog/*/;
//]]>
</script>
<link title="搜索 流浪的龙－个人知识管理" rel="search"  type="application/opensearchdescription+xml"  href="http://i.renjihe.com/blog/inc/opensearch.php" />



</head>
<body id="pagelocation-read">
<div id="wrapper">
	<div id="innerWrapper">
		<div id="header">
			<div id="innerHeader">
				<div id="blogLogo">
				</div>
				<div class="blog-header">
					<h1 class="blog-title"><a href="index.php.htm" tppabs="http://i.renjihe.com/blog/index.php">流浪的龙－个人知识管理</a></h1>
					<div class="blog-desc"></div>
				</div>
				<div id="menu">
					<ul>
					<li><span id="nav_index" class="activepage"><a href="index.php.htm" tppabs="http://i.renjihe.com/blog/index.php" ><span id="navitem_index" class="activepageitem">首页</span></a></span></li>
<li><span id="nav_http_3A_2F_2Fi.renjihe.com_2F"><a href="javascript:if(confirm('http://i.renjihe.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://i.renjihe.com/'" tppabs="http://i.renjihe.com/"  target="_blank"><span id="navitem_http_3A_2F_2Fi.renjihe.com_2F">个性首页</span></a></span></li>
<li><span id="nav_http_3A_2F_2Fi.renjihe.com_2Flink.html"><a href="javascript:if(confirm('http://i.renjihe.com/link.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://i.renjihe.com/link.html'" tppabs="http://i.renjihe.com/link.html"  target="_blank"><span id="navitem_http_3A_2F_2Fi.renjihe.com_2Flink.html">网址导航</span></a></span></li>
<li><span id="nav_tag"><a href="tag.php.htm" tppabs="http://i.renjihe.com/blog/tag.php" ><span id="navitem_tag">标签</span></a></span></li>
<li><span id="nav_guestbook"><a href="guestbook.php.htm" tppabs="http://i.renjihe.com/blog/guestbook.php" ><span id="navitem_guestbook">留言</span></a></span></li>
					</ul>
				</div>
			</div>
		</div>
		<div id="mainWrapper">
			<div id="content" class="content">
				<div id="innerContent">
					<div class="announce" style="display: none">
						<div class="announce-content">
						
						</div>
					</div>
					<div class="article-top" style="display: none">
						<div class="pages">
							
						</div>
					</div>
					<div class="article-top">
	<div class="prev-article"><a href="read.php-7332.htm" tppabs="http://i.renjihe.com/blog/read.php?7332" title="上一篇 GameBoy模拟器开发"><img src="toolbar_previous.gif" tppabs="http://i.renjihe.com/blog/template/default/images/toolbar_previous.gif" alt='' border='0'/>GameBoy模拟器开发</a></div>
	<div class="next-article"><a href="read.php-7356.htm" tppabs="http://i.renjihe.com/blog/read.php?7356" title="下一篇 网格沉思-游戏中的网格系"><img src="toolbar_next.gif" tppabs="http://i.renjihe.com/blog/template/default/images/toolbar_next.gif" alt='' border='0'/>网格沉思-游戏中的网格系</a></div>
</div>
<div class="textbox">
	<div class="textbox-calendar">
	<span class="textbox-calendar-month">Jun</span>
	<span class="textbox-calendar-day">29</span>
	</div>
	<div class="textbox-title">
		<h4>
		Amit&#039;s A star Page中译文 <span id="starid7355"><img src="unstarred.gif" tppabs="http://i.renjihe.com/blog/template/default/images/others/unstarred.gif" alt="" title="未加星标" border="0"/></span> <img src="blank.gif" tppabs="http://i.renjihe.com/blog/images/weather/blank.gif" alt="不指定" title="不指定"/> 
		</h4>
		<div class="textbox-label">
		 <a href="view.php-go=user_1.htm" tppabs="http://i.renjihe.com/blog/view.php?go=user_1" target="_blank">renjihe1988</a> , 21:06 , <a href="index.php-go=category_2.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_2" title="查看分类： 软件">软件</a> &raquo; <a href="index.php-go=category_62.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_62" title="查看分类： 游戏">游戏</a> , <a href="read.php-7355.htm#reply" tppabs="http://i.renjihe.com/blog/read.php?7355#reply" title="发表您的评论">评论(0)</a> , <a href='javascript: void(0);' title="查看引用地址" onclick='showhidediv("tb7355");'>引用(0)</a> , <a href="read.php-7355.htm" tppabs="http://i.renjihe.com/blog/read.php?7355">阅读(0)</a> ,  Via 本站原创 <span class="text-label-indented"><img src="toolbar_fontsize.gif" tppabs="http://i.renjihe.com/blog/template/default/images/toolbar_fontsize.gif" alt='' title="字体大小" border='0'/> <a href="javascript: doZoom(16);">大</a> | <a href="javascript: doZoom(14);">中</a> | <a href="javascript: doZoom(12);">小</a> <a href="javascript:if(confirm('http://i.renjihe.com/blog/Kurt_Godel  \n\nļ޷ Teleport Ultra , Ϊ , , Ŀֹͣ  \n\nڷϴ?'))window.location='http://i.renjihe.com/blog/Kurt_Godel'" tppabs="http://i.renjihe.com/blog/feed.php?go=entry_7355"><img src="toolbar_rss.gif" tppabs="http://i.renjihe.com/blog/template/default/images/toolbar_rss.gif" alt='' title="订阅本文" border='0'/></a> <a href="javascript:if(confirm('http://i.renjihe.com/blog/g-del-s-incompleteness-theorems  \n\nļ޷ Teleport Ultra , Ϊ , , Ŀֹͣ  \n\nڷϴ?'))window.location='http://i.renjihe.com/blog/g-del-s-incompleteness-theorems'" tppabs="http://i.renjihe.com/blog/read.php?save_7355"><img src="toolbar_save.gif" tppabs="http://i.renjihe.com/blog/template/default/images/toolbar_save.gif" alt='' title="保存本文为文本文档" border='0'/></a></span>
		</div>
	</div>
	<div id="tb7355" style="display: none;" class="textbox-tburl"><strong>引用功能被关闭了。</strong></div>
	
	<div class="textbox-content" id="zoomtext">
	 	<p style="font-size: 13px; line-height: 16.25px; margin: 0cm 0cm 0pt; text-indent: 24.1pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><strong><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">译序</span></strong><strong><span style="font-size: 12pt; line-height: 20px"></span></strong></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">这篇文章很适合</span><span>A*</span><span style="font-family: 宋体">算法的初学者，可惜网上没找到翻译版的。本着好东西不敢独享的想法，也为了锻炼一下英文，本人译了这篇文章。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">由于本人英文水平非常有限，六级考了两次加一块不超过</span><span>370</span><span style="font-family: 宋体">分，因此本译文难免存在问题。不过也算是抛砖引玉，希望看到有更多的游戏开发方面的优秀译作出现，毕竟中文的优秀资料太少了，中国的游戏开发者的路不好走。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">本人能力有限，译文中有小部分词句实在难以翻译，因此暂时保留英文原文放在译文中。对于不敢确定翻译是否准确的词句，本人用圆括号保留了英文原文，读者可以对照着加以理解。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>A*</span><span style="font-family: 宋体">算法本身是很简单的，因此原文中并没有过多地讨论</span><span>A*</span><span style="font-family: 宋体">算法本身，而是花了较大的篇幅讨论了用于保存</span><span>OPEN</span><span style="font-family: 宋体">和</span><span>CLOSED</span><span style="font-family: 宋体">集的数据结构，以及</span><span>A*</span><span style="font-family: 宋体">算法的变种和扩展。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">编程实现</span><span>A*</span><span style="font-family: 宋体">是简单的，读者可以用</span><span>STL</span><span style="font-family: 宋体">对本文中的伪代码加以实现（本人已花一天时间实验过基本的</span><span>A*</span><span style="font-family: 宋体">搜索）。但是最重要的还是对</span><span>A*</span><span style="font-family: 宋体">本身的理解，这样才可以在自己的游戏中处理各种千变万化的情况。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">翻译本文的想法产生于</span><span>2006</span><span style="font-family: 宋体">年</span><span>5</span><span style="font-family: 宋体">月，实际完成于</span><span>2007</span><span style="font-family: 宋体">年</span><span>4</span><span style="font-family: 宋体">月到</span><span>6</span><span style="font-family: 宋体">月，非常惭愧。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">最后，本译文仅供交流和参考，对于因本译文放到网上而产生的任何问题，本人不负任何责任。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: right" class="MsoNormal" align="right"><span style="font-family: 宋体">　　　　　　　　　　　　　　　　　　　　　　　　　　蔡鸿于南开大学软件学院</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: right" class="MsoNormal" align="right"><span style="font-family: 宋体">　　　　　　　　　　　　　　　　　　　　　　　　　　　</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2007<span style="font-family: 宋体"><span>年</span></span>6<span style="font-family: 宋体"><span>月</span></span>9<span style="font-family: 宋体"><span>日</span></span></span></p><span style="text-align: justify; font-size: 10.5pt; font-family: 'Times New Roman'; color: #303030"><br /></span><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">原文地址：</span><span>http://theory.stanford.edu/~amitp/GameProgramming/</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">相关链接：</span><span>http://www-cs-students.stanford.edu/%7Eamitp/gameprog.html#Paths</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>&nbsp;</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">我们尝试解决的问题是把一个游戏对象（</span><span>game object</span><span style="font-family: 宋体">）从出发点移动到目的地。路径搜索</span><span>(Pathfinding)</span><span style="font-family: 宋体">的目标是找到一条好的路径&mdash;&mdash;避免障碍物、敌人，并把代价（燃料，时间，距离，装备，金钱等）最小化。运动（</span><span>Movement</span><span style="font-family: 宋体">）的目标是找到一条路径并且沿着它行进。把关注的焦点仅集中于其中的一种方法是可能的。一种极端情况是，当游戏对象开始移动时，一个老练的路径搜索器（</span><span>pathfinder</span><span style="font-family: 宋体">）外加一个琐细的运动算法（</span><span>movement algorithm</span><span style="font-family: 宋体">）可以找到一条路径，游戏对象将会沿着该路径移动而忽略其它的一切。另一种极端情况是，一个单纯的运动系统（</span><span>movement-only system</span><span style="font-family: 宋体">）将不会搜索一条路径（最初的&ldquo;路径&rdquo;将被一条直线取代），取而代之的是在每一个结点处仅采取一个步骤，同时考虑周围的环境。同时使用路径搜索</span><span>(Pathfinding)</span><span style="font-family: 宋体">和运动算法（</span><span>movement algorithm</span><span style="font-family: 宋体">）将会得到最好的效果。</span><span></span></p><span style="text-align: justify; font-size: 10.5pt; line-height: 17.5px; font-family: 'Times New Roman'; color: #303030"><br /></span><p style="font-size: 13px; line-height: 16.25px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>&nbsp;</span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>1&nbsp;<span style="font-family: 宋体"><span>导言</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>1.1<span style="font-family: 宋体">&nbsp;</span><span style="font-family: 宋体"><span>算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>1.2<span style="font-family: 宋体">&nbsp;Dijkstra</span><span style="font-family: 宋体"><span>算法与最佳优先搜索</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>1.3<span style="font-family: 宋体">&nbsp;A*</span><span style="font-family: 宋体"><span>算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>2&nbsp;<span style="font-family: 宋体"><span>启发式算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>2.1<span style="font-family: 宋体">&nbsp;A*</span><span style="font-family: 宋体"><span>对启发式函数的使用</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>2.2<span style="font-family: 宋体">&nbsp;</span><span style="font-family: 宋体"><span>速度还是精确度？</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>2.3<span style="font-family: 宋体">&nbsp;</span><span style="font-family: 宋体"><span>衡量单位</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>2.4<span style="font-family: 宋体">&nbsp;</span><span style="font-family: 宋体"><span>精确的启发式函数</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.4.1&nbsp;<span style="font-family: 宋体"><span>预计算的精确启发式函数</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.4.2&nbsp;<span style="font-family: 宋体"><span>线性精确启发式算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>2.5<span style="font-family: 宋体">&nbsp;</span><span style="font-family: 宋体"><span>网格地图中的启发式算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.1&nbsp;<span style="font-family: 宋体"><span>曼哈顿距离</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.2&nbsp;<span style="font-family: 宋体"><span>对角线距离</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.3&nbsp;<span style="font-family: 宋体"><span>欧几里得距离</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.4&nbsp;<span style="font-family: 宋体"><span>平方后的欧几里得距离</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.5 Breaking ties</span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>2.5.6&nbsp;<span style="font-family: 宋体"><span>区域搜索</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>3 Implementation notes</span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>3.1&nbsp;<span style="font-family: 宋体"><span>概略</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>3.2&nbsp;<span style="font-family: 宋体"><span>源代码</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>3.3&nbsp;<span style="font-family: 宋体"><span>集合的表示</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.1&nbsp;<span style="font-family: 宋体"><span>未排序数组或链表</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.2&nbsp;<span style="font-family: 宋体"><span>排序数组</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.3&nbsp;<span style="font-family: 宋体"><span>排序链表</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.4&nbsp;<span style="font-family: 宋体"><span>排序跳表</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.5&nbsp;<span style="font-family: 宋体"><span>索引数组</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.6&nbsp;<span style="font-family: 宋体"><span>哈希表</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.7&nbsp;<span style="font-family: 宋体"><span>二元堆</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.8&nbsp;<span style="font-family: 宋体"><span>伸展树</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.9 HOT<span style="font-family: 宋体"><span>队列</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.10&nbsp;<span style="font-family: 宋体"><span>比较</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.3.11&nbsp;<span style="font-family: 宋体"><span>混合实现</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>3.4&nbsp;<span style="font-family: 宋体"><span>与游戏循环的交互</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.4.1&nbsp;<span style="font-family: 宋体"><span>提前退出</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.4.2&nbsp;<span style="font-family: 宋体"><span>中断算法</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.4.3&nbsp;<span style="font-family: 宋体"><span>组运动</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>3.4.4&nbsp;<span style="font-family: 宋体"><span>细化</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>4 A*<span style="font-family: 宋体"><span>算法的变种</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.1 beam search</span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.2&nbsp;<span style="font-family: 宋体"><span>迭代深化</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.3&nbsp;<span style="font-family: 宋体"><span>动态衡量</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.4&nbsp;<span style="font-family: 宋体"><span>带宽搜索</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.5&nbsp;<span style="font-family: 宋体"><span>双向搜索</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>4.6&nbsp;<span style="font-family: 宋体"><span>动态</span></span>A*<span style="font-family: 宋体"><span>与终身计划</span></span>A*</span></span><span></span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>5&nbsp;<span style="font-family: 宋体"><span>处理运动障碍物</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>5.1&nbsp;<span style="font-family: 宋体"><span>重新计算路径</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>5.2&nbsp;<span style="font-family: 宋体"><span>路径拼接</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>5.3&nbsp;<span style="font-family: 宋体"><span>监视地图变化</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>5.4&nbsp;<span style="font-family: 宋体"><span>预测障碍物的运动</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc1"><span class="MsoHyperlink"><span>6&nbsp;<span style="font-family: 宋体"><span>预计算路径的空间代价</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>6.1&nbsp;<span style="font-family: 宋体"><span>位置</span></span>VS<span style="font-family: 宋体"><span>方向</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>6.2&nbsp;<span style="font-family: 宋体"><span>路径压缩</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>6.2.1&nbsp;<span style="font-family: 宋体"><span>位置存储</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc3"><span class="MsoHyperlink"><span>6.2.2&nbsp;<span style="font-family: 宋体"><span>方向存储</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>6.3&nbsp;<span style="font-family: 宋体"><span>计算导航点</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>6.4&nbsp;<span style="font-family: 宋体"><span>极限路径长度</span></span></span></span><span></span></p><p style="margin: 0cm 0cm 0pt 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify" class="MsoToc2"><span class="MsoHyperlink"><span>6.5&nbsp;<span style="font-family: 宋体"><span>总结</span></span></span></span><span></span></p><strong style="color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-size: 22pt; line-height: 36.6667px; font-family: 'Times New Roman'"><br /></span></strong><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180937"></a><span style="font-size: 12pt">1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">导言</span><span style="font-size: 12pt"></span></h1><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　</span><span style="font-family: 宋体">移动一个简单的物体（<span>object</span>）看起来是容易的。而路径搜索是复杂的。为什么涉及到路径搜索就产生麻烦了？考虑以下情况：<span></span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　</span><span style="font-family: 宋体">物体（<span>unit</span>）最初位于地图的底端并且尝试向顶部移动。物体扫描的区域中<span>(</span>粉红色部分<span>)</span>没有任何东西显示它不能向上移动，因此它持续向上移动。在靠近顶部时，它探测到一个障碍物然后改变移动方向。然后它沿着<span>U</span>形障碍物找到它的红色的路径。相反的，一个路径搜索器（<span>pathfinder</span>）将会扫描一个更大的区域（淡蓝色部分），但是它能做到不让物体<span>(unit)</span>走向凹形障碍物而找到一条更短的路径<span>(</span>蓝色路径）。<span></span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　然而你可以扩展一个运动算法，用于对付上图所示的障碍物。或者避免制造凹形障碍，或者把凹形出口标识为危险的<span>(</span>只有当目的地在里面时才进去<span>):</span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　比起一直等到最后一刻才发现问题，路径搜索器让你提前作出计划。不带路径搜索的运动</span><span>(movement)</span><span style="font-family: 宋体">可以在很多种情形下工作，同时可以扩展到更多的情形，但是路径搜索是一种更常用的解决更多问题的方法。</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180938"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">1.1</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">算法</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　计算机科学教材中的路径搜索算法在数学视角的图上工作&mdash;&mdash;由边联结起来的结点的集合。一个基于图块</span><span>(tile)</span><span style="font-family: 宋体">拼接的游戏地图可以看成是一个图，每个图块</span><span>(tile)</span><span style="font-family: 宋体">是一个结点，并在每个图块之间画一条边：</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　目前，我会假设我们使用二维网格</span><span>(grid)</span><span style="font-family: 宋体">。稍后我将讨论如何在你的游戏之外建立其他类型的图。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　许多</span><span>AI</span><span style="font-family: 宋体">领域或算法研究领域中的路径搜索算法是基于任意</span><span>(arbitrary)</span><span style="font-family: 宋体">的图设计的，而不是基于网格</span><span>(grid-based)</span><span style="font-family: 宋体">的图。我们可以找到一些能使用网格地图的特性的东西。有一些我们认为是常识，而算法并不理解。例如，我们知道一些和方向有关的东西：一般而言，如果两个物体距离越远，那么把其中一个物体向另一个移动将花越多的时间；并且我们知道地图中没有任何秘密通道可以从一个地点通向另一个地点。（我假设没有，如果有的话，将会很难找到一条好的路径，因为你并不知道要从何处开始。）</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180939"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">1.2</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;Dijkstra</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">算法与最佳优先搜索</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="margin: 10px auto; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-size: 10.5pt; color: black"><span style="font-family: 宋体">　　<span>Dijkstra</span>算法从物体所在的初始点开始，访问图中的结点。它迭代检查待检查结点集中的结点，并把和该结点最靠近的尚未检查的结点加入待检查结点集。该结点集从初始结点向外扩展，直到到达目标结点。<span>Dijkstra</span>算法保证能找到一条从初始点到目标点的最短路径，只要所有的边都有一个非负的代价值。（我说&ldquo;最短路径&rdquo;是因为经常会出现许多差不多短的路径。）在下图中，粉红色的结点是初始结点，蓝色的是目标点，而类菱形的有色区域（注：原文是<span>teal areas</span>）则是<span>Dijkstra</span>算法扫描过的区域。颜色最淡的区域是那些离初始点最远的，因而形成探测过程（<span>exploration</span>）的边境（<span>frontier</span>）：<span></span></span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="margin: 10px auto; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-size: 10.5pt; color: black"><span style="font-family: 宋体">　　最佳优先搜索（<span>BFS</span>）算法按照类似的流程运行，不同的是它能够评估（称为启发式的）任意结点到目标点的代价。与选择离初始结点最近的结点不同的是，它选择离目标最近的结点。<span>BFS</span>不能保证找到一条最短路径。然而，它比<span>Dijkstra</span>算法快的多，因为它用了一个启发式函数（<span>heuristic function</span>）快速地导向目标结点。例如，如果目标位于出发点的南方，<span>BFS</span>将趋向于导向南方的路径。在下面的图中，越黄的结点代表越高的启发式值（移动到目标的代价高），而越黑的结点代表越低的启发式值（移动到目标的代价低）。这表明了与<span>Dijkstra&nbsp;</span>算法相比，<span>BFS</span>运行得更快。<span></span></span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="margin: 10px auto; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-size: 10.5pt; color: black"><span style="font-family: 宋体">　　然而，这两个例子都仅仅是最简单的情况&mdash;&mdash;地图中没有障碍物，最短路径是直线的。现在我们来考虑前边描述的凹型障碍物。<span>Dijkstra</span>算法运行得较慢，但确实能保证找到一条最短路径：<span></span></span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">　　另一方面，</span><span style="color: black">BFS</span><span style="font-family: 宋体; color: black">运行得较快，但是它找到的路径明显不是一条好的路径：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="margin: 10px auto; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-size: 10.5pt; color: black"><span style="font-family: 宋体">　　问题在于<span>BFS</span>是基于贪心策略的，它试图向目标移动尽管这不是正确的路径。由于它仅仅考虑到达目标的代价，而忽略了当前已花费的代价，于是尽管路径变得很长，它仍然继续走下去。<span></span></span></span></p><p style="margin: 10px auto; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><span style="font-family: 宋体"><span style="font-size: 10.5pt">　　结合两者的优点不是更好吗？<span>1968</span>年发明的<span>A*</span>算法就是把启发式方法（<span>heuristic approaches</span>）如<span>BFS</span>，和常规方法如<span>Dijsktra</span>算法结合在一起的算法。有点不同的是，类似<span>BFS</span>的启发式方法经常给出一个近似解而不是保证最佳解。然而，尽管<span>A*</span>基于无法保证最佳解的启发式方法，<span>A*</span>却能保证找到一条最短路径。</span><span style="font-size: 10.5pt"></span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180940"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">1.3</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;A*</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">算法</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　我将集中讨论</span><span>A*</span><span style="font-family: 宋体">算法。</span><span>A*</span><span style="font-family: 宋体">是路径搜索中最受欢迎的选择，因为它相当灵活，并且能用于多种多样的情形之中。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　和其它的图搜索算法一样，</span><span>A*</span><span style="font-family: 宋体">潜在地搜索图中一个很大的区域。和</span><span>Dijkstra</span><span style="font-family: 宋体">一样，</span><span>A*</span><span style="font-family: 宋体">能用于搜索最短路径。和</span><span>BFS</span><span style="font-family: 宋体">一样，</span><span>A*</span><span style="font-family: 宋体">能用启发式函数（注：原文为</span><span>heuristic</span><span style="font-family: 宋体">）引导它自己。在简单的情况中，它和</span><span>BFS</span><span style="font-family: 宋体">一样快。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　在凹型障碍物的例子中，</span><span>A*</span><span style="font-family: 宋体">找到一条和</span><span>Dijkstra</span><span style="font-family: 宋体">算法一样好的路径：</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　成功的秘决在于，它把</span><span>Dijkstra</span><span style="font-family: 宋体">算法（靠近初始点的结点）和</span><span>BFS</span><span style="font-family: 宋体">算法（靠近目标点的结点）的信息块结合起来。在讨论</span><span>A*</span><span style="font-family: 宋体">的标准术语中，</span><span>g(n)</span><span style="font-family: 宋体">表示从初始结点到任意结点</span><span>n</span><span style="font-family: 宋体">的代价，</span><span>h(n)</span><span style="font-family: 宋体">表示从结点</span><span>n</span><span style="font-family: 宋体">到目标点的启发式评估代价（</span><span>heuristic estimated cost</span><span style="font-family: 宋体">）。在上图中，</span><span>yellow(h)</span><span style="font-family: 宋体">表示远离目标的结点而</span><span>teal(g)</span><span style="font-family: 宋体">表示远离初始点的结点。当从初始点向目标点移动时，</span><span>A*</span><span style="font-family: 宋体">权衡这两者。每次进行主循环时，它检查</span><span>f(n)</span><span style="font-family: 宋体">最小的结点</span><span>n</span><span style="font-family: 宋体">，其中</span><span>f(n) = g(n) + h(n)</span><span style="font-family: 宋体">。</span><span></span></p><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180941"></a><span style="font-size: 12pt">2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">启发式算法</span><span style="font-size: 12pt"></span></h1><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　启发式函数</span><span>h(n)</span><span style="font-family: 宋体">告诉</span><span>A*</span><span style="font-family: 宋体">从任意结点</span><span>n</span><span style="font-family: 宋体">到目标结点的最小代价评估值。选择一个好的启发式函数是重要的。</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180942"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">2.1</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;A*</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">对启发式函数的使用</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　启发式函数可以控制</span><span>A*</span><span style="font-family: 宋体">的行为：</span><span></span></p><ul style="margin-left: 30px; padding-left: 0px; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体; color: windowtext">一种极端情况，如果</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">是</span><span style="color: windowtext">0</span><span style="font-family: 宋体; color: windowtext">，则只有</span><span style="color: windowtext">g(n)</span><span style="font-family: 宋体; color: windowtext">起作用，此时</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">演变成</span><span style="color: windowtext">Dijkstra</span><span style="font-family: 宋体; color: windowtext">算法，这保证能找到最短路径。</span><span style="font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体; color: windowtext">如果</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">经常都比从</span><span style="color: windowtext">n</span><span style="font-family: 宋体; color: windowtext">移动到目标的实际代价小（或者相等），则</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">保证能找到一条最短路径。</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">越小，</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">扩展的结点越多，运行就得越慢。</span><span style="font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体; color: windowtext">如果</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">精确地等于从</span><span style="color: windowtext">n</span><span style="font-family: 宋体; color: windowtext">移动到目标的代价，则</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">将会仅仅寻找最佳路径而不扩展别的任何结点，这会运行得非常快。尽管这不可能在所有情况下发生，你仍可以在一些特殊情况下让它们精确地相等（译者：指让</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">精确地等于实际值）。只要提供完美的信息，</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">会运行得很完美，认识这一点很好。</span><span style="font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体; color: windowtext">如果</span><span style="color: windowtext">h(n)</span><span style="font-family: 宋体; color: windowtext">有时比从</span><span style="color: windowtext">n</span><span style="font-family: 宋体; color: windowtext">移动到目标的实际代价高，则</span><span style="color: windowtext">A*</span><span style="font-family: 宋体; color: windowtext">不能保证找到一条最短路径，但它运行得更快。</span><span style="font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; text-align: left"><span style="font-family: 宋体">另一种极端情况，如果</span><span>h(n)</span><span style="font-family: 宋体">比</span><span>g(n)</span><span style="font-family: 宋体">大很多，则只有</span><span>h(n)</span><span style="font-family: 宋体">起作用，</span><span>A*</span><span style="font-family: 宋体">演变成</span><span>BFS</span><span style="font-family: 宋体">算法。</span><span></span></li></ul><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　所以我们得到一个很有趣的情况，那就是我们可以决定我们想要从</span><span>A*</span><span style="font-family: 宋体">中获得什么。理想情况下（注：原文为</span><span>At exactly the right point</span><span style="font-family: 宋体">），我们想最快地得到最短路径。如果我们的目标太低，我们仍会得到最短路径，不过速度变慢了；如果我们的目标太高，那我们就放弃了最短路径，但</span><span>A*</span><span style="font-family: 宋体">运行得更快。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">在游戏中，</span><span>A*</span><span style="font-family: 宋体">的这个特性非常有用。例如，你会发现在某些情况下，你希望得到一条好的路径（</span><span>&quot;good&quot; path</span><span style="font-family: 宋体">）而不是一条完美的路径（</span><span>&quot;perfect&quot; path</span><span style="font-family: 宋体">）。为了权衡</span><span>g(n)</span><span style="font-family: 宋体">和</span><span>h(n)</span><span style="font-family: 宋体">，你可以修改任意一个。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">注</span><strong><span>:</span></strong><span style="font-family: 宋体">在学术上，如果启发式函数值是对实际代价的低估，</span><span>A*</span><span style="font-family: 宋体">算法被称为简单的</span><span>A</span><span style="font-family: 宋体">算法（原文为</span><span>simply A</span><span style="font-family: 宋体">）。然而，我继续称之为</span><span>A*</span><span style="font-family: 宋体">，因为在实现上是一样的，并且在游戏编程领域并不区别</span><span>A</span><span style="font-family: 宋体">和</span><span>A*</span><span style="font-family: 宋体">。</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180943"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">2.2</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">速度还是精确度？</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　</span><span>A*</span><span style="font-family: 宋体">改变它自己行为的能力基于启发式代价函数，启发式函数在游戏中非常有用。在速度和精确度之间取得折衷将会让你的游戏运行得更快。在很多游戏中，你并不真正需要得到最好的路径，仅需要近似的就足够了。而你需要什么则取决于游戏中发生着什么，或者运行游戏的机器有多快。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　假设你的游戏有两种地形，平原和山地，在平原中的移动代价是</span><span>1</span><span style="font-family: 宋体">而在山地则是</span><span>3</span><span style="font-family: 宋体">。</span><span>A* is going to search three times as far along flat land as it does along mountainous land.&nbsp;</span><span style="font-family: 宋体">这是因为有可能有一条沿着平原到山地的路径。把两个邻接点之间的评估距离设为</span><span>1.5</span><span style="font-family: 宋体">可以加速</span><span>A*</span><span style="font-family: 宋体">的搜索过程。然后</span><span>A*</span><span style="font-family: 宋体">会将</span><span>3</span><span style="font-family: 宋体">和</span><span>1.5</span><span style="font-family: 宋体">比较，这并不比把</span><span>3</span><span style="font-family: 宋体">和</span><span>1</span><span style="font-family: 宋体">比较差。</span><span>It is not as dissatisfied with mountainous terrain, so it won't spend as much time trying to find a way around it. Alternatively, you can speed up up A*'s search by decreasing the amount it searches for paths around mountains―just tell A* that the movement cost on mountains is 2 instead of 3. Now it will search only twice as far along the flat terrain as along mountainous terrain. Either approach gives up ideal paths to get something quicker.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">速度和精确度之间的选择前不是静态的。你可以基于</span><span>CPU</span><span style="font-family: 宋体">的速度、用于路径搜索的时间片数、地图上物体（</span><span>units</span><span style="font-family: 宋体">）的数量、物体的重要性、组（</span><span>group</span><span style="font-family: 宋体">）的大小、难度或者其他任何因素来进行动态的选择。取得动态的折衷的一个方法是，建立一个启发式函数用于假定通过一个网格空间的最小代价是</span><span>1</span><span style="font-family: 宋体">，然后建立一个代价函数（</span><span>cost function</span><span style="font-family: 宋体">）用于测量（</span><span>scales</span><span style="font-family: 宋体">）：</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>g&rsquo;(n) = 1 + alpha * ( g(n) &ndash; 1&nbsp;</span><span style="color: black">)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　如果</span><span>alpha</span><span style="font-family: 宋体">是</span><span>0</span><span style="font-family: 宋体">，则改进后的代价函数的值总是</span><span>1</span><span style="font-family: 宋体">。这种情况下，地形代价被完全忽略，</span><span>A*</span><span style="font-family: 宋体">工作变成简单地判断一个网格可否通过。如果</span><span>alpha</span><span style="font-family: 宋体">是</span><span>1</span><span style="font-family: 宋体">，则最初的代价函数将起作用，然后你得到了</span><span>A*</span><span style="font-family: 宋体">的所有优点。你可以设置</span><span>alpha</span><span style="font-family: 宋体">的值为</span><span>0</span><span style="font-family: 宋体">到</span><span>1</span><span style="font-family: 宋体">的任意值。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　你也可以考虑对启发式函数的返回值做选择：绝对最小代价或者期望最小代价。例如，如果你的地图大部分地形是代价为</span><span>2</span><span style="font-family: 宋体">的草地，其它一些地方是代价为</span><span>1</span><span style="font-family: 宋体">的道路，那么你可以考虑让启发式函数不考虑道路，而只返回</span><span>2*</span><span style="font-family: 宋体">距离。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　速度和精确度之间的选择并不是全局的。在地图上的某些区域，精确度是重要的，你可以基于此进行动态选择。例如，假设我们可能在某点停止重新计算路径或者改变方向，则在接近当前位置的地方，选择一条好的路径则是更重要的，因此为何要对后续路径的精确度感到厌烦？或者，对于在地图上的一个安全区域，最短路径也许并不十分重要，但是当从一个敌人的村庄逃跑时，安全和速度是最重要的。（译者注：译者认为这里指的是，在安全区域，可以考虑不寻找精确的最短路径而取近似路径，因此寻路快；但在危险区域，逃跑的安全性和逃跑速度是重要的，即路径的精确度是重要的，因此可以多花点时间用于寻找精确路径。）</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180944"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">2.3</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">衡量单位</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 10.5pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　</span><span>A*</span><span style="font-family: 宋体">计算</span><span>f(n) = g(n) + h(n)</span><span style="font-family: 宋体">。为了对这两个值进行相加，这两个值必须使用相同的衡量单位。如果</span><span>g(n)</span><span style="font-family: 宋体">用小时来衡量而</span><span>h(n)</span><span style="font-family: 宋体">用米来衡量，那么</span><span>A*</span><span style="font-family: 宋体">将会认为</span><span>g</span><span style="font-family: 宋体">或者</span><span>h</span><span style="font-family: 宋体">太大或者太小，因而你将不能得到正确的路径，同时你的</span><span>A*</span><span style="font-family: 宋体">算法将运行得更慢。</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180945"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">2.4</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">精确的启发式函数</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　如果你的启发式函数精确地等于实际最佳路径（</span><span>optimal path</span><span style="font-family: 宋体">），如下一部分的图中所示，你会看到此时</span><span>A*</span><span style="font-family: 宋体">扩展的结点将非常少。</span><span>A*</span><span style="font-family: 宋体">算法内部发生的事情是：在每一结点它都计算</span><span>f(n) = g(n) + h(n)</span><span style="font-family: 宋体">。当</span><span>h(n)</span><span style="font-family: 宋体">精确地和</span><span>g(n)</span><span style="font-family: 宋体">匹配（译者注：原文为</span><span>match</span><span style="font-family: 宋体">）时，</span><span>f(n)</span><span style="font-family: 宋体">的值在沿着该路径时将不会改变。不在正确路径（</span><span>right path</span><span style="font-family: 宋体">）上的所有结点的</span><span>f</span><span style="font-family: 宋体">值均大于正确路径上的</span><span>f</span><span style="font-family: 宋体">值（译者注：正确路径在这里应该是指最短路径）。如果已经有较低</span><span>f</span><span style="font-family: 宋体">值的结点，</span><span>A*</span><span style="font-family: 宋体">将不考虑</span><span>f</span><span style="font-family: 宋体">值较高的结点，因此它肯定不会偏离最短路径。</span><span></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180946"></a><span style="font-size: 12pt">2.4.1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">预计算的精确启发式函数</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　构造精确启发函数的一种方法是预先计算任意一对结点之间最短路径的长度。在许多游戏的地图中这并不可行。然后，有几种方法可以近似模拟这种启发函数：</span><span></span></p><ul style="margin-left: 30px; padding-left: 0px; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span>Fit a coarse grid on top of the fine grid. Precompute the shortest path between any pair of coarse grid locations.</span><span></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span>Precompute the shortest path between any pair of&nbsp;<a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://theory.stanford.edu/~amitp/GameProgramming/David_Hilbert  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://theory.stanford.edu/~amitp/GameProgramming/David_Hilbert#S9'" tppabs="http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html#S9"><span style="color: black">waypoints</span></a>. This is a generalization of the coarse grid approach.</span><span style="font-size: 12pt; font-family: 宋体"></span></li></ul><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　</span><span style="font-family: 宋体; color: black">（译者：此处不好翻译，暂时保留原文）</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">然后添加一个启发函数</span><span>h&rsquo;</span><span style="font-family: 宋体">用于评估从任意位置到达邻近导航点（</span><span>waypoints</span><span style="font-family: 宋体">）的代价。（如果愿意，后者也可以通过预计算得到。）最终的启发式函数可以是：</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 10.5pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>h(n) = h'(n, w1) + distance(w1, w2), h'(w2, goal)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">或者如果你希望一个更好但是更昂贵的启发式函数，则分别用靠近结点和目标的所有的</span><span>w1,w2</span><span style="font-family: 宋体">对对上式进行求值。（译者注：原文为</span><span>or if you want a better but more expensive heuristic, evaluate the above with all pairs w1, w2 that are close to the node and the goal, respectively.</span><span style="font-family: 宋体">）</span><span></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180947"></a><span style="font-size: 12pt">2.4.2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">线性精确启发式算法</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　在特殊情况下，你可以不通过预计算而让启发式函数很精确。如果你有一个不存在障碍物和</span><span>slow</span><span style="font-family: 宋体">地形，那么从初始点到目标的最短路径应该是一条直线。</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　如果你正使用简单的启发式函数（我们不知道地图上的障碍物），则它应该和精确的启发式函数相符合（译者注：原文为</span><span>match</span><span style="font-family: 宋体">）。如果不是这样，则你会遇到衡量单位的问题，或者你所选择的启发函数类型的问题。</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180948"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">2.5</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">网格地图中的启发式算法</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">　　在网格地图中，有一些众所周知的启发式函数。</span><span></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180949"></a><span style="font-size: 12pt">2.5.1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">曼哈顿距离</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体">标准的启发式函数是曼哈顿距离（</span><span>Manhattan distance</span><span style="font-family: 宋体">）。考虑你的代价函数并找到从一个位置移动到邻近位置的最小代价</span><span>D</span><span style="font-family: 宋体">。因此，我的游戏中的启发式函数应该是曼哈顿距离的</span><span>D</span><span style="font-family: 宋体">倍：</span><span></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H(n) = D * (abs ( n.x &ndash; goal.x ) + abs ( n.y &ndash; goal.y ) )</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">你应该使用符合你的代价函数的衡量单位。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">(Note: the above image has a&nbsp;<a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://theory.stanford.edu/~amitp/GameProgramming/Hilbert\'s_tenth_problem  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://theory.stanford.edu/~amitp/GameProgramming/Hilbert\'s_tenth_problem#S12'" tppabs="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S12"><span style="color: black">tie-breaker</span></a>&nbsp;added to the heuristic.&#125;</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">（译者注：曼哈顿距离</span><span style="color: black">&mdash;&mdash;</span><span style="font-family: 宋体; color: black">两点在南北方向上的距离加上在东西方向上的距离，即</span><span style="color: black">D</span><span style="font-family: 宋体; color: black">（</span><span style="color: black">I</span><span style="font-family: 宋体; color: black">，</span><span style="color: black">J</span><span style="font-family: 宋体; color: black">）</span><span style="color: black">=&#124;XI-XJ&#124;+&#124;YI-YJ&#124;</span><span style="font-family: 宋体; color: black">。对于一个具有正南正北、正东正西方向规则布局的城镇街道，从一点到达另一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离因此曼哈顿距离又称为出租车距离，曼哈顿距离不是距离不变量，当坐标轴变动时，点间的距离就会不同</span><span style="color: black">&mdash;&mdash;</span><span style="font-family: 宋体; color: black">百度知道）</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180950"></a><span style="font-size: 12pt">2.5.2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">对角线距离</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果在你的地图中你允许对角运动那么你需要一个不同的启发函数。（</span><span style="color: black">4 east, 4 north</span><span style="font-family: 宋体; color: black">）的</span><span style="font-family: 宋体">曼哈顿距离将变成</span><span>8*D</span><span style="font-family: 宋体">。然而，你可以简单地移动（</span><span>4 northeast</span><span style="font-family: 宋体">）代替，所以启发函数应该是</span><span>4*D</span><span style="font-family: 宋体">。这个函数使用对角线，假设直线和对角线的代价都是</span><span>D</span><span style="font-family: 宋体">：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h(n) = D * max(abs(n.x - goal.x), abs(n.y - goal.y))</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果对角线运动的代价不是</span><span style="color: black">D</span><span style="font-family: 宋体; color: black">，但类似于</span><span style="color: black">D2 = sqrt(2) * D</span><span style="font-family: 宋体; color: black">，则上面的启发函数不准确。你需要一些更准确（原文为</span><span style="color: black">sophisticated</span><span style="font-family: 宋体; color: black">）的东西：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h_diagonal(n) = min(abs(n.x - goal.x), abs(n.y - goal.y))</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h_straight(n) = (abs(n.x - goal.x) + abs(n.y - goal.y))</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h(n) = D2 * h_diagonal(n) + D * (h_straight(n) - 2*h_diagonal(n)))</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">这里，我们计算</span><span>h_diagonal(n)</span><span style="font-family: 宋体">：沿着斜线可以移动的步数；</span><span>h_straight(n)</span><span style="font-family: 宋体">：曼哈顿距离；然后合并这两项，让所有的斜线步都乘以</span><span>D2</span><span style="font-family: 宋体">，剩下的所有直线步</span><span style="color: black">(</span><span style="font-family: 宋体; color: black">注意这里是曼哈顿距离的步数减去</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">倍的斜线步数</span><span style="color: black">)</span><span style="font-family: 宋体">都乘以</span><span>D</span><span style="font-family: 宋体">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180951"></a><span style="font-size: 12pt">2.5.3&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">欧几里得距离</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果你的单位可以沿着任意角度移动（而不是网格方向），那么你也许应该使用直线距离：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h(n) = D * sqrt((n.x-goal.x)^2 + (n.y-goal.y)^2)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">然而，如果是这样的话，直接使用</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">时将会遇到麻烦，因为代价函数</span><span style="color: black">g</span><span style="font-family: 宋体; color: black">不会</span><span style="color: black">match</span><span style="font-family: 宋体; color: black">启发函数</span><span style="color: black">h</span><span style="font-family: 宋体; color: black">。因为欧几里得距离比曼哈顿距离和对角线距离都短，你仍可以得到最短路径，不过</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">将运行得更久一些：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black"></span><span></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180952"></a><span style="font-size: 12pt">2.5.4&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">平方后的欧几里得距离</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">我曾经看到一些</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的网页，其中提到让你通过使用距离的平方而避免欧几里得距离中昂贵的平方根运算：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">h(n) = D * ((n.x-goal.x)^2 + (n.y-goal.y)^2)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">不要这样做！这明显地导致衡量单位的问题。当</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">计算</span><span style="color: black">f(n) = g(n) + h(n)</span><span style="font-family: 宋体; color: black">，距离的平方将比</span><span style="color: black">g</span><span style="font-family: 宋体; color: black">的代价大很多，并且你会因为启发式函数评估值过高而停止。对于更长的距离，这样做会靠近</span><span style="color: black">g(n)</span><span style="font-family: 宋体; color: black">的极端情况而不再计算任何东西，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">退化成</span><span style="color: black">BFS</span><span style="font-family: 宋体; color: black">：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180953"></a><span style="font-size: 12pt">2.5.5 Breaking ties</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">导致低性能的一个原因来自于启发函数的</span><span style="color: black">ties</span><span style="font-family: 宋体; color: black">（注：这个词实在不知道应该翻译为什么）。当某些路径具有相同的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值的时候，它们都会被搜索（</span><span style="color: black">explored</span><span style="font-family: 宋体; color: black">），尽管我们只需要搜索其中的一条：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"><br /></span><span style="color: black">Ties in f values.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">为了解决这个问题，我们可以为启发函数添加一个附加值（译者注：原文为</span><span style="color: black">small tie breaker</span><span style="font-family: 宋体; color: black">）。附加值对于结点必须是确定性的（也就是说，不能是随机的数），而且它必须让</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值体现区别。因为</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">对</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值排序，让</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值不同意味着只有一个</span><span style="color: black">&quot;equivalent&quot;</span><span style="font-family: 宋体; color: black">的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值会被检测。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一种添加附加值的方式是稍微改变（译者注：原文为</span><span style="color: black">nudge</span><span style="font-family: 宋体; color: black">）</span><span style="color: black">h</span><span style="font-family: 宋体; color: black">的衡量单位。如果我们减少衡量单位（译者注：原文为</span><span style="color: black">scale it downwards</span><span style="font-family: 宋体; color: black">），那么当我们朝着目标移动的时候</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">将逐渐增加。很不幸，这意味着</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。我们可以增加衡量单位（译者注：原文为</span><span style="color: black">scale it downwards scale h upwards slightly</span><span style="font-family: 宋体; color: black">）（甚至是</span><span style="color: black">0.1%</span><span style="font-family: 宋体; color: black">），</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">就会倾向于扩展到靠近目标的结点。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">heuristic *= (1.0 + p)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">选择因子</span><span style="color: black">p</span><span style="font-family: 宋体; color: black">使得</span><span style="color: black">p &lt;&nbsp;</span><span style="font-family: 宋体; color: black">移动一步（</span><span style="color: black">step</span><span style="font-family: 宋体; color: black">）的最小代价</span><span style="color: black">&nbsp;/&nbsp;</span><span style="font-family: 宋体; color: black">期望的最长路径长度。假设你不希望你的路径超过</span><span style="color: black">1000</span><span style="font-family: 宋体; color: black">步（</span><span style="color: black">step</span><span style="font-family: 宋体; color: black">），你可以使</span><span style="color: black">p = 1 / 1000</span><span style="font-family: 宋体; color: black">。添加这个附加值的结果是，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">比以前搜索的结点更少了。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"><br /></span><span style="color: black">Tie-breaking scaling added to heuristic.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">当存在障碍物时，当然仍要在它们周围寻找路径，但要意识到，当绕过障碍物以后，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">搜索的区域非常少：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"><br /></span><span style="color: black">Tie-breaking scaling added to heuristic, works nicely with obstacles.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">Steven van Dijk</span><span style="font-family: 宋体; color: black">建议，一个更直截了当的方法是把</span><span style="color: black">h</span><span style="font-family: 宋体; color: black">传递到比较函数（</span><span style="color: black">comparison function</span><span style="font-family: 宋体; color: black">）。当</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值相等时，比较函数检查</span><span style="color: black">h</span><span style="font-family: 宋体; color: black">，然后添加附加值。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一个不同的添加附加值的方法是，倾向于从初始点到目标点的连线（直线）：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">dx1 = current.x - goal.x</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">dy1 = current.y - goal.y</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">dx2 = start.x - goal.x</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">dy2 = start.y - goal.y</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">cross = abs(dx1*dy2 - dx2*dy1)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">heuristic += cross*0.001</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">这段代码计算初始</span><span style="color: black">-</span><span style="font-family: 宋体; color: black">目标向量（</span><span style="color: black">start to goal vector</span><span style="font-family: 宋体; color: black">）和当前</span><span style="color: black">-</span><span style="font-family: 宋体; color: black">目标向量（</span><span style="color: black">current point to goal vector</span><span style="font-family: 宋体; color: black">）的向量叉积（</span><span style="color: black">vector cross-product</span><span style="font-family: 宋体; color: black">）。</span><span style="color: black">When these vectors don't line up, the cross product will be larger.</span><span style="font-family: 宋体; color: black">结果是，这段代码选择的路径稍微倾向于从初始点到目标点的直线。当没有障碍物时，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">不仅搜索很少的区域，而且它找到的路径看起来非常棒：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"><br /></span><span style="color: black">Tie-breaking cross-product added to heuristic, produces pretty paths.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">然而，因为这种附加值倾向于从初始点到目标点的直线路径，当出现障碍物时将会出现奇怪的结果（注意这条路径仍是最佳的，只是看起来很奇怪）：</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"><br /></span><span style="color: black">Tie-breaking cross-product added to heuristic, less pretty with obstacles.</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">为了交互地研究这种附加值方法的改进，请参考</span><span style="color: black">James Macgill</span><span style="font-family: 宋体; color: black">的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">确</span><span style="color: black">applet</span><span style="font-family: 宋体; color: black">（</span><span style="color: black">http://www.ccg.leeds.ac.uk/james/aStar/&nbsp;</span><span style="font-family: 宋体; color: black">）</span><span style="color: black">[</span><span style="font-family: 宋体; color: black">如果链接无效，请使用这个镜像（</span><span style="color: black">http://www.vision.ee.ethz.ch/~buc/astar/AStar.html</span><span style="font-family: 宋体; color: black">）</span><span style="color: black">]</span><span style="font-family: 宋体; color: black">（译者注：两个链接均无效）。使用&ldquo;</span><span style="color: black">Clear</span><span style="font-family: 宋体; color: black">&rdquo;以清除地图，选择地图对角的两个点。当你使用&ldquo;</span><span style="color: black">Classic A*</span><span style="font-family: 宋体; color: black">&rdquo;方法，你会看到附加值的效果。当你使用&ldquo;</span><span style="color: black">Fudge</span><span style="font-family: 宋体; color: black">&rdquo;方法，你会看到上面给启发函数添加叉积后的效果。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">然而另一种添加附加值的方法是，小心地构造你的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">优先队列，使新插入的具有特殊</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值的结点总是比那些以前插入的具有相同</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值的旧结点要好一些。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">你也许也想看看能够更灵活地（译者注：原文为</span><span style="color: black">sophisticated</span><span style="font-family: 宋体; color: black">）添加附加值的</span><span style="color: black">AlphA*</span><span style="font-family: 宋体; color: black">算法（</span><span style="color: black">http://home1.stofanet.dk/breese/papers.html</span><span style="font-family: 宋体; color: black">），不过用这种算法得到的路径是否能达到最佳仍在研究中。</span><span style="color: black">AlphA*</span><span style="font-family: 宋体; color: black">具有较好的适应性，而且可能比我在上面讨论的附加值方法运行得都要好。然而，我所讨论的附加值方法非常容易实现，所以从它们开始吧，如果你需要得到更好的效果，再去尝试</span><span style="color: black">AlphA*</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180954"></a><span style="font-size: 12pt">2.5.6&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">区域搜索</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">　　如果你想搜索</span><span style="font-family: 宋体">邻</span><span style="font-family: 宋体; color: black">近目标的任意不确定结点，而不是某个特定的结点，你应该建立一个启发函数</span><span style="color: black">h&rsquo;(x)</span><span style="font-family: 宋体; color: black">，使得</span><span style="color: black">h&rsquo;(x)</span><span style="font-family: 宋体; color: black">为</span><span>h1(x), h2(x), h3(x)</span><span style="font-family: 宋体">。。。的最小值，而这些</span><span>h1, h2, h3</span><span style="font-family: 宋体">是邻近结点的启发函数。然而，一种更快的方法是让</span><span>A*</span><span style="font-family: 宋体">仅搜索目标区域的中心。一旦你从</span><span>OPEN</span><span style="font-family: 宋体">集合中取得任意一个邻近目标的结点，你就可以停止搜索并建立一条路径了。</span><span style="color: black"></span></p><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180955"></a><span style="font-size: 12pt">3 Implementation notes</span><span style="font-size: 12pt"></span></h1><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180956"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">3.1&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">概略</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">　　如果不考虑具体实现代码，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法是相当简单的。有两个集合，</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集。其中</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集保存待考查的结点。开始时，</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集只包含一个元素：初始结点。</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集保存已考查过的结点。开始时，</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集是空的。如果绘成图，</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集就是被访问区域的边境（</span><span style="color: black">frontier</span><span style="font-family: 宋体; color: black">）而</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集则是被访问区域的内部（</span><span style="color: black">interior</span><span style="font-family: 宋体; color: black">）。每个结点同时保存其父结点的指针因此我们可以知道它是如何被找到的。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">　　在主循环中重复地从</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中取出最好的结点</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">（</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值最小的结点）并检查之。如果</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">是目标结点，则我们的任务完成了。否则，结点</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">被从</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中删除并加入</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集。然后检查它的邻居</span><span style="color: black">n&rsquo;</span><span style="font-family: 宋体; color: black">。如果邻居</span><span style="color: black">n&rsquo;</span><span style="font-family: 宋体; color: black">在</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集中，那么它是已经被检查过的，所以我们不需要考虑它</span><span style="color: black">*</span><span style="font-family: 宋体; color: black">；如果</span><span style="color: black">n&rsquo;</span><span style="font-family: 宋体; color: black">在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中，那么它是以后肯定会被检查的，所以我们现在不考虑它</span><span style="color: black">*</span><span style="font-family: 宋体; color: black">。否则，把它加入</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集，把它的父结点设为</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">。到达</span><span style="color: black">n&rsquo;</span><span style="font-family: 宋体; color: black">的路径的代价</span><span style="color: black">g(n&rsquo;)</span><span style="font-family: 宋体; color: black">，设定为</span><span style="color: black">g(n) + movementcost(n, n&rsquo;)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">(*)</span><span style="font-family: 宋体; color: black">这里我忽略了一个小细节。你确实需要检查结点的</span><span style="color: black">g</span><span style="font-family: 宋体; color: black">值是否更小了，如果是的话，需要重新打开（</span><span style="color: black">re-open</span><span style="font-family: 宋体; color: black">）它。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">OPEN = priority queue containing START</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">CLOSED = empty set</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">while lowest rank in OPEN is not the GOAL:</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;current = remove lowest rank item from OPEN</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;add current to CLOSED</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;for neighbors of current:</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;cost = g(current) + movementcost(current, neighbor)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;if neighbor in OPEN and cost less than g(neighbor):</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove neighbor from OPEN, because new path is better</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;if neighbor in CLOSED and cost less than g(neighbor): **</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove neighbor from CLOSED</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in OPEN and neighbor not in CLOSED:</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set g(neighbor) to cost</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add neighbor to OPEN</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set priority queue rank to g(neighbor) + h(neighbor)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set neighbor's parent to current</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">&nbsp;</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">reconstruct reverse path from goal to start</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">by following parent pointers</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt 42pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">(**) This should never happen if you have an admissible heuristic. However in games we often have inadmissible heuristics.</span><span></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180957"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">3.2&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">源代码</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">我自己的（旧的）</span><span style="color: black">C++A*</span><span style="font-family: 宋体; color: black">代码是可用的：</span><span style="color: black">path.cpp (http://theory.stanford.edu/~amitp/ GameProgramming/path.cpp)</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">path.h (http://theory.stanford.edu/~amitp/GameProgramming/ path.h)</span><span style="font-family: 宋体; color: black">，但是不容易阅读。还有一份更老的代码（更慢的，但是更容易理解），和很多其它的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">实现一样，它在</span><span style="color: black">Steve Woodcock'</span><span style="font-family: 宋体; color: black">的游戏</span><span style="color: black">AI</span><span style="font-family: 宋体; color: black">页面（</span><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.gameai.com/Computability_theory_(computation)  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.gameai.com/Computability_theory_(computation)'" tppabs="http://www.gameai.com/ai.html"><span style="color: black">http://www.gameai.com/ai.html</span></a></span><span style="font-family: 宋体; color: black">）。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在网上，你能找到</span><span style="color: black">C</span><span style="font-family: 宋体; color: black">，</span><span style="color: black">C++</span><span style="font-family: 宋体; color: black">，</span><span style="color: black">Visual Basic&nbsp;</span><span style="font-family: 宋体; color: black">，</span><span style="color: black">Java(http://www.cuspy.com/software/pathfinder/ doc/)</span><span style="font-family: 宋体; color: black">，</span><span style="color: black">Flash/Director/Lingo,&nbsp;<a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.codeproject.com/csharp/Alonzo_Church  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.codeproject.com/csharp/Alonzo_Church'" tppabs="http://www.codeproject.com/csharp/CSharpPathfind.asp"><span style="color: black">C#</span></a>(<a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.codeproject.com/csharp/Alonzo_Church  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.codeproject.com/csharp/Alonzo_Church'" tppabs="http://www.codeproject.com/csharp/CSharpPathfind.asp"><span style="color: black">http://www.codeproject.com/csharp/CSharpPathfind.asp</span></a>), Delphi, Lisp, Python, Perl,&nbsp;</span><span style="font-family: 宋体; color: black">和</span><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/Lambda_calculus  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/Lambda_calculus'" tppabs="http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/5_1.html"><span style="color: black">Prolog</span></a>&nbsp;</span><span style="font-family: 宋体; color: black">实现的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">代码。一定的阅读</span><span style="color: black">Justin Heyes-Jones</span><span style="font-family: 宋体; color: black">的</span><span style="color: black">C++</span><span style="font-family: 宋体; color: black">实现（</span><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.geocities.com/jheyesjones/Turing_machine  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.geocities.com/jheyesjones/Turing_machine'" tppabs="http://www.geocities.com/jheyesjones/astar.html"><span style="color: black">http://www.geocities.com/jheyesjones/astar.html</span></a></span><span style="font-family: 宋体; color: black">）。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180958"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">3.3&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">集合的表示</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">你首先想到的用于实现</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集的数据结构是什么？如果你和我一样，你可能想到&ldquo;数组&rdquo;。你也可能想到&ldquo;链表&rdquo;。我们可以使用很多种不同的数据结构，为了选择一种，我们应该考虑我们需要什么样的操作。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集上我们主要有三种操作：主循环重复选择最好的结点并删除它；访问邻居结点时需要检查它是否在集合里面；访问邻居结点时需要插入新结点。插入和删除最佳是优先队列（</span><span style="color: black">http://members.xoom.com/killough/heaps.html</span><span style="font-family: 宋体; color: black">）的典型操作。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">选择哪种数据结构不仅取决于操作，还取决于每种操作执行的次数。检查一个结点是否在集合中这一操作对每个被访问的结点的每个邻居结点都执行一次。删除最佳操作对每个被访问的结点都执行一次。被考虑到的绝大多数结点都会被访问；不被访问的是搜索空间边缘（</span><em><span>fringe</span></em><span style="font-family: 宋体; color: black">）的结点。当评估数据结构上面的这些操作时，必须考虑</span><span style="color: black">fringe(F)</span><span style="font-family: 宋体; color: black">的最大值。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">另外，还有第四种操作，虽然执行的次数相对很少，但还是必须实现的。如果正被检查的结点已经在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中（这经常发生），并且如果它的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值比已经在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的结点要好（这很少见），那么</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的值必须被调整。调整操作包括删除结点（</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值不是最佳的结点）和重插入。这两个步骤必须被最优化为一个步骤，这个步骤将移动结点。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180959"></a><span style="font-size: 12pt">3.3.1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">未排序数组或链表</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">最简单的数据结构是未排序数组或链表。集合关系检查操作（</span><span style="color: black">Membership test</span><span style="font-family: 宋体; color: black">）很慢，扫描整个结构花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。插入操作很快，添加到末尾花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。查找最佳元素（</span><span style="color: black">Finding the best element</span><span style="font-family: 宋体; color: black">）很慢，扫描整个结构花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。对于数组，删除最佳元素（</span><span style="color: black">Removing the best element</span><span style="font-family: 宋体; color: black">）花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">，而链表则是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。调整操作中，查找结点花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">，改变值花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180960"></a><span style="font-size: 12pt">3.3.2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">排序数组</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">为了加快删除最挂操作，可以对数组进行排序。集合关系检查操作将变成</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">，因为我们可以使用折半查找。插入操作会很慢，为了给新元素腾出空间，需要花费</span><span style="color: black">&nbsp;<span>O(F)</span></span><span style="font-family: 宋体; color: black">以移动所有的元素。查找最佳元素操作会很快，因为它已经在末尾了所以花费是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。如果我们保证最佳排序至数组的尾部（</span><span style="color: black">best sorts to the&nbsp;</span><em><span>end</span></em><span style="color: black">&nbsp;of the array</span><span style="font-family: 宋体; color: black">），删除最佳元素操作花费将是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。调整操作中，查找结点花费</span><span style="color: black">O(logF)</span><span style="font-family: 宋体; color: black">，改变值</span><span style="color: black">/</span><span style="font-family: 宋体; color: black">位置花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180961"></a><span style="font-size: 12pt">3.3.3&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">排序链表</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在排序数组中，插入操作很慢。如果使用链表则可以加速该操作。集合关系检查操作很慢，需要花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">用于扫描链表。插入操作是很快的，插入新元素只花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">时间，但是查找正确位置需要花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。查找最佳元素很快，花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">时间，因为最佳元素已经在表的尾部。删除最佳元素也是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。调整操作中，查找结点花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">，改变值</span><span style="color: black">/</span><span style="font-family: 宋体; color: black">位置花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180962"></a><span style="font-size: 12pt">3.3.4&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">排序跳表</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在未排序链表中查找元素是很慢的。如果用跳表（</span><span style="color: black">http://en.wikipedia.org/wiki/Skip_list</span><span style="font-family: 宋体; color: black">）代替链表的话，可以加速这个操作。在跳表中，如果有排序键（</span><span style="color: black">sort key</span><span style="font-family: 宋体; color: black">）的话，集合关系检查操作会很快：</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">。如果你知道在何处插入的话，和链表一样，插入操作也是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。如果排序键是</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">，查找最佳元素很快，达到</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">，删除一个元素也是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。调整操作涉及到查找结点，删除结点和重插入。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果我们用地图位置作为跳表的排序键，集合关系检查操作将是</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">。在完成集合关系检查后，插入操作是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。查找最佳元素是</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">，删除一个结点是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。因为集合关系检查更快，所以它比未排序链表要好一些。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果我们用</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值作为跳表的排序键，集合关系检查操作将是</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。插入操作是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。查找最佳元素是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">，删除一个结点是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。这并不比排序链表好。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180963"></a><span style="font-size: 12pt">3.3.5&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">索引数组</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果结点的集合有限并且数目是适当的，我们可以使用直接索引结构，索引函数</span><span style="color: black">i(n)</span><span style="font-family: 宋体; color: black">把结点</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">映射到一个数组的索引。未排序与排序数组的长度等于</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集的最大值，和它们不同，对所有的</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">，索引数组的长度总是等于</span><span style="color: black">max(i(n))</span><span style="font-family: 宋体; color: black">。如果你的函数是密集的（没有不被使用的索引），</span><span style="color: black">max(i(n))</span><span style="font-family: 宋体; color: black">将是你地图中结点的数目。只要你的地图是网格的，让索引函数密集就是容易的。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">假设</span><span style="color: black">i(n)</span><span style="font-family: 宋体; color: black">是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">的，集合关系检查将花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">，因为我们几乎不需要检查</span><span>Array[i(n)]</span><span style="font-family: 宋体">是否包含任何数据。</span><span style="color: black">Insertion is O(1), as we just ste&nbsp;</span><span>Array[i(n)]</span><span style="color: black">.</span><span style="font-family: 宋体; color: black">查找和删除最佳操作是</span><span style="color: black">O(numnodes)</span><span style="font-family: 宋体; color: black">，因为我们必须搜索整个结构。调整操作是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180964"></a><span style="font-size: 12pt">3.3.6&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">哈希表</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">索引数组使用了很多内存用于保存不在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的所有结点。一个选择是使用哈希表。哈希表使用了一个哈希函数</span><span style="color: black">h(n)</span><span style="font-family: 宋体; color: black">把地图上每个结点映射到一个哈希码。让哈希表的大小等于</span><span style="color: black">N</span><span style="font-family: 宋体; color: black">的两倍，以使发生冲突的可能性降低。假设</span><span>h(n)</span><span style="color: black">&nbsp;</span><span style="font-family: 宋体; color: black">是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">的，集体关系检查操作花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">；插入操作花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">；删除最佳元素操作花费</span><span style="color: black">O(numnodes)</span><span style="font-family: 宋体; color: black">，因为我们需要搜索整个结构。调整操作花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180965"></a><span style="font-size: 12pt">3.3.7&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">二元堆</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一个二元堆（不要和内存堆混淆）是一种保存在数组中的树结构。和许多普通的树通过指针指向子结点所不同，二元堆使用索引来查找子结点。</span><span style="color: black">C++ STL</span><span style="font-family: 宋体; color: black">包含了一个二元堆的高效实现，我在我自己的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">代码中使用了它。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在二元堆中，集体关系检查花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">，因为你必须扫描整个结构。插入操作花费</span><span>O(log F)</span><span style="font-family: 宋体">而删除最佳操作花费也是</span><span>O(log F)</span><span style="font-family: 宋体">。</span><span style="font-family: 宋体; color: black">调整操作很微妙（</span><span style="color: black">tricky</span><span style="font-family: 宋体; color: black">），花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">时间找到节点，并且很神奇，只用</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">来调整。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">我的一个朋友（他研究用于最短路径算法的数据结构）说，除非在你的</span><span style="color: black">fringe</span><span style="font-family: 宋体; color: black">集里有多于</span><span style="color: black">10000</span><span style="font-family: 宋体; color: black">个元素，否则二元堆是很不错的。除非你的游戏地图特别大，否则你不需要更复杂的数据结构（如</span><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www-cs-students.stanford.edu/~csilvers/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www-cs-students.stanford.edu/~csilvers/'" tppabs="http://www-cs-students.stanford.edu/~csilvers/"><span style="color: black">multi-level buckets</span></a></span><span style="font-family: 宋体; color: black">（</span><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www-cs-students.stanford.edu/~csilvers/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www-cs-students.stanford.edu/~csilvers/'" tppabs="http://www-cs-students.stanford.edu/~csilvers/"><span style="color: black">http://www-cs-students.stanford.edu/~csilvers/</span></a></span><span style="font-family: 宋体; color: black">））。你应该尽可能不用</span><span style="color: black">Fibonacci&nbsp;</span><span style="font-family: 宋体; color: black">堆（</span><span style="color: black">http://www.star-lab.com/goldberg/pub/neci-tr-96-062.ps</span><span style="font-family: 宋体; color: black">），因为虽然它的渐近复杂度很好，但是执行起来很慢，除非</span><span style="color: black">F</span><span style="font-family: 宋体; color: black">足够大。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180966"></a><span style="font-size: 12pt">3.3.8&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">伸展树</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">堆是一种基于树的结构，它有一个期望的</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">代价的时间操作。然而，问题是在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法中，通常的情况是，一个代价小的节点被移除（花费</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">的代价，因为其他结点必须从树的底部向上移动），而紧接着一些代价小的节点被添加（花费</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">的代价，因为这些结点被添加到底部并且被移动到最顶部）。在这里，堆的操作在预期的情况下和最坏情况下是一样的。如果我们找到这样一种数据结构，最坏情况还是一样，而预期的情况好一些，那么就可以得到改进。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">伸展树（</span><span style="color: black">Splay tree</span><span style="font-family: 宋体; color: black">）是一种自调整的树结构。任何对树结点的访问都尝试把该结点推到树的顶部（</span><span style="color: black">top</span><span style="font-family: 宋体; color: black">）。这就产生了一个缓存效果（</span><span style="color: black">&quot;caching&quot; effect</span><span style="font-family: 宋体; color: black">）：很少被使用的结点跑到底部（</span><span style="color: black">bottom</span><span style="font-family: 宋体; color: black">）去了并且不减慢操作（</span><span style="color: black">don't slow down operations</span><span style="font-family: 宋体; color: black">）。你的</span><span style="color: black">splay</span><span style="font-family: 宋体; color: black">树有多大并不重要，因为你的操作仅仅和你的&ldquo;</span><span style="color: black">cache size</span><span style="font-family: 宋体; color: black">&rdquo;一样慢。在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">中，低代价的结点使用得很多，而高代价结点经常不被使用，所以高代价结点将会移动到树的底部。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">使用伸展树后，集体关系检查，插入，删除最佳和调整操作都是期望的</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">（注：原文为</span><span style="color: black">expected O(log F)&nbsp;</span><span style="font-family: 宋体; color: black">），最坏情况是</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">。然而有代表性的是，缓存过程（</span><span style="color: black">caching</span><span style="font-family: 宋体; color: black">）避免了最坏情况的发生。</span><span style="color: black">Dijkstra</span><span style="font-family: 宋体; color: black">算法和带有低估的启发函数（</span><span style="color: black">underestimating heuristic</span><span style="font-family: 宋体; color: black">）的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法却有一些特性让伸展树达不到最优。特别是对结点</span><span style="color: black">n</span><span style="font-family: 宋体; color: black">和邻居结点</span><span style="color: black">n&rsquo;</span><span style="font-family: 宋体; color: black">来说，</span><span>f(n') &gt;= f(n)</span><span style="font-family: 宋体">。</span><span style="font-family: 宋体; color: black">当这发生时，也许插入操作总是发生在树的同一边结果是使它失去了平衡。我没有试验过这个。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180967"></a><span style="font-size: 12pt">3.3.9 HOT</span><span style="font-size: 12pt; font-family: 宋体">队列</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">还有一种比堆好的数据结构。通常你可以限制优先队列中值的范围。给定一个限定的范围，经常会存在更好的算法。例如，对任意值的排序可以在</span><span style="color: black">O(N log N)</span><span style="font-family: 宋体; color: black">时间内完成，但当固定范围时，桶排序和基数排序可以在</span><span style="color: black">O(N)</span><span style="font-family: 宋体; color: black">时间内完成。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">我们可以使用</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">（</span><span style="color: black">Heap On Top</span><span style="font-family: 宋体; color: black">）队列</span><span style="color: black">(http://www.star-lab.com/goldberg/pub /neci-tr-97-104.ps</span><span style="font-family: 宋体; color: black">）来利用</span><span>f(n') &gt;= f(n)</span><span style="font-family: 宋体">，其中</span><span>n&rsquo;</span><span style="font-family: 宋体">是</span><span>n</span><span style="font-family: 宋体">的一个邻居结点。我们删除</span><span>f(n)</span><span style="font-family: 宋体">值最小的结点</span><span>n</span><span style="font-family: 宋体">，插入满足</span><span>f(n) &lt;= f(n') &lt;= f(n) + delta</span><span style="font-family: 宋体">的邻居</span><span>n'</span><span style="font-family: 宋体">，其中</span><span>delta &lt;= C</span><span style="font-family: 宋体">。</span><span style="font-family: 宋体; color: black">常数</span><span style="color: black">C</span><span style="font-family: 宋体; color: black">是从一结点到邻近结点代价改变量的最大值。因为</span><span style="color: black">f(n)</span><span style="font-family: 宋体; color: black">是</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的最小</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值，并且正要被插入的所有结点都小于或等于</span><span>f(n) + delta</span><span style="font-family: 宋体">，我们知道</span><span>OPEN</span><span style="font-family: 宋体">集中的所有</span><span>f</span><span style="font-family: 宋体">值都不超过一个</span><span>0..delta</span><span style="font-family: 宋体">的范围。在桶</span><span>/</span><span style="font-family: 宋体">基数排序中，我们可以用&ldquo;桶&rdquo;（</span><span style="color: black">buckets</span><span style="font-family: 宋体">）对</span><span>OPEN</span><span style="font-family: 宋体">集中的结点进行排序。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">使用</span><span style="color: black">K</span><span style="font-family: 宋体; color: black">个桶，我们把</span><span style="color: black">O(N)</span><span style="font-family: 宋体; color: black">的代价降低到平均</span><span style="color: black">O(N/K)</span><span style="font-family: 宋体; color: black">。通过</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列，顶端的桶使用二元堆而所有其他的桶都是未排序数组。因而，对顶部的桶，集合关系检查代价是预期的</span><span style="color: black">O(F/K)</span><span style="font-family: 宋体; color: black">，插入和删除最佳是</span><span style="color: black">O(log (F/K))</span><span style="font-family: 宋体; color: black">。对其他桶，集合关系检查是</span><span style="color: black">O(F/K)</span><span style="font-family: 宋体; color: black">，插入是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">，而删除最佳根本不发生！如果顶端的桶是空的，那么我们必须把下一个桶即未排序数组转换为二元堆。这个操作（&ldquo;</span><span style="color: black">heapify</span><span style="font-family: 宋体; color: black">&rdquo;）可以在</span><span style="color: black">O(F/K)</span><span style="font-family: 宋体; color: black">时间内完成。在调整操作中，删除是</span><span style="color: black">O(F/K)</span><span style="font-family: 宋体; color: black">，然后插入是</span><span style="color: black">O(log (F/K))</span><span style="font-family: 宋体; color: black">或</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">中，我们加入</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的许多结点实际上根本是不需要的。在这方面</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列很有优势，因为不需要的元素的插入操作只花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">时间。只有需要的元素被</span><span style="color: black">heapified</span><span style="font-family: 宋体; color: black">（代价较低的那些）。唯一一个超过</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">的操作是从堆中删除结点，只花费</span><span style="color: black">O(log (F/K))</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">另外，如果</span><span style="color: black">C</span><span style="font-family: 宋体; color: black">比较小，我们可以只让</span><span style="color: black">K = C</span><span style="font-family: 宋体; color: black">，则对于最小的桶，我们甚至不需要一个堆，国为在一个桶中的所有结点都有相同的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值。插入和删除最佳都是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">时间！有人研究过，</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列在至多在</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中有</span><span style="color: black">800</span><span style="font-family: 宋体; color: black">个结点时和堆一样快，并且如果</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中至多有</span><span style="color: black">1500</span><span style="font-family: 宋体; color: black">个结点，则比堆快</span><span style="color: black">20%</span><span style="font-family: 宋体; color: black">。我期望随着结点的增加，</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列也更快。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列的一个简单的变化是一个二层队列（</span><span style="color: black">two-level queue</span><span style="font-family: 宋体; color: black">）：把好的结点放进一个数据结构（堆或数组）而把坏的结点放进另一个数据结构（数组或链表）。因为大多数进入</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的结点都&ldquo;坏的&rdquo;，它们从不被检查，因而把它们放进出一个大数组是没有害处的。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180968"></a><span style="font-size: 12pt">3.3.10&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">比较</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">注意有一点很重要，我们并不是仅仅关心渐近的行为（大</span><span style="color: black">O</span><span style="font-family: 宋体; color: black">符号）。我们也需要关心小常数（</span><span style="color: black">low constant</span><span style="font-family: 宋体; color: black">）下的行为。为了说明原因，考虑一个</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">的算法，和另一个</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">的算法，其中</span><span style="color: black">F</span><span style="font-family: 宋体; color: black">是堆中元素的个数。也许在你的机器上，第一个算法的实现花费</span><span style="color: black">10000*log(F)</span><span style="font-family: 宋体; color: black">秒，而另一个的实现花费</span><span style="color: black">2*F</span><span style="font-family: 宋体; color: black">秒。当</span><span style="color: black">F=256</span><span style="font-family: 宋体; color: black">时，第一个算法将花费</span><span style="color: black">80000</span><span style="font-family: 宋体; color: black">秒而第二个算法花费</span><span style="color: black">512</span><span style="font-family: 宋体; color: black">秒。在这种情况下，&ldquo;更快&rdquo;的算法花费更多的时间，而且只有在当</span><span style="color: black">F&gt;200000</span><span style="font-family: 宋体; color: black">时才能运行得更快。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">你不能仅仅比较两个算法。你还要比较算法的实现。同时你还需要知道你的数据的大小（</span><span style="color: black">size</span><span style="font-family: 宋体; color: black">）。在上面的例子中，第一种实现在</span><span style="color: black">F&gt;200000</span><span style="font-family: 宋体; color: black">时更快，但如果在你的游戏中，</span><span style="color: black">F</span><span style="font-family: 宋体; color: black">小于</span><span style="color: black">30000</span><span style="font-family: 宋体; color: black">，那么第二种实现好一些。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">基本数据结构没有一种是完全合适的。未排序数组或者链表使插入操作很快而集体关系检查和删除操作非常慢。排序数组或者链表使集体关系检查稍微快一些，删除（最佳元素）操作非常快而插入操作非常慢。二元堆让插入和删除操作稍微快一些，而集体关系检查则很慢。伸展树让所有操作都快一些。</span><span style="color: black">HOT</span><span style="font-family: 宋体; color: black">队列让插入操作很快，删除操作相当快，而集体关系检查操作稍微快一些。索引数组让集体关系检查和插入操作非常快，但是删除操作不可置信地慢，同时还需要花费很多内存空间。哈希表和索引数组类似，但在普通情况下，它花费的内存空间少得多，而删除操作虽然还是很慢，但比索引数组要快。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">关于更高级的优先队列的资料和实现，请参考</span><span style="color: black">Lee Killough</span><span style="font-family: 宋体; color: black">的优先队列页面（</span><span style="color: black">http://members.xoom.com/killough/heaps.html</span><span style="font-family: 宋体; color: black">）。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180969"></a><span style="font-size: 12pt">3.3.11&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">混合实现</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">为了得到最佳性能，你将希望使用混合数据结构。在我的</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">代码中，我使用一个索引数组从而集合关系检查是</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">的，一个二元堆从而插入操作和删除最佳都是</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">的。对于调整操作，我使用索引数组从而花费</span><span style="color: black">O(1)</span><span style="font-family: 宋体; color: black">时间检查我是否真的需要进行调整（通过在索引数组中保存</span><span style="color: black">g</span><span style="font-family: 宋体; color: black">值），然后在少数确实需要进行调整的情况中，我使用二元堆从而调整操作花费</span><span style="color: black">O(F)</span><span style="font-family: 宋体; color: black">时间。你也可以使用索引数组保存堆中每个结点的位置，这让你的调整操作变成</span><span style="color: black">O(log F)</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180970"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">3.4&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">与游戏循环的交互</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">交互式的（尤其是实时的）游戏对最佳路径的计算要求很高。能够得到一个解决方案比得到最佳方案可能更重要。然而在所有其他因素都相同的情况下，短路径比长路径好。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一般来说，计算靠近初始结点的路径比靠近目标结点的路径更重要一些。立即开始原理（</span><span style="color: black">The principle of&nbsp;</span><em><span>immediate start</span></em><span style="font-family: 宋体; color: black">）：让游戏中的物体尽可能快地开始行动，哪怕是沿着一条不理想的路径，然后再计算一条更好的路径。在实时游戏中，应该更多地关注</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的延迟情况（</span><em><span>latency</span></em><span style="font-family: 宋体; color: black">）而不是吞吐量（</span><em><span>throughput</span></em><span style="font-family: 宋体; color: black">）。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">可以对物体编程让它们根据自己的本能（简单行为）或者智力（一条预先计算好的路径）来行动。除非它们的智力告诉它们怎么行动，否则它们就根据自己的本能来行动（这是实际上使用的方法，并且</span><span style="color: black">Rodney Brook</span><span style="font-family: 宋体; color: black">在他的机器人体系结构中也用到）。和立即计算所有路径所不同，让游戏在每一个，两个，或者三个循环中搜索一条路径。让物体在开始时依照本能行动</span><span style="color: black">(</span><span style="font-family: 宋体; color: black">可能仅仅是简单地朝着目标直线前进</span><span style="color: black">)</span><span style="font-family: 宋体; color: black">，然后才为它们寻找路径。这种方法让让路径搜索的代价趋于平缓，因此它不会集中发生在同一时刻。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180971"></a><span style="font-size: 12pt">3.4.1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">提前退出</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">可以从</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法的主循环中提前退出来同时得到一条局部路径。通常，当找到目标结点时，主循环就退出了。然而，在此之前的任意结点，可以得到一条到达</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">中当前最佳结点的路径。这个结点是到达目标点的最佳选择，所以它是一个理想的中间结点（原文为</span><span style="color: black">so it's a reasonable place to go</span><span style="font-family: 宋体; color: black">）。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">可以提前退出的情况包括检查了一定数量的结点，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法已经运行了几毫秒时间，或者扫描了一个离初始点有些距离的结点。当使用路径拼接时，应该给被拼接的路径一个比全路径（</span><span style="color: black">full path</span><span style="font-family: 宋体; color: black">）小的最大长度。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180972"></a><span style="font-size: 12pt">3.4.2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">中断算法</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果需要进行路径搜索的物体较少，或者如果用于保存</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集的数据结构较小，那么保存算法的状态是可行的，然后退出到游戏循环继续运行游戏。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180973"></a><span style="font-size: 12pt">3.4.3&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">组运动</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">路径请求并不是均匀分布的。即时策略游戏中有一个常见的情况，玩家会选择多个物体并命令它们朝着同样的目标移动。这给路径搜索系统以沉重的负载。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在这种情况下，为某个物体寻找到的路径对其它物体也是同样有用的。一种方法是，寻找一条从物体的中心到目的地中心的路径</span><span style="color: black">P</span><span style="font-family: 宋体; color: black">。对所有物体使用该路径的绝大部分，对每一个物体，前十步和后十步使用为它自己寻找的路径。物体</span><span style="color: black">i</span><span style="font-family: 宋体; color: black">得到一条从它的开始点到</span><span style="color: black">P[10]</span><span style="font-family: 宋体; color: black">的路径，紧接着是共享的路径</span><span>P[10..len(P)-10]</span><span style="font-family: 宋体; color: black">，最后是从</span><span>P[len(P)-10]</span><span style="font-family: 宋体">到目的地的路径。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">为每个物体寻找的路径是较短的（平均步数大约是</span><span style="color: black">10</span><span style="font-family: 宋体; color: black">），而较长的路径被共享。大多数路径只寻找一次并且为所有物体所共享。然而，当玩家们看到所有的物体都沿着相同的路径移动时，将对游戏失去兴趣。为了对系统做些改进，可以让物体稍微沿着不同的路径运动。一种方法是选择邻近结点以改变路径。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">另一种方法是让每个物体都意识到其它物体的存在（或许是通过随机选择一个&ldquo;领导&rdquo;物体，或者是通过选择一个能够最好地意识到当前情况的物体），同时仅仅为领导寻路。然后用</span><span style="color: black">flocking</span><span style="font-family: 宋体; color: black">算法让它们以组的形式运动。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">然而还有一种方法是利用</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法的中间状态。这个状态可以被朝着相同目标移动的多个物体共享，只要物体共享相同的启发式函数和代价函数。当主循环退出时，不要消除</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集；用</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">上一次的</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集开始下一次的循环（下一个物体的开始位置）。（这可以被看成是中断算法和提前退出部分的一般化）</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180974"></a><span style="font-size: 12pt">3.4.4&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">细化</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果地图中没有障碍物，而有不同代价的地形，那么可以通过低估地形的代价来计算一条初始路径。例如，如果草地的代价是</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">，山地代价是</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">，山脉的代价是</span><span style="color: black">3</span><span style="font-family: 宋体; color: black">，那么</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">会考虑通过</span><span style="color: black">3</span><span style="font-family: 宋体; color: black">个草地以避免</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">个山脉。通过把草地看成</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">，山地看成</span><span style="color: black">1.1</span><span style="font-family: 宋体; color: black">，而山脉看成</span><span style="color: black">1.2</span><span style="font-family: 宋体; color: black">来计算初始路径，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">将会用更少的时间去设法避免山脉，而且可以更快地找到一条路径（这接近于精确启发函数的效果）。一旦找到一条路径，物体就可以开始移动，游戏循环就可以继续了。当多余的</span><span style="color: black">CPU</span><span style="font-family: 宋体; color: black">时间是可用的时候，可以用真实的移动代价去计算更好的路径。</span><span></span></p><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180975"></a><span style="font-size: 12pt">4 A*</span><span style="font-size: 12pt; font-family: 宋体">算法的变种</span><span style="font-size: 12pt"></span></h1><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180976"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.1 beam search</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的主循环中，</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集保存所有需要检查的结点。</span><span style="color: black">Beam Search</span><span style="font-family: 宋体; color: black">是</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法的一个变种，这种算法限定了</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集的尺寸。如果</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集变得过大，那些没有机会通向一条好的路径的结点将被抛弃。缺点是你必须让排序你的集合以实现这个，这限制了可供选择的数据结构。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180977"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.2&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">迭代深化</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">迭代深化是一种在许多</span><span style="color: black">AI</span><span style="font-family: 宋体; color: black">算法中使用的方法，这种方法从一个近似解开始，逐渐得到更精确的解。该名称来源于游戏树搜索，需要查看前面几步（比如在象棋里），通过查看前面更多步来提高树的深度。一旦你的解不再有更多的改变或者改善，就可以认为你已经得到足够好的解，当你想要进一步精确化时，它不会再有改善。在</span><span style="color: black">ID-A*</span><span style="font-family: 宋体; color: black">中，深度是</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值的一个</span><span style="color: black">cutoff</span><span style="font-family: 宋体; color: black">。当</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">的值太大时，结点甚至将不被考虑（例如，它不会被加入</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中）。第一次迭代只处理很少的结点。此后每一次迭代，访问的结点都将增加。如果你发现路径有所改善，那么就继续增加</span><span style="color: black">cutoff</span><span style="font-family: 宋体; color: black">，否则就可以停止了。更多的细节请参考这些关于</span><span style="color: black">ID-A*</span><span style="font-family: 宋体; color: black">的资料：</span><span style="color: black">http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">我本人认为在游戏地图中没有太大的必要使用</span><span style="color: black">ID-A*</span><span style="font-family: 宋体; color: black">寻路。</span><span style="color: black">ID</span><span style="font-family: 宋体; color: black">算法趋向于增加计算时间而减少内存需求。然而在地图路径搜索中，&ldquo;结点&rdquo;是很小的&mdash;&mdash;它们仅仅是坐标而已。我认为不保存这些结点以节省空间并不会带来多大改进。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180978"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.3&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">动态衡量</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在动态衡量中，你假设在开始搜索时，最重要的是讯速移动到任意位置；而在搜索接近结束时，最重要的是移动到目标点。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">f(p) = g(p) + w(p) * h(p)</span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">启发函数中带有一个权值（</span><span style="color: black">weight</span><span style="font-family: 宋体; color: black">）（</span><span style="color: black">w&gt;=1</span><span style="font-family: 宋体; color: black">）。当你接近目标时，你降低这个权值；这降低了启发函数的重要性，同时增加了路径真实代价的相对重要性。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180979"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.4&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">带宽搜索</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">带宽搜索（</span><em><span>Bandwidth Search</span></em><span style="font-family: 宋体; color: black">）有两个对有些人也许有用的特性。这个变种假设</span><span style="color: black">h</span><span style="font-family: 宋体; color: black">是过高估计的值，但不高于某个数</span><span style="color: black">e</span><span style="font-family: 宋体; color: black">。如果这就是你遇到的情况，那么你得到的路径的代价将不会比最佳路径的代价超过</span><span style="color: black">e</span><span style="font-family: 宋体; color: black">。重申一次，你的启发函数设计的越好，最终效果就越好。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">另一个特性是，你可以丢弃</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的某些结点。当</span><span style="color: black">h+d</span><span style="font-family: 宋体; color: black">比路径的真实代价高的时候（对于某些</span><span style="color: black">d</span><span style="font-family: 宋体; color: black">），你可以丢弃那些</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值比</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中的最好结点的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值高至少</span><span style="color: black">e+d</span><span style="font-family: 宋体; color: black">的结点。这是一个奇怪的特性。对于好的</span><span style="color: black">f</span><span style="font-family: 宋体; color: black">值你有一个&ldquo;范围&rdquo;（</span><span style="color: black">&quot;band&quot;</span><span style="font-family: 宋体; color: black">），任何在这个范围之外的结点都可以被丢弃掉，因为这个结点肯定不会在最佳路径上。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">好奇地（</span><span style="color: black">Curiously</span><span style="font-family: 宋体; color: black">），你可以对这两种特性使用不同的启发函数，而问题仍然可以得到解决。使用一个启发函数以保证你得到的路径不会太差，另一个用于检查从</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">集中去掉哪些结点。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180980"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.5&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">双向搜索</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">与从开始点向目标点搜索不同的是，你也可以并行地进行两个搜索&mdash;&mdash;一个从开始点向目标点，另一个从目标点向开始点。当它们相遇时，你将得到一条好的路径。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">这听起来是个好主意，但我不会给你讲很多内容。双向搜索的思想是，搜索过程生成了一棵在地图上散开的树。一棵大树比两棵小树差得多，所以最好是使用两棵较小的搜索树。然而我的试验表明，在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">中你得不到一棵树，而只是在搜索地图中当前位置附近的区域，但是又不像</span><span style="color: black">Dijkstra</span><span style="font-family: 宋体; color: black">算法那样散开。事实上，这就是让</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">算法运行得如此快的原因&mdash;&mdash;无论你的路径有多长，它并不进行疯狂的搜索，除非路径是疯狂的。它只尝试搜索地图上小范围的区域。如果你的地图很复杂，双向搜索会更有用。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">面对面的方法（</span><span style="color: black">The&nbsp;</span><em><span>front-to-front</span></em><span style="color: black">&nbsp;variation</span><span style="font-family: 宋体; color: black">）把这两种搜索结合在一起。这种算法选择一对具有最好的</span><span>g(start,x) + h(x,y) + g(y,goal)</span><span style="font-family: 宋体">的结点，而不是选择最好的前向搜索结点&mdash;&mdash;</span><span>g(start,x) + h(x,goal)</span><span style="font-family: 宋体">，或者最好的后向搜索结点&mdash;&mdash;</span><span>g(y,goal) + h(start,y)</span><span style="font-family: 宋体">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">Retargeting</span><span style="font-family: 宋体; color: black">方法不允许前向和后向搜索同时发生。它朝着某个最佳的中间结点运行前向搜索一段时间，然后再朝这个结点运行后向搜索。然后选择一个后向最佳中间结点，从前向最佳中间结点向后向最佳中间结点搜索。一直进行这个过程，直到两个中间结点碰到一块。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180981"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">4.6&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">动态</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">A*</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">与终身计划</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">A*</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">有一些</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的变种允许当初始路径计算出来之后，世界发生改变。</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">用于当你没有全局所有信息的时候。如果你没有所有的信息，</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">可能会出错；</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">的贡献在于，它能纠正那些错误而不用过多的时间。</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">用于代价会改变的情况。在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">中，当地图发生改变时，路径将变得无效；</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">可以重新使用之前</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的计算结果并产生新的路径。然而，</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">都需要很多内存&mdash;&mdash;用于运行</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">并保存它的内部信息（</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集，路径树，</span><span style="color: black">g</span><span style="font-family: 宋体; color: black">值），当地图发生改变时，</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">或者</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">会告诉你，是否需要就地图的改变对路径作调整。在一个有许多运动着的物体的游戏中，你经常不希望保存所有这些信息，所以</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">在这里并不适用。它们是为机器人技术而设计的，这种情况下只有一个机器人&mdash;&mdash;你不需要为别的机器人寻路而重用内存。如果你的游戏只有一个或者少数几个物体，你可以研究一下</span><span style="color: black">D*</span><span style="font-family: 宋体; color: black">或者</span><span style="color: black">LPA*</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><ul style="margin-left: 30px; padding-left: 0px; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.frc.ri.cmu.edu/~axs/Functional_programming  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.frc.ri.cmu.edu/~axs/Functional_programming'" tppabs="http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html"><span style="color: black">Overview of D*</span></a></span><span style="font-family: 宋体">（</span><span>http://www.frc.ri.cmu.edu/~axs/dynamic_plan.html</span><span style="font-family: 宋体">）</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.frc.ri.cmu.edu/~axs/doc/Lisp_programming_language  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.frc.ri.cmu.edu/~axs/doc/Lisp_programming_language'" tppabs="http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps"><span style="color: black">D* Paper 1</span></a></span><span style="font-family: 宋体">（</span><span>http:// http://www.frc.ri.cmu.edu/~axs/doc/icra94.ps</span><span style="font-family: 宋体">）</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://www.frc.ri.cmu.edu/~axs/doc/Scheme_(programming_language)  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.frc.ri.cmu.edu/~axs/doc/Scheme_(programming_language)'" tppabs="http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps"><span style="color: black">D* Paper 2</span></a></span><span style="font-family: 宋体">（</span><span>http:// http://www.frc.ri.cmu.edu/~axs/doc/ijcai95.ps</span><span style="font-family: 宋体">）</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://idm-lab.org/Y_combinator  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://idm-lab.org/Y_combinator'" tppabs="http://idm-lab.org/project-a.html"><span style="color: black">Lifelong planning overview</span></a></span><span style="font-family: 宋体">（</span><span>http://idm-lab.org/project-a.html</span><span style="font-family: 宋体">）</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://csci.mrs.umn.edu/UMMCSciWiki/pub/CSci3903s03/KellysPaper/Georg_Cantor  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://csci.mrs.umn.edu/UMMCSciWiki/pub/CSci3903s03/KellysPaper/Georg_Cantor'" tppabs="http://csci.mrs.umn.edu/UMMCSciWiki/pub/CSci3903s03/KellysPaper/seminar.pdf"><span style="color: black">Lifelong planning paper (PDF)</span></a></span><span style="font-family: 宋体">（</span><span><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://csci.mrs.umn.edu/UMMCsciwiki/pub/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://csci.mrs.umn.edu/UMMCsciwiki/pub/'" tppabs="http://csci.mrs.umn.edu/UMMCsciwiki/pub/"><span style="color: black">http://csci.mrs.umn.edu/UMMCsciwiki/pub/</span></a>&nbsp;Csci3903s03/KellysPaper/seminar.pdf</span><span style="font-family: 宋体">）</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; text-align: left"><span style="color: black"><a style="color: gray; text-decoration: none" href="javascript:if(confirm('http://idm-lab.org/103-3576835-0834231?ie=UTF8&s=books&qid=1177237889&sr=8-4  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://idm-lab.org/103-3576835-0834231?ie=UTF8&s=books&qid=1177237889&sr=8-4'" tppabs="http://idm-lab.org/applet.html"><span style="color: black">Lifelong planning A* applet</span></a></span><span style="font-family: 宋体; color: black">（</span><span style="color: black">http://idm-lab.org/applet.html</span><span style="font-family: 宋体; color: black">）</span><span></span></li></ul><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180982"></a><span style="font-size: 12pt">5&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">处理运动障碍物</span><span style="font-size: 12pt"></span></h1><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一个路径搜索算法沿着固定障碍物计算路径，但是当障碍物会运动时情况又怎样？当一个物体到达一个特写的位置，原来的障碍物也许不再在那儿了，或者一个新的障碍物也许到达那儿。处理该问题的一个方法是放弃路径搜索而使用运动算法（</span><span style="color: black">movement algorithms</span><span style="font-family: 宋体; color: black">）替代，这就不能</span><span style="color: black">look far ahead</span><span style="font-family: 宋体; color: black">；这种方法会在后面的部分中讨论。这一部分将对路径搜索方法进行修改从而解决运动障碍物的问题。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180983"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">5.1&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">重新计算路径</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">当时间渐渐过去，我们希望游戏世界有所改变。以前搜索到的一条路径到现在也许不再是最佳的了。对旧的路径用新的信息进行更新是有价值的。以下规则可以用于决定什么时候需要重新计算路径：</span><span style="color: black"></span></p><ul style="margin-left: 30px; padding-left: 0px; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">每</span><span>N</span><span style="font-family: 宋体">步：这保证用于计算路径的信息不会旧于</span><span>N</span><span style="font-family: 宋体">步。</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">任何可以使用额外的</span><span>CPU</span><span style="font-family: 宋体">时间的时候：这允许动态调整路径的性质；在物体数量多时，或者运行游戏的机器比较慢时，每个物体对</span><span>CPU</span><span style="font-family: 宋体">的使用可得到减少。</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">当物体拐弯或者跨越一个导航点（</span><span>waypoint</span><span style="font-family: 宋体">）的时候。</span><span style="font-size: 12pt; font-family: 宋体"><span></span></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: disc; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">当物体附近的世界改变了的时候。</span><span style="font-size: 12pt; font-family: 宋体"></span></li></ul><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">重计算路径的主要缺点是许多路径信息被丢弃了。例如，如果路径是</span><span style="color: black">100</span><span style="font-family: 宋体; color: black">步长，每</span><span style="color: black">10</span><span style="font-family: 宋体; color: black">步重新计算一次，路径的总步数将是</span><span style="color: black">100+90+80+70+60+50+40+30+20+10 = 550</span><span style="font-family: 宋体; color: black">。对</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">步长的路径，大约需要计算</span><span style="color: black">M^2</span><span style="font-family: 宋体; color: black">步。因此如果你希望有许多很长的路径，重计算不是个好主意。重新使用路径信息比丢弃它更好。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180984"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">5.2&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">路径拼接</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">当一条路径需要被重新计算时，意味着世界正在改变。对于一个正在改变的世界，对地图中当前邻近的区域总是比对远处的区域了解得更多。因此，我们应该集中于在附近寻找好的路径，同时假设远处的路径不需要重新计算，除非我们接近它。与重新计算整个路径不同，我们可以重新计算路径的前</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">步：</span><span style="color: black"></span></p><ol style="padding-left: 40px; color: #303030; font-family: Verdana, Helvetica, Arial; line-height: 18px; text-align: justify"><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: decimal; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">令</span><span>p[1]..p[N]</span><span style="font-family: 宋体">为路径（</span><span>N</span><span style="font-family: 宋体">步）的剩余部分</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: decimal; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">为</span><span>p[1]</span><span style="font-family: 宋体">到</span><span>p[M]</span><span style="font-family: 宋体">计算一条新的路径</span><span style="font-size: 12pt; font-family: 宋体"></span></li><li class="MsoNormal" style="font-size: 13px; line-height: 19.5px; list-style-type: decimal; margin: 0cm 0cm 0pt; color: black; text-align: left"><span style="font-family: 宋体">把这条新路径拼接（</span><span>Splice</span><span style="font-family: 宋体">）到旧路径：把</span><span>p[1]..p[M]</span><span style="font-family: 宋体">用新的路径值代替</span><span style="font-size: 12pt; font-family: 宋体"></span></li></ol><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: center" class="MsoNormal" align="center"><span style="font-size: 12pt; font-family: 宋体; color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">因为</span><span style="color: black">p[1]</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">p[M]</span><span style="font-family: 宋体; color: black">比分开的</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">步小（原文：</span><span style="color: black">Since p[1] and p[M] are fewer than M steps apart</span><span style="font-family: 宋体; color: black">），看起来新路径不会很长。不幸的是，新的路径也许很长而且不够好。上面的图显示了这种情况。最初的红色路径是</span><span style="color: black">1-2-3-4</span><span style="font-family: 宋体; color: black">，褐色的是障碍物。如果我们到达</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">并且发现从</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">到达</span><span style="color: black">3</span><span style="font-family: 宋体; color: black">的路径被封锁了，路径拼接技术会把</span><span style="color: black">2-3</span><span style="font-family: 宋体; color: black">用</span><span style="color: black">2-5-3</span><span style="font-family: 宋体; color: black">取代，结果是物体沿着路径</span><span style="color: black">1-2-5-3-4</span><span style="font-family: 宋体; color: black">运动。我们可以看到这不是一条好的路径，蓝色的路径</span><span style="color: black">1-2-5-4</span><span style="font-family: 宋体; color: black">是一条更好的路径。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">通常可以通过查看新路径的长度检测到坏的路径。如果这严格大于</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">，就可能是不好的。一个简单的解决方法是，为搜索算法设置一个最大路径长度。如果找不到一条短的路径，算法返回错误代码；这种情况下，用重计算路径取代路径拼接，从而得到路径</span><span style="color: black">1-2-5-4.</span><span style="font-family: 宋体; color: black">。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">对于其它情况，对于</span><span style="color: black">N</span><span style="font-family: 宋体; color: black">步的路径，路径拼接会计算</span><span style="color: black">2N</span><span style="font-family: 宋体; color: black">或者</span><span style="color: black">3N</span><span style="font-family: 宋体; color: black">步，这取决于拼接新路径的频率。对于对世界的改变作反应的能力而言，这个代价是相当低的。令人吃惊的是这个代价和拼接的步数</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">无关。</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">不影响</span><span style="color: black">CPU</span><span style="font-family: 宋体; color: black">时间，而控制了响应和路径质量的折衷。如果</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">太大，物体的移动将不能快速对地图的改变作出反应。如果</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">太小，拼接的路径可能太短以致不能正确地绕过障碍物；许多不理想的路径（如</span><span style="color: black">1-2-5-3-4</span><span style="font-family: 宋体; color: black">）将被找到。尝试不同的</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">值和不同的拼接标准</span><span style="color: black">(</span><span style="font-family: 宋体; color: black">如每</span><span style="color: black">3/4&nbsp;</span><em><span>M</span></em><span style="font-family: 宋体; color: black">步</span><span style="color: black">)</span><span style="font-family: 宋体; color: black">，看看哪一种情况对你的地图最合适。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">路径拼接确实比重计算路径要快，但它不能对路径的改变作出很好的反应。经常可以发现这种情况并用路径重计算来取代。也可以调整一些变量，如</span><span style="color: black">M</span><span style="font-family: 宋体; color: black">和寻找新路径的时机，所以可以对该方法进行调整</span><span style="color: black">(</span><span style="font-family: 宋体; color: black">甚至在运行时</span><span style="color: black">)</span><span style="font-family: 宋体; color: black">以用于不同的情况。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="color: black">Note</span><span style="font-family: 宋体; color: black">：</span><span style="color: black">Bryan Stout&nbsp;</span><span style="font-family: 宋体; color: black">有两个算法，</span><span style="color: black">Patch-One</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">Patch-All</span><span style="font-family: 宋体; color: black">，他从路径拼接中得到灵感，并在实践中运行得很好。他出席了</span><span style="color: black"><a style="color: gray; text-decoration: none" href="mhtml:http://dev.gameres.com/Program/Abstract/Arithmetic/AmitAStar.mht!https://www.cmpevents.com/GD07/a.asp?option=C&amp;V=11&amp;SessID=4608"><span style="color: black">GDC 2007</span></a></span><span style="font-family: 宋体; color: black">（</span><span style="color: black">https://www.cmpevents.com/GD07/a.asp?option =C &amp;V=11&amp; SessID=4608</span><span style="font-family: 宋体; color: black">）；一旦他把资料放在网上，我将链接过去。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21.1pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><strong><span>Implementation Note</span></strong><strong><span style="font-family: 宋体">：</span><span></span></strong></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">反向保存路径，从而删除路径的开始部分并用不同长度的新路径拼接将更容易，因为这两个操作都将在数组的末尾进行。本质上你可以把这个数组看成是堆栈因为顶部的元素总是下一个要使用的。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180985"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">5.3&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">监视地图变化</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">与间隔一段时间重计算全部或部分路径不同的是，可以让地图的改变触发一次重计算。地图可以分成区域，每个物体都可以对某些区域感兴趣（可以是包含部分路径的所有区域，也可以只是包含部分路径的邻近区域）。当一个障碍物进入或者离开一个区域，该区域将被标识为已改变，所有对该区域感兴趣的物体都被通知到，所以路径将被重新计算以适应障碍物的改变。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">这种技术有许多变种。例如，可以每隔一定时间通知物体，而不是立即通知物体。多个改变可以成组地触发一个通知，因此避免了额外的重计算。另一个例子是，让物体检查区域，而不是让区域通知物体。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">监视地图变化允许当障碍物不改变时物体避免重计算路径，所以当你有许多区域并不经常改变时，考虑这种方法。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180986"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">5.4&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">预测障碍物的运动</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">如果障碍物的运动可以预测，就能为路径搜索考虑障碍物的未来位置。一个诸如</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">的算法有一个代价函数用以检查穿过地图上一点的代价有多难。</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">可以被改进从而知道到达一点的时间需求（通过当前路径长度来检查），而现在则轮到代价函数了。代价函数可以考虑时间，并用预测的障碍物位置检查在某个时刻地图某个位置是否可以通过。这个改进不是完美的，然而，因为它并不考虑在某个点等待障碍物自动离开的可能性，同时</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">并不区分到达相同目的地的不同的路径，而是针对不同的目的地，所以还是可以接受的。</span><span style="color: black"></span></p><h1 style="margin: 17pt 0cm 16.5pt; color: #ffffff; border-bottom-width: 0px; border-bottom-style: dashed; border-bottom-color: #cccccc; padding-left: 10px; font-size: 28px; font-family: Verdana, Helvetica, Arial; line-height: 20px; background-image: url('http://www.cnblogs.com/skins/redcross/images/bg_title.gif'); background-repeat: no-repeat"><a name="_Toc169180987"></a><span style="font-size: 12pt">6&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">预计算路径的空间代价</span><span style="font-size: 12pt"></span></h1><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">有时，路径计算的限制因素不是时间，而是用于数以百计的物体的存储空间。路径搜索器需要空间以运行算法和保存路径。算法运行所需的临时空间（在</span><span style="color: black">A*</span><span style="font-family: 宋体; color: black">中是</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集）通常比保存结果路径的空间大许多。通过限制在一定的时间计算一条路径，可以把临时空间数量最小化。另外，为</span><span style="color: black">OPEN</span><span style="font-family: 宋体; color: black">和</span><span style="color: black">CLOSED</span><span style="font-family: 宋体; color: black">集所选择的数据结构的不同，最小化临时空间的程度也有很大的不同。这一部分聚集于优化用于计算路径的空间代价。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180988"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">6.1&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">位置</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">VS</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">方向</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一条路径可以用位置或者方向来表示。位置需要更多的空间，但是有一个优点，易于查询路径中的任意位置或者方向而不用沿着路径移动。当保存方向时，只有方向容易被查询；只有沿着整个路径移动才能查询位置。在一个典形的网格地图中，位置可以被保存为两个</span><span style="color: black">16</span><span style="font-family: 宋体; color: black">位整数，每走一步是</span><span style="color: black">32</span><span style="font-family: 宋体; color: black">位。而方向是很少的，因此用极少的空间就够了。如果物体只能沿着四个方向移动，每一步用两位就够了；如果物体能沿着</span><span style="color: black">6</span><span style="font-family: 宋体; color: black">个或者</span><span style="color: black">8</span><span style="font-family: 宋体; color: black">个方向移动，每一步也只需要三位。这些对于保存路径中的位置都有明显的空间节省。</span><span style="color: black">Hannu Kankaanpaa</span><span style="font-family: 宋体; color: black">指出可以进一步减少空间需求，那就是保存相对方向（右旋</span><span style="color: black">60</span><span style="font-family: 宋体; color: black">度）而不是绝对方向（朝北走）。有些相对方向对某些物体来说意义不大。比如，如果你的物体朝北移动，那么下一步朝南移动的可能性很小。在只有六种方向的游戏中，你只有五个有意义的方向。在某些地图中，也许只有三个方向（直走，左旋</span><span style="color: black">60</span><span style="font-family: 宋体; color: black">度，右旋</span><span style="color: black">60</span><span style="font-family: 宋体; color: black">度）有意义，而其它地图中，右旋</span><span style="color: black">120</span><span style="font-family: 宋体; color: black">度是有效的（比如，沿着陡峭的山坡走之字形的路径时）。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180989"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">6.2&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">路径压缩</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一旦找到一条路径，可以对它进行压缩。可以用一个普通的压缩算法，但这里不进行讨论。使用特定的压缩算法可以缩小路径的存储，无论它是基于位置的还是基于方向的。在做决定之前，考察你的游戏中的路径以确定哪种压缩效果最好。另外还要考虑实现和调试，代码量，</span><span style="color: black">and whether it really matters.</span><span style="font-family: 宋体; color: black">如果你有</span><span style="color: black">300</span><span style="font-family: 宋体; color: black">个物体并且在同一时刻只有</span><span style="color: black">50</span><span style="font-family: 宋体; color: black">个在移动，同时路径比较短（</span><span style="color: black">100</span><span style="font-family: 宋体; color: black">步），内存总需求大概只有不到</span><span style="color: black">50k</span><span style="font-family: 宋体; color: black">，总之，没有必要担心压缩的效果。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180990"></a><span style="font-size: 12pt">6.2.1&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">位置存储</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在障碍物比地形对路径搜索影响更大的地图中，路径中有大部分是直线的。如果是这种情况，那么路径只需要包含直线部分的终止点（有时叫</span><span style="color: black">waypoints</span><span style="font-family: 宋体; color: black">）。此时移动过程将包含检查下一结点和沿着直线向前移动。</span><span style="color: black"></span></p><h3 style="font-size: 16px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; margin: 13pt 0cm; line-height: 20px"><a name="_Toc169180991"></a><span style="font-size: 12pt">6.2.2&nbsp;</span><span style="font-size: 12pt; font-family: 宋体">方向存储</span><span style="font-size: 12pt"></span></h3><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">保存方向时，有一种情况是同一个方向保存了很多次。可以用简单的方法节省空间。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一种方法是保存方向以及朝着该方向移动的次数。和位置存储的优化不同，当一个方向并不是移动很多次时，这种优化的效果反而不好。同样的，对于那些可以进行位置压缩的直线来说，方向压缩是行不通的，因为这条直线可能没有和正在移动的方向关联。通过相对方向，你可以把&ldquo;继续前进&rdquo;当作可能的方向排除掉。</span><span style="color: black">Hannu Kankaanpaa</span><span style="font-family: 宋体; color: black">指出，在一个八方向地图中，你可以去掉前，后，以及向左和向右</span><span style="color: black">135</span><span style="font-family: 宋体; color: black">度（假设你的地图允许这个），然后你可以仅用两个比特保存每个方向。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">另一种保存路径的方法是变长编码。这种想法是使用一个简单的比特（</span><span style="color: black">0</span><span style="font-family: 宋体; color: black">）保存最一般的步骤：向前走。使用一个&ldquo;</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">&rdquo;表示拐弯，后边再跟几个比特表示拐弯的方向。在一个四方向地图中，你只能左转和右转，因此可以用&ldquo;</span><span style="color: black">10</span><span style="font-family: 宋体; color: black">&rdquo;表示左转，&ldquo;</span><span style="color: black">11</span><span style="font-family: 宋体; color: black">&rdquo;表示右转。</span><span style="color: black"></span></p><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">变长编码比</span><span style="color: black">run length encoding</span><span style="font-family: 宋体; color: black">更一般，并且可以压缩得更好，但对于较长的直线路径则不然。序列（向北直走</span><span style="color: black">6</span><span style="font-family: 宋体; color: black">步，左转，直走</span><span style="color: black">3</span><span style="font-family: 宋体; color: black">步，右转，直走</span><span style="color: black">5</span><span style="font-family: 宋体; color: black">步，左转，直走</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">步）用</span><span style="color: black">run length encoding</span><span style="font-family: 宋体; color: black">表示是</span><span style="color: black">[(NORTH, 6), (WEST, 3), (NORTH, 5), (WEST, 2)]</span><span style="font-family: 宋体; color: black">。如果每个方向用</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">比特，每个距离用</span><span style="color: black">8</span><span style="font-family: 宋体; color: black">比特，保存这条路径需要</span><span style="color: black">40</span><span style="font-family: 宋体; color: black">比特。而对于变长编码，你用</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">比特表示每一步，</span><span style="color: black">2</span><span style="font-family: 宋体; color: black">比特表示拐弯&mdash;&mdash;</span><span style="color: black">[NORTH 0 0 0 0 0 0 10 0 0 0 11 0 0 0 0 0 10 0 0]</span><span style="font-family: 宋体; color: black">&mdash;&mdash;一共</span><span style="color: black">24</span><span style="font-family: 宋体; color: black">比特。如果初始方向和每次拐弯对应</span><span style="color: black">1</span><span style="font-family: 宋体; color: black">步，则每次拐弯都节省了一个比特，结果只需要</span><span style="color: black">20</span><span style="font-family: 宋体; color: black">比特保存这条路径。然而，用变长编码保存更长的路径时需要更多的空间。序列</span><span style="color: black">(</span><span style="font-family: 宋体; color: black">向北直走</span><span style="color: black">200</span><span style="font-family: 宋体; color: black">步</span><span style="color: black">)</span><span style="font-family: 宋体; color: black">用</span><span style="color: black">run length encoding</span><span style="font-family: 宋体; color: black">表示是</span><span style="color: black">[(NORTH, 200)]</span><span style="font-family: 宋体; color: black">，总共需要</span><span style="color: black">10</span><span style="font-family: 宋体; color: black">比特。用变长编码表示同样的序列则是</span><span style="color: black">[NORTH 0 0 ...]</span><span style="font-family: 宋体; color: black">，一共需要</span><span style="color: black">202</span><span style="font-family: 宋体; color: black">比特。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180992"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">6.3&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">计算导航点</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">一个导航点（</span><span style="color: black">waypoint</span><span style="font-family: 宋体; color: black">）是路径上的一个结点。与保存路径上的每一步不同，在进行路径搜索之后，一个后处理（</span><span style="color: black">post-processing</span><span style="font-family: 宋体; color: black">）的步骤可能会把若干步</span><span style="color: black">collapse</span><span style="font-family: 宋体; color: black">（译者：不好翻译，保留原单词）为一个简单的导航点，这经常发生在路径上那些方向发生改变的地方，或者在一个重要的（</span><span style="color: black">major</span><span style="font-family: 宋体; color: black">）位置如城市。然后运动算法将在两个导航点之间运行。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180993"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">6.4&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">极限路径长度</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">当地图中的条件或者秩序会发生改变时，保存一条长路径是没有意义的，因为在从某些点开始，后边的路径已经没有用了。每个物体都可以保存路径开始时的特定几步，然后当路径已经没用时重新计算路径。这种方法虑及了（</span><span style="color: black">allows for</span><span style="font-family: 宋体; color: black">）对每个物体使用数据的总量的管理。</span><span style="color: black"></span></p><h2 style="margin: 13pt 0cm; font-size: 21px; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify; line-height: 26.25px"><a name="_Toc169180994"></a><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'">6.5&nbsp;</span><span style="font-size: 12pt; line-height: 20px; font-family: 宋体">总结</span><span style="font-size: 12pt; line-height: 20px; font-family: 'Times New Roman'"></span></h2><p style="font-size: 13px; line-height: 19.5px; margin: 0cm 0cm 0pt; text-indent: 21pt; color: #303030; font-family: Verdana, Helvetica, Arial; text-align: justify" class="MsoNormal"><span style="font-family: 宋体; color: black">在游戏中，路径潜在地花费了许多存储空间，特别是当路径很长并且有很多物体需要寻路时。路径压缩，导航点和</span><span style="color: black">beacons</span><span style="font-family: 宋体; color: black">通过把多个步骤保存为一个较小数据从而减少了空间需求。</span><span style="color: black">Waypoints rely on straight-line segments being common so that we have to store only the endpoints, while beacons rely on there being well-known paths calculated beforehand between specially marked places on the map.</span><span style="font-family: 宋体; color: black">（译者：此处不好翻译，暂时保留原文）如果路径仍然用了许多存储空间，可以限制路径长度，这就回到了经典的时间</span><span style="color: black">-</span><span style="font-family: 宋体; color: black">空间折衷法：为了节省空间，信息可以被丢弃，稍后才重新计算它。</span></p> 
	</div>
	<div class="textbox-bottom">
	</div>
	<div class="tags" style="display: none">  
	</div>
</div>
<div id="commentWrapper" class="comment-wrapper">
	<a name="topreply"></a>
	<div id="addnew"></div>	<div class="comment-pages">
	
	</div>
</div>

					<div class="article-bottom" style="display: none">
						<div class="pages">
							
						</div>
					</div>
				</div>
			</div>
		<div id="sidebar" class="sidebar">
			<div id="innerSidebar">
				<div id="innerSidebarSearch">
					<form method="post" action="http://i.renjihe.com/blog/visit.php">
	<input name="job" type="hidden" value="search"/>
	<input name="keyword" class="search-field" type="text"/>
	<select name="searchmethod"><option value="1">日志标题</option><option value="2">日志全文</option><option value="3">评论引用</option><option value="4">所有留言</option></select>
	<input value="搜索" class="button" type="submit"/>
	</form>
				</div>
				<div id="innerSidebarOne">
					<div id='panelCategory' class="panel">
<h5 style="cursor: pointer" onclick='showhidediv("sideblock_category");'>分类</h5>
<div class="panel-content" id="sideblock_category" style="display: block">
<ul><li><a href="index.php-go=category_1.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_1" title="硬件">硬件</a> [1] <a href="feed.php-go=category_1" tppabs="http://i.renjihe.com/blog/feed.php?go=category_1"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_6.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_6" title="fpga/cpld">fpga/cpld</a> [10] <a href="feed.php-go=category_6" tppabs="http://i.renjihe.com/blog/feed.php?go=category_6"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_66.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_66" title="模电与电路">模电与电路</a> [1] <a href="feed.php-go=category_66" tppabs="http://i.renjihe.com/blog/feed.php?go=category_66"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_7.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_7" title="DSP">DSP</a> [14] <a href="feed.php-go=category_7" tppabs="http://i.renjihe.com/blog/feed.php?go=category_7"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_27.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_27" title="硬件知识">硬件知识</a> [26] <a href="feed.php-go=category_27" tppabs="http://i.renjihe.com/blog/feed.php?go=category_27"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_73.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_73" title="3D打印">3D打印</a> [1] <a href="feed.php-go=category_73" tppabs="http://i.renjihe.com/blog/feed.php?go=category_73"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_64.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_64" title="资讯">资讯</a> [18] <a href="feed.php-go=category_64" tppabs="http://i.renjihe.com/blog/feed.php?go=category_64"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_78.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_78" title="树莓派">树莓派</a> [5] <a href="feed.php-go=category_78" tppabs="http://i.renjihe.com/blog/feed.php?go=category_78"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_2.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_2" title="软件">软件</a> [0] <a href="feed.php-go=category_2.htm" tppabs="http://i.renjihe.com/blog/feed.php?go=category_2"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_9.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_9" title="linux">linux</a> [912] <a href="feed.php-go=category_9" tppabs="http://i.renjihe.com/blog/feed.php?go=category_9"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_14.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_14" title="QT">QT</a> [131] <a href="feed.php-go=category_14" tppabs="http://i.renjihe.com/blog/feed.php?go=category_14"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_82.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_82" title="Lua">Lua</a> [15] <a href="feed.php-go=category_82" tppabs="http://i.renjihe.com/blog/feed.php?go=category_82"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_15.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_15" title="Android">Android</a> [261] <a href="feed.php-go=category_15" tppabs="http://i.renjihe.com/blog/feed.php?go=category_15"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_65.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_65" title="Iphone">Iphone</a> [48] <a href="feed.php-go=category_65" tppabs="http://i.renjihe.com/blog/feed.php?go=category_65"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_32.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_32" title="windows">windows</a> [61] <a href="feed.php-go=category_32" tppabs="http://i.renjihe.com/blog/feed.php?go=category_32"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_31.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_31" title="webkit">webkit</a> [79] <a href="feed.php-go=category_31" tppabs="http://i.renjihe.com/blog/feed.php?go=category_31"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_10.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_10" title="C/C++">C/C++</a> [98] <a href="feed.php-go=category_10" tppabs="http://i.renjihe.com/blog/feed.php?go=category_10"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_29.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_29" title="lisp、Erlang">Erlang、Lisp</a> [28] <a href="feed.php-go=category_29" tppabs="http://i.renjihe.com/blog/feed.php?go=category_29"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_46.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_46" title="Python">Python</a> [255] <a href="feed.php-go=category_46" tppabs="http://i.renjihe.com/blog/feed.php?go=category_46"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_18.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_18" title="Java">Java</a> [25] <a href="feed.php-go=category_18" tppabs="http://i.renjihe.com/blog/feed.php?go=category_18"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_13.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_13" title="web">web</a> [486] <a href="feed.php-go=category_13" tppabs="http://i.renjihe.com/blog/feed.php?go=category_13"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_50.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_50" title="测试">测试</a> [12] <a href="feed.php-go=category_50" tppabs="http://i.renjihe.com/blog/feed.php?go=category_50"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_23.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_23" title="源码分析">源码分析</a> [85] <a href="feed.php-go=category_23" tppabs="http://i.renjihe.com/blog/feed.php?go=category_23"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_19.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_19" title="编译原理">编译原理</a> [82] <a href="feed.php-go=category_19" tppabs="http://i.renjihe.com/blog/feed.php?go=category_19"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_83.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_83" title="黑客">黑客</a> [4] <a href="feed.php-go=category_83" tppabs="http://i.renjihe.com/blog/feed.php?go=category_83"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_39.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_39" title="GPU编程">GPU编程</a> [89] <a href="feed.php-go=category_39" tppabs="http://i.renjihe.com/blog/feed.php?go=category_39"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_48.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_48" title="OpenGL">OpenGL</a> [117] <a href="feed.php-go=category_48" tppabs="http://i.renjihe.com/blog/feed.php?go=category_48"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_52.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_52" title="OpenCV">OpenCV</a> [18] <a href="feed.php-go=category_52" tppabs="http://i.renjihe.com/blog/feed.php?go=category_52"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_20.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_20" title="音视频与流媒体">音视频与流媒体</a> [412] <a href="feed.php-go=category_20" tppabs="http://i.renjihe.com/blog/feed.php?go=category_20"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_62.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_62" title="游戏">游戏</a> [455] <a href="feed.php-go=category_62" tppabs="http://i.renjihe.com/blog/feed.php?go=category_62"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_54.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_54" title="FLEX&AS">FLEX&amp;AS</a> [124] <a href="feed.php-go=category_54" tppabs="http://i.renjihe.com/blog/feed.php?go=category_54"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_61.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_61" title="编程杂项">编程杂项</a> [55] <a href="feed.php-go=category_61" tppabs="http://i.renjihe.com/blog/feed.php?go=category_61"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_57.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_57" title="网络安全">网络安全</a> [43] <a href="feed.php-go=category_57" tppabs="http://i.renjihe.com/blog/feed.php?go=category_57"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_28.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_28" title="软件工程">软件工程</a> [40] <a href="feed.php-go=category_28" tppabs="http://i.renjihe.com/blog/feed.php?go=category_28"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_74.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_74" title="并行编程">并行编程</a> [4] <a href="feed.php-go=category_74" tppabs="http://i.renjihe.com/blog/feed.php?go=category_74"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_77.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_77" title="大数据">大数据</a> [10] <a href="feed.php-go=category_77" tppabs="http://i.renjihe.com/blog/feed.php?go=category_77"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_37.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_37" title="理论">理论</a> [0] <a href="feed.php-go=category_37.htm" tppabs="http://i.renjihe.com/blog/feed.php?go=category_37"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_38.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_38" title="数学">数学</a> [75] <a href="feed.php-go=category_38" tppabs="http://i.renjihe.com/blog/feed.php?go=category_38"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_43.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_43" title="物理">物理</a> [19] <a href="feed.php-go=category_43" tppabs="http://i.renjihe.com/blog/feed.php?go=category_43"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_24.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_24" title="算法">算法</a> [80] <a href="feed.php-go=category_24" tppabs="http://i.renjihe.com/blog/feed.php?go=category_24"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_40.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_40" title="音频处理">音频处理</a> [3] <a href="feed.php-go=category_40" tppabs="http://i.renjihe.com/blog/feed.php?go=category_40"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_36.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_36" title="CV&Graphic">CV&amp;Graphic</a> [183] <a href="feed.php-go=category_36" tppabs="http://i.renjihe.com/blog/feed.php?go=category_36"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li class="indent"><a href="index.php-go=category_35.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_35" title="AR&AI&模式识别">AR&amp;AI&amp;模式识别</a> [127] <a href="feed.php-go=category_35" tppabs="http://i.renjihe.com/blog/feed.php?go=category_35"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_26.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_26" title="工具">工具</a> [56] <a href="feed.php-go=category_26" tppabs="http://i.renjihe.com/blog/feed.php?go=category_26"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_3.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_3" title="新鲜玩意">新鲜玩意</a> [446] <a href="feed.php-go=category_3" tppabs="http://i.renjihe.com/blog/feed.php?go=category_3"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_63.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_63" title="行业应用">行业应用</a> [6] <a href="feed.php-go=category_63" tppabs="http://i.renjihe.com/blog/feed.php?go=category_63"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_4.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_4" title="资讯">资讯</a> [137] <a href="feed.php-go=category_4" tppabs="http://i.renjihe.com/blog/feed.php?go=category_4"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_12.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_12" title="网文">网文</a> [622] <a href="feed.php-go=category_12" tppabs="http://i.renjihe.com/blog/feed.php?go=category_12"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_41.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_41" title="点子正传">点子正传</a> [20] <a href="feed.php-go=category_41" tppabs="http://i.renjihe.com/blog/feed.php?go=category_41"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_56.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_56" title="理财">理财</a> [24] <a href="feed.php-go=category_56" tppabs="http://i.renjihe.com/blog/feed.php?go=category_56"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_55.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_55" title="收集">收集</a> [157] <a href="feed.php-go=category_55" tppabs="http://i.renjihe.com/blog/feed.php?go=category_55"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_71.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_71" title="创业">创业</a> [405] <a href="feed.php-go=category_71" tppabs="http://i.renjihe.com/blog/feed.php?go=category_71"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_80.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_80" title="共享软件">共享软件</a> [12] <a href="feed.php-go=category_80" tppabs="http://i.renjihe.com/blog/feed.php?go=category_80"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_72.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_72" title="创意">创意</a> [20] <a href="feed.php-go=category_72" tppabs="http://i.renjihe.com/blog/feed.php?go=category_72"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_85.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_85" title="星象命理">星象命理</a> [40] <a href="feed.php-go=category_85" tppabs="http://i.renjihe.com/blog/feed.php?go=category_85"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_11.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_11" title="杂项">杂项</a> [50] <a href="feed.php-go=category_11" tppabs="http://i.renjihe.com/blog/feed.php?go=category_11"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_58.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_58" title="记录">记录</a> [26] <a href="feed.php-go=category_58" tppabs="http://i.renjihe.com/blog/feed.php?go=category_58"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_79.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_79" title="心灵鸡汤">心灵鸡汤</a> [78] <a href="feed.php-go=category_79" tppabs="http://i.renjihe.com/blog/feed.php?go=category_79"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_75.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_75" title="文学">文学</a> [9] <a href="feed.php-go=category_75" tppabs="http://i.renjihe.com/blog/feed.php?go=category_75"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_67.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_67" title="其它工程资料">其它工程资料</a> [2] <a href="feed.php-go=category_67" tppabs="http://i.renjihe.com/blog/feed.php?go=category_67"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_84.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_84" title="哲学">哲学</a> [24] <a href="feed.php-go=category_84" tppabs="http://i.renjihe.com/blog/feed.php?go=category_84"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_87.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_87" title="有言">有言</a> [9] <a href="feed.php-go=category_87" tppabs="http://i.renjihe.com/blog/feed.php?go=category_87"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_88.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_88" title="微语录">微语录</a> [15] <a href="feed.php-go=category_88" tppabs="http://i.renjihe.com/blog/feed.php?go=category_88"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_76.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_76" title="置顶">置顶</a> [440] <a href="feed.php-go=category_76" tppabs="http://i.renjihe.com/blog/feed.php?go=category_76"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_86.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_86" title="励志">励志</a> [10] <a href="feed.php-go=category_86" tppabs="http://i.renjihe.com/blog/feed.php?go=category_86"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li><li><a href="index.php-go=category_81.htm" tppabs="http://i.renjihe.com/blog/index.php?go=category_81" title="资源管理">资源管理</a> [1] <a href="feed.php-go=category_81" tppabs="http://i.renjihe.com/blog/feed.php?go=category_81"><img src="rss.png" tppabs="http://i.renjihe.com/blog/template/default/images/rss.png" border="0" alt="RSS" title="追踪这个分类的RSS" /></a></li></ul>
</div>
</div><div class="panel">
<h5 onclick='showhidediv("sidebar_calendar");'>日历</h5>
<div class="panel-content" id="sidebar_calendar" style="display: block">
<table id="calendar" cellspacing="1" width="100%">
<tbody><tr><td colspan="7" class="calendar-top">
<a href="index.php-go=archive&cm=9&cy=2015.htm" tppabs="http://i.renjihe.com/blog/index.php?go=archive&cm=9&cy=2015" rel="noindex,nofollow">&lt;</a>
<a href="archive.php.htm" tppabs="http://i.renjihe.com/blog/archive.php" rel="noindex,nofollow"><span class="calendar-year">2016</span></a>
<a href="index.php-go=archive&cm=9&cy=2017.htm" tppabs="http://i.renjihe.com/blog/index.php?go=archive&cm=9&cy=2017" rel="noindex,nofollow">&gt;</a>
	&nbsp;&nbsp;
<a href="index.php-go=archive&cm=8&cy=2016.htm" tppabs="http://i.renjihe.com/blog/index.php?go=archive&cm=8&cy=2016" rel="noindex,nofollow">&lt;</a>
<a href="index.php-go=archive&cm=9&cy=2016.htm" tppabs="http://i.renjihe.com/blog/index.php?go=archive&cm=9&cy=2016" rel="noindex,nofollow"><span class="calendar-month">9</span></a>
<a href="index.php-go=archive&cm=10&cy=2016.htm" tppabs="http://i.renjihe.com/blog/index.php?go=archive&cm=10&cy=2016" rel="noindex,nofollow">&gt;</a>
</td></tr>
<tr class="calendar-weekdays">
	<td class="calendar-weekday-cell">日</td>
	<td class="calendar-weekday-cell">一</td>
	<td class="calendar-weekday-cell">二</td>
	<td class="calendar-weekday-cell">三</td>
	<td class="calendar-weekday-cell">四</td>
	<td class="calendar-weekday-cell">五</td>
	<td class="calendar-weekday-cell">六</td>
</tr>
<tr class="calendar-weekdays"><td class="calendar-sunday"></td><td class="calendar-day"></td><td class="calendar-day"></td><td class="calendar-day"></td><td id="cal1" class="calendar-day"><a href="index.php-go=showday_2016-9-1.htm" tppabs="http://i.renjihe.com/blog/index.php?go=showday_2016-9-1" rel="noindex,nofollow">1</a></td><td id="cal2" class="calendar-day">2</td><td id="cal3" class="calendar-today">3</td></tr><tr class="calendar-weekdays"><td id="cal4" class="calendar-sunday">4</td><td id="cal5" class="calendar-day">5</td><td id="cal6" class="calendar-day">6</td><td id="cal7" class="calendar-day">7</td><td id="cal8" class="calendar-day">8</td><td id="cal9" class="calendar-day">9</td><td id="cal10" class="calendar-saturday">10</td></tr><tr class="calendar-weekdays"><td id="cal11" class="calendar-sunday">11</td><td id="cal12" class="calendar-day">12</td><td id="cal13" class="calendar-day">13</td><td id="cal14" class="calendar-day">14</td><td id="cal15" class="calendar-day">15</td><td id="cal16" class="calendar-day">16</td><td id="cal17" class="calendar-saturday">17</td></tr><tr class="calendar-weekdays"><td id="cal18" class="calendar-sunday">18</td><td id="cal19" class="calendar-day">19</td><td id="cal20" class="calendar-day">20</td><td id="cal21" class="calendar-day">21</td><td id="cal22" class="calendar-day">22</td><td id="cal23" class="calendar-day">23</td><td id="cal24" class="calendar-saturday">24</td></tr><tr class="calendar-weekdays"><td id="cal25" class="calendar-sunday">25</td><td id="cal26" class="calendar-day">26</td><td id="cal27" class="calendar-day">27</td><td id="cal28" class="calendar-day">28</td><td id="cal29" class="calendar-day">29</td><td id="cal30" class="calendar-day">30</td><td class="calendar-saturday"></td></tr>
</tbody></table>
</div>
</div><div class="panel">
<h5 onclick='showhidediv("sidebar_statistics");'>统计</h5>
<div class="panel-content" id="sidebar_statistics" style="display: block">
访问次数 133640<br/>今日访问 1<br/>日志数量 7121<br/><a href="guestbook.php.htm" tppabs="http://i.renjihe.com/blog/guestbook.php">留言数量 2</a><br/>在线人数 1<br/>
</div>
</div><div class="panel">
<h5 onclick='showhidediv("sidebar_entries");'>最新日志</h5>
<div class="panel-content" id="sidebar_entries" style="display: block">
<ul><li class='rowcouple'><a href="read.php-7527.htm" tppabs="http://i.renjihe.com/blog/read.php?7527" title="mysql优化之索引优化">mysql优化之索引优化</a></li><li class='rowodd'><a href="read.php-7526.htm" tppabs="http://i.renjihe.com/blog/read.php?7526" title="Mysql limit 优化，百万至千万级快速分页，--复合索引的引用并应用于轻量级框架&nbsp;&nbsp;">Mysql limit ...</a></li><li class='rowcouple'><a href="read.php-7525.htm" tppabs="http://i.renjihe.com/blog/read.php?7525" title="mysql sql语句执行时间查询">mysql sql语句执...</a></li><li class='rowodd'><a href="read.php-7524.htm" tppabs="http://i.renjihe.com/blog/read.php?7524" title="GeoHash核心原理解析">GeoHash核心原理解...</a></li><li class='rowcouple'><a href="read.php-7523.htm" tppabs="http://i.renjihe.com/blog/read.php?7523" title="如何实现按距离排序、范围查找">如何实现按距离排序、范围...</a></li></ul>
</div>
</div>
				</div>
				<div id="innerSidebarTwo">
					<div class="panel">
<h5 onclick='showhidediv("sidebar_link");'>链接</h5>
<div class="panel-content" id="sidebar_link" style="display: block">
<ul><li><strong>协会</strong></li><li class="indent"><a href="javascript:if(confirm('http://www.siggraph.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.siggraph.org/'" tppabs="http://www.siggraph.org/" target="_blank" title="siggraph - ">siggraph</a></li><li class="indent"><a href="javascript:if(confirm('http://www.siggraph.org.cn/Pages/index.aspx  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.siggraph.org.cn/Pages/index.aspx'" tppabs="http://www.siggraph.org.cn/Pages/index.aspx" target="_blank" title="siggraph中国 - ">siggraph中国</a></li><li class="indent"><a href="javascript:if(confirm('http://www.igf.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.igf.com/'" tppabs="http://www.igf.com/" target="_blank" title="独立游戏节 - ">独立游戏节</a></li><li><strong>项目</strong></li><li class="indent"><a href="javascript:if(confirm('http://youyur.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://youyur.com/'" tppabs="http://youyur.com/" target="_blank" title="有鱼 - ">有鱼</a></li><li class="indent"><a href="javascript:if(confirm('http://codecanyon.net/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://codecanyon.net/'" tppabs="http://codecanyon.net/" target="_blank" title="codecanyon - ">codecanyon</a></li><li class="indent"><a href="javascript:if(confirm('http://www.sxsoft.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.sxsoft.com/'" tppabs="http://www.sxsoft.com/" target="_blank" title="软件项目交易网 - ">软件项目交易网</a></li><li class="indent"><a href="javascript:if(confirm('http://www.csto.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.csto.com/'" tppabs="http://www.csto.com/" target="_blank" title="csto - ">csto</a></li><li class="indent"><a href="javascript:if(confirm('http://themeforest.net/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://themeforest.net/'" tppabs="http://themeforest.net/" target="_blank" title="themeforest - ">themeforest</a></li><li class="indent"><a href="javascript:if(confirm('http://www.digitalriver.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.digitalriver.com/'" tppabs="http://www.digitalriver.com/" target="_blank" title="Digital River - ">Digital River</a></li><li class="indent"><a href="javascript:if(confirm('http://www.vworker.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.vworker.com/'" tppabs="http://www.vworker.com/" target="_blank" title="vworker - ">vworker</a></li><li class="indent"><a href="javascript:if(confirm('http://luexiao.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://luexiao.com/'" tppabs="http://luexiao.com/" target="_blank" title="略晓 - ">略晓</a></li><li class="indent"><a href="javascript:if(confirm('http://www.yateshi.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.yateshi.com/'" tppabs="http://www.yateshi.com/" target="_blank" title="雅特士外包网  - ">雅特士外包网 </a></li><li class="indent"><a href="javascript:if(confirm('http://wpappstore.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://wpappstore.com/'" tppabs="http://wpappstore.com/" target="_blank" title="WP App Store - ">WP App Store</a></li><li class="indent"><a href="javascript:if(confirm('http://store.steampowered.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://store.steampowered.com/'" tppabs="http://store.steampowered.com/" target="_blank" title="Steam - ">Steam</a></li><li class="indent"><a href="javascript:if(confirm('http://www.taskcity.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.taskcity.com/'" tppabs="http://www.taskcity.com/" target="_blank" title="TaskCity - ">TaskCity</a></li><li class="indent"><a href="javascript:if(confirm('http://www.istockphoto.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.istockphoto.com/'" tppabs="http://www.istockphoto.com/" target="_blank" title="iStockphoto - ">iStockphoto</a></li><li class="indent"><a href="javascript:if(confirm('http://envato.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://envato.com/'" tppabs="http://envato.com/" target="_blank" title="Envato - ">Envato</a></li><li class="indent"><a href="javascript:if(confirm('https://tutsplus.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://tutsplus.com/'" tppabs="https://tutsplus.com/" target="_blank" title="Tuts+ Premium - ">Tuts+ Premium</a></li><li class="indent"><a href="javascript:if(confirm('http://www.sharebank.com.cn/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.sharebank.com.cn/'" tppabs="http://www.sharebank.com.cn/" target="_blank" title="软行天下  - ">软行天下 </a></li><li class="indent"><a href="javascript:if(confirm('http://www.softreg.com.cn/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.softreg.com.cn/'" tppabs="http://www.softreg.com.cn/" target="_blank" title="中国共享软件注册中心 - ">中国共享软件注册中心</a></li><li class="indent"><a href="javascript:if(confirm('https://www.elance.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.elance.com/'" tppabs="https://www.elance.com/" target="_blank" title="Elance - ">Elance</a></li><li class="indent"><a href="javascript:if(confirm('http://www.freelancer.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.freelancer.com/'" tppabs="http://www.freelancer.com/" target="_blank" title="freelancer - ">freelancer</a></li><li class="indent"><a href="javascript:if(confirm('http://www.bizsofts.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.bizsofts.com/'" tppabs="http://www.bizsofts.com/" target="_blank" title="软件商务网 - ">软件商务网</a></li><li class="indent"><a href="javascript:if(confirm('https://www.odesk.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.odesk.com/'" tppabs="https://www.odesk.com/" target="_blank" title="oDesk - ">oDesk</a></li><li class="indent"><a href="javascript:if(confirm('http://store.raspberrypi.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://store.raspberrypi.com/'" tppabs="http://store.raspberrypi.com/" target="_blank" title="树莓派商店 - ">树莓派商店</a></li><li><strong>杂项</strong></li><li class="indent"><a href="javascript:if(confirm('http://www.codinghorror.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.codinghorror.com/'" tppabs="http://www.codinghorror.com/" target="_blank" title="codinghorror - ">codinghorror</a></li><li class="indent"><a href="javascript:if(confirm('http://www.fabiensanglard.net/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.fabiensanglard.net/'" tppabs="http://www.fabiensanglard.net/" target="_blank" title="fabiensanglard - ">fabiensanglard</a></li><li class="indent"><a href="javascript:if(confirm('http://www.intel.com/intelpress/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.intel.com/intelpress/'" tppabs="http://www.intel.com/intelpress/" target="_blank" title="英特尔出版社 - ">英特尔出版社</a></li><li class="indent"><a href="javascript:if(confirm('http://www.opencart.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.opencart.com/'" tppabs="http://www.opencart.com/" target="_blank" title="OpenCart - ">OpenCart</a></li><li class="indent"><a href="javascript:if(confirm('http://www.appinn.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.appinn.com/'" tppabs="http://www.appinn.com/" target="_blank" title="小众软件 - ">小众软件</a></li><li class="indent"><a href="javascript:if(confirm('http://renderhjs.net/shoebox/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://renderhjs.net/shoebox/'" tppabs="http://renderhjs.net/shoebox/" target="_blank" title="shoebox工具 - ">shoebox工具</a></li><li><strong>个人</strong></li><li><strong>阅读</strong></li><li class="indent"><a href="javascript:if(confirm('http://huaban.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://huaban.com/'" tppabs="http://huaban.com/" target="_blank" title="花瓣网 - ">花瓣网</a></li><li class="indent"><a href="javascript:if(confirm('http://www.oralstudy.cn/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.oralstudy.cn/'" tppabs="http://www.oralstudy.cn/" target="_blank" title="英语口语学习网 - ">英语口语学习网</a></li><li class="indent"><a href="javascript:if(confirm('http://www.dspguide.com/pdfbook.htm  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.dspguide.com/pdfbook.htm'" tppabs="http://www.dspguide.com/pdfbook.htm" target="_blank" title="DSP Guide - ">DSP Guide</a></li><li><strong>在线文档</strong></li><li class="indent"><a href="javascript:if(confirm('http://help.adobe.com/zh_CN/flex/mobileapps/index.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://help.adobe.com/zh_CN/flex/mobileapps/index.html'" tppabs="http://help.adobe.com/zh_CN/flex/mobileapps/index.html" target="_blank" title="Flex移动开发 - ">Flex移动开发</a></li><li class="indent"><a href="javascript:if(confirm('http://help.adobe.com/zh_CN/as3/learn/index.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://help.adobe.com/zh_CN/as3/learn/index.html'" tppabs="http://help.adobe.com/zh_CN/as3/learn/index.html" target="_blank" title="Flex AS3 - ">Flex AS3</a></li><li class="indent"><a href="javascript:if(confirm('http://www.adobe.com/cn/devnet.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.adobe.com/cn/devnet.html'" tppabs="http://www.adobe.com/cn/devnet.html" target="_blank" title="Adobe开发者中心 - ">Adobe开发者中心</a></li><li class="indent"><a href="javascript:if(confirm('http://help.adobe.com/zh_CN/FlashPlatform/reference/actionscript/3/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://help.adobe.com/zh_CN/FlashPlatform/reference/actionscript/3/'" tppabs="http://help.adobe.com/zh_CN/FlashPlatform/reference/actionscript/3/" target="_blank" title="ActionScript3.0参考 - ">ActionScript3.0参考</a></li><li class="indent"><a href="javascript:if(confirm('http://help.adobe.com/zh_CN/as3/dev/index.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://help.adobe.com/zh_CN/as3/dev/index.html'" tppabs="http://help.adobe.com/zh_CN/as3/dev/index.html" target="_blank" title="ActionScript 3.0 - ">ActionScript 3.0</a></li><li class="indent"><a href="javascript:if(confirm('http://help.adobe.com/zh_CN/air/build/index.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://help.adobe.com/zh_CN/air/build/index.html'" tppabs="http://help.adobe.com/zh_CN/air/build/index.html" target="_blank" title="AIR - ">AIR</a></li><li class="indent"><a href="javascript:if(confirm('http://www.ppurl.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.ppurl.com/'" tppabs="http://www.ppurl.com/" target="_blank" title="皮皮书屋 - ">皮皮书屋</a></li><li class="indent"><a href="javascript:if(confirm('http://science.scileaf.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://science.scileaf.com/'" tppabs="http://science.scileaf.com/" target="_blank" title="四叶科学百科 - ">四叶科学百科</a></li><li><strong>临时</strong></li><li class="indent"><a href="javascript:if(confirm('http://www.uisdc.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.uisdc.com/'" tppabs="http://www.uisdc.com/" target="_blank" title="优设 - ">优设</a></li><li class="indent"><a href="javascript:if(confirm('http://www.genesis-3d.com.cn/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.genesis-3d.com.cn/'" tppabs="http://www.genesis-3d.com.cn/" target="_blank" title="genesis-3d - ">genesis-3d</a></li><li class="indent"><a href="javascript:if(confirm('http://designlol.net/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://designlol.net/'" tppabs="http://designlol.net/" target="_blank" title="designlol - ">designlol</a></li></ul>
</div>
</div><div class="panel">
<h5 onclick='showhidediv("sidebar_misc");'>其他</h5>
<div class="panel-content" id="sidebar_misc" style="display: block">
<a href="login.php.htm" tppabs="http://i.renjihe.com/blog/login.php">登入</a><br/><a href="login.php-job=register.htm" tppabs="http://i.renjihe.com/blog/login.php?job=register">注册</a><br/>RSS： <a href="feed.php" tppabs="http://i.renjihe.com/blog/feed.php">日志</a> | <a href="feed.php-go=comment.htm" tppabs="http://i.renjihe.com/blog/feed.php?go=comment">评论</a><br/>编码：UTF-8<br/><a href="javascript:if(confirm('http://validator.w3.org/check?uri=referer  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://validator.w3.org/check?uri=referer'" tppabs="http://validator.w3.org/check?uri=referer" target="_blank">XHTML 1.0</a>
</div>
</div>
				</div>
				<div id="innerSidebarFooter">
				 Powered by <a href="javascript:if(confirm('http://www.bo-blog.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.bo-blog.com/'" tppabs="http://www.bo-blog.com/" target="_blank">Bo-Blog 2.1.1 Release</a><span id="footer-security"><a href="javascript:if(confirm('http://www.cnbct.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.cnbct.org/'" tppabs="http://www.cnbct.org/" target="_blank" title="Code detection by Bug.Center.Team"><img src="detect.gif" tppabs="http://i.renjihe.com/blog/images/others/detect.gif" alt="Code detection by Bug.Center.Team" border="0" /></a></span>
				<div id="processtime">
				</div>
				</div>
			</div>
		</div>
	</div>
		<div id="footer">
		</div>
	</div>
</div>
<script type="text/javascript">
loadSidebar();
</script>
<script type='text/javascript'>
//<![CDATA[
if (document.getElementById('processtime')) document.getElementById('processtime').innerHTML="<span class='runtimedisplay'>Run in 127 ms, 6 Queries.</span>";
//]]>
</script></body>
</html>