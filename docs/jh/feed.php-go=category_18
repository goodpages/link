<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?4101</link>
<title><![CDATA[走进JVM，浅水也能捉鱼]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Tue, 18 Dec 2012 09:46:12 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4101</guid> 
<description>
<![CDATA[ 
	这不是一篇描述jvm是什么的文章，也不介绍jvm跨平台的特性，也不是讲述jvm安全特性的文章，更不是讲解jvm指令操作，数据运算的文章，本文重点讲述类型的生命周期。 <p>　　类型的生命周期涉及到：类的装载、jvm体系结构、垃圾回收机制。</p><p>　　为什么要讲jvm体系结构？因为类的装载和垃圾回收机制都和jvm体系结构息息相关。</p><p>　　那么什么是jvm体系结构呢？<br /><img class="insertimage" src="attachment.php?fid=1345" border="0" width="601" height="382" /></p><p>　　当jvm运行起来的时候，它会向系统申请一片内存区（不同的jvm实现可能不同，有些可以使用虚拟内存），将这块内存分出一部分存储许多东西，例如：程序创建的对象，传递给方法的参数，返回值，局部变量等等，我们将这块内存称之为运行时数据区，运行时数据区可以划分成方法区、堆、java栈、pc寄存器、本地方法栈。看到上面这幅图，和这些解说你可能大概的明白jvm体系是个啥样子，但是你或许还不了解运行时数据区里面方法区等用来干嘛的。</p><ul><li>方法区：当虚拟机装载一个class文件的时候，它会从这个class文件包含的二进制数据中解析类型信息，然后将这些类型信息放到方法区中。因为方法区是被所有线程共享的，所以必须考虑数据的线程安全。假如两个线程都在试图找lava的类，在lava类还没有被加载的情况下，只应该有一个线程去加载，而另一个线程等待。</li><li>PC寄存器：每个新线程产生都将得到自己的pc寄存器以及一个java栈帧。</li><li>堆：存放程序运行时产生的所有对象。堆是一个线程共享的内存区，所以我们写多线程程序的时候需要考虑并发。</li><li>Java栈：java栈由许多栈帧组成的，如图，当一个线程调用java方法时，虚拟机压入一个新的栈帧到java栈中，当方法返回的时候，这个栈帧被从java栈弹出并被抛弃。<br /><img class="insertimage" src="attachment.php?fid=1346" border="0" width="607" height="277" /></li></ul><p>　　那么现在你应该可以想象到一些jvm是怎么工作的了，是不是应该接着讲具体工作原理了呢？。但是不急，先了解下类的装载机制。</p><p>　　了解类的装载机制之前先了解jvm里面的类装载器：BootstrapLoader、ExtClassLoader、AppClassLoader；ExtClassLoader（负责装载jre下面的rt.jar,charsets.jar）和AppClassLoader(负责转载classpath下面的类包)是ClassLoader（抽象类）的子类；</p><p>　　BootstrapLoader（负责装载jre核心类库）是根装载器，是c/c++写的，在java里面看不到它。</p><p>　　这三个类装载器存在父子关系，根装载器是ExtClassLoader父装载器，ExtClassLoader是AppClassLoader父装载器；</p><p>　　Jvm中类的装载也是安全机制沙箱模型的第一道门槛。Java装载类使用双亲委派模式即全盘负责委托机制。好现在让我们了解装载大概流程。</p><p>　　当装载一个类的时候，若是由用户指定一个类装载器装载的话，那么那个类装载器会先委派给父类装载器，一直委派到根装载器，如果装载的是一个java.lang.String，由于它是核心类库的而且已经被装载过了，那么就会直接返回一个class对象，那么如果是一个根装载器找不到的类呢？接着就会交给子类（下一级父类）装载器，如果还是没有找到类文件，接着就会由之前用户指定的那个类装载器装载。（这里没有说明装载超类的过程，请勿疏忽）。</p><p>　　如果是有人恶意的写了一个基础类java.lang.String，那么会影响虚拟机吗？不会因为这个类最终会交由根装载器装载，而根装载器只会去jre核心类库加载，最终返回的class类型并不是用户写的String，而且系统自带的String，也就是说用户写String永远不会被加载。</p><p>　　了解了类装载器是怎么工作了之后，我们也需要了解下class文件格式；</p><div class="cnblogs_code"><div><span style="color: #000000">TheClassFileStructure<br />ClassFile&#123;<br />u4magic;</span><span style="color: #008000">//</span><span style="color: #008000">魔数</span><span style="color: #008000"><br /></span><span style="color: #000000">u2minor_version;</span><span style="color: #008000">//</span><span style="color: #008000">class次版本号</span><span style="color: #008000"><br /></span><span style="color: #000000">u2major_version;</span><span style="color: #008000">//</span><span style="color: #008000">class主版本号</span><span style="color: #008000"><br /></span><span style="color: #000000">u2constant_pool_count;</span><span style="color: #008000">//</span><span style="color: #008000">常量池计数</span><span style="color: #008000"><br /></span><span style="color: #000000">cp_infoconstant_pool[constant_pool_count</span><span style="color: #000000">-</span><span style="color: #000000">1</span><span style="color: #000000">];</span><span style="color: #008000">//</span><span style="color: #008000">常量池</span><span style="color: #008000"><br /></span><span style="color: #000000">u2access_flags;</span><span style="color: #008000">//</span><span style="color: #008000">修饰符</span><span style="color: #008000"><br /></span><span style="color: #000000">u2this_class;</span><span style="color: #008000">//</span><span style="color: #008000">常量池索引</span><span style="color: #008000"><br /></span><span style="color: #000000">u2interfaces_count;<br />u2interfaces[interfaces_count];<br />u2fields_count;<br />field_infofields[fields_count];<br />u2methods_count;<br />method_infomethods[methods_count];<br />u2attributes_count;<br />attribute_infoattributes[attrributes_count];<br />&#125;</span></div></div><p>　　我们需要了解的有很多，但是我们难以理解的就是cp_infoconstant_pool常量池。</p><p>　　一个常量池里面有很多表：</p><blockquote>　　CONSTANT_Utf8 UTF-8编码的Unicode字符串<br />&nbsp;　　CONSTANT_Integer int类型的字面值<br />&nbsp;　　CONSTANT_Float float类型的字面值<br />&nbsp;　　CONSTANT_Long long类型的字面值<br />&nbsp;　　CONSTANT_Double double类型的字面值<br />&nbsp;　　CONSTANT_Class 对一个类或接口的符号引用<br />&nbsp;　　CONSTANT_String String类型字面值的引用<br />&nbsp;　　CONSTANT_Field ref对一个字段的符号引用<br />&nbsp;　　CONSTANT_Method ref对一个类中方法的符号引用<br />&nbsp;　　CONSTANT_InterfaceMethod ref对一个接口中方法的符号引用<br />&nbsp;　　CONSTANT_NameAndType 对一个字段或方法的部分符号引用</blockquote><p>　　这些表结构我也不解释了，如果对class文件不够了解也没什么关系，知道个大概也行。那么我们了解了jvm体系，类装载器工作流程，那么我们细看下类装载器工作中，jvm运行时数据区的变化，方法区里面的结构等等。</p><p>　　在类装载的过程中，每一个类装载器都会在方法区里面形成一张表，这张表记载着该装载器和对应的类的权限定名。没这么一张表就形成了jvm内部的命名空间。同时在方法区里面还该类的常量池等信息。</p><p>　　那么说到这些，其实这个过程还是很模糊，而且很多知识也落下了，那么我们现在看一个详细一点的装载过程。</p><p>　　当装载一个普通的类的时候，即调用类装载器的loadClass方法，如果希望装载的类还没有被装载到命名空间，那么jvm会传递一个该类型的全限定名给类装载器，也就是常量池CONSTANT_Class_info（该表存储着父类、类装载器等信息）入口的装载器，来试图装载被引用的类型，如果发起引用的类型是被jvm装载器定义的，那么由jvm类装载器装载，否则由用户自定义装载器装载，那么一旦被引用的类型被装载了，jvm仔细检查它的二进制数据，如果类是是一个类，并且不是java.lang.Object。jvm根据数据得到它的全限定名进行装载（递归的应用了）这个过程还需要递归超接口。</p><p>　　装载差不多讲完了，一个完整的过程是：装载连接&mdash;&mdash;初始化。</p><p>　　那么连接和初始化就一带而过了，重点放在垃圾回收。</p><p>　　连接的过程主要是验证（确认类型符合java语言的语义，并且它不会危及虚拟机的完整性）、准备（java虚拟机为类变量分配内存，设计默认初始值）、解析（在类型的常量池中寻找类、接口、字段和方法的符合引用，把这些符号引用替换成直接引用的过程）。</p><p>　　初始化的时候，如果类存在直接超类，且超类还没有被初始化，就先初始化直接超类。初始化接口并不需要初始化它的父接口。</p><p>　　<strong>补充：</strong></p><p>　　Jvm当运行某个方法的时候，先把这个方法压入java栈中，里面包含局部变量等信息，那么对象放入哪里呢？压入栈的是对象的引用，即变量，所有的对象都存储在堆中。</p><p>　　为什么要把对象放入堆，把变量之类的数据放入栈呢？说白了，对象太大了，存入栈中运算麻烦。（当然标准的回答不是这样的，我这里仅仅是说明实质）</p><p>　　了解了这么一个过程之后，我们必然要了解垃圾回收机制了。</p><p>　　<strong>基本回收算法</strong></p><p>　　1. 引用计数：比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p><p>　　2. 标记-清除：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><p>　　3. 复制：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现碎片问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><p>　　4. 标记-整理：此算法结合了标记-清除和复制两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象压缩到堆的其中一块，按顺序排放。此算法避免了标记-清除的碎片问题，同时也避免了复制算法的空间问题。</p><p>　　5. 增量收集：实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。</p><p>　　6. 分代：基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?3041</link>
<title><![CDATA[ JNA—JNI终结者]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Wed, 29 Aug 2012 01:56:05 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?3041</guid> 
<description>
<![CDATA[ 
	<h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span style="font-family: 宋体">介绍</span></span></span></h1><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">给大家介绍一个最新的访问本机代码的</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">框架</span><span><span style="font-family: Calibri">&mdash;JNA</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA(Java Native Access)</span></span><span style="font-family: 宋体">框架是一个开源的</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">框架，是</span><span><span style="font-family: Calibri">SUN</span></span><span style="font-family: 宋体">公司主导开发的，建立在经典的</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">的基础之上的一个框架。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">项目地址：</span></span><span><a href="https://jna.dev.java.net/"><u><span style="font-family: Calibri; color: #800080">https://jna.dev.java.net/</span></u></a></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">非常强大、易用，功能上类似与</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">的</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span style="font-family: 宋体">不堪回首的</span><span><span style="font-family: Cambria">JNI</span></span></span></span></h1><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">我们知道，使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">调用</span><span><span style="font-family: Calibri">.dll/.so</span></span><span style="font-family: 宋体">共享类库是非常非常麻烦和痛苦的。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">如果有一个现有的</span><span><span style="font-family: Calibri">.dll/.so</span></span><span style="font-family: 宋体">文件，如果使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术调用，我们首先需要另外使用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言写一个</span><span><span style="font-family: Calibri">.dll/.so</span></span><span style="font-family: 宋体">共享库，使用</span><span><span style="font-family: Calibri">SUN</span></span><span style="font-family: 宋体">规定的数据结构替代</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言的数据结构，调用已有的</span><span><span style="font-family: Calibri"><span>&nbsp; </span>dll/so</span></span><span style="font-family: 宋体">中公布的函数。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">然后再在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">中载入这个适配器</span><span><span style="font-family: Calibri">dll/so</span></span><span style="font-family: 宋体">，再编写</span><span><span style="font-family: Calibri">Java<span>&nbsp;&nbsp; </span>native</span></span><span style="font-family: 宋体">函数作为</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">中函数的代理。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">经过</span><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">个繁琐的步骤才能在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">中调用本地代码。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">因此，很少有</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">程序员愿意编写调用</span><span><span style="font-family: Calibri">dll/.so</span></span><span style="font-family: 宋体">库中的原生函数的</span><span><span style="font-family: Calibri">java</span></span><span style="font-family: 宋体">程序。这也使</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">语言在客户端上乏善可陈。可以说</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">是</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">的一大弱点！</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span><span style="font-family: Cambria">.NET</span></span><span style="font-family: 宋体">平台上强大的</span><span><span style="font-family: Cambria">P/Invoke</span></span></span></span></h1><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">而在</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">平台上，强大的</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">技术使我们</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">程序员非常羡慕。使用</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">技术，只需要使用编写一个</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">函数，再加上一个声明的标注，就可以直接调用</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">中的函数。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">不需要你再使用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言编写</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">来适配。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span style="font-family: 宋体">不逊于</span><span><span style="font-family: Cambria">P/Invoke</span></span><span style="font-family: 宋体">的</span><span><span style="font-family: Cambria">JNA</span></span></span></span></h1><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">现在，不需要再羡慕</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">的</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">机制了。</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">把对</span><span><span style="font-family: Calibri">dll/.so</span></span><span style="font-family: 宋体">共享库的调用减少到了和</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">相同的程度。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">使用</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">，不需要再编写适配用的</span><span><span style="font-family: Calibri">.dll/.so</span></span><span style="font-family: 宋体">，只需要在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">中编写一个接口和一些代码，作为</span><span><span style="font-family: Calibri">.dll/.so</span></span><span style="font-family: 宋体">的代理，就可以在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">程序中调用</span><span><span style="font-family: Calibri">dll/so</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h2 style="margin: 10pt 0cm 0pt"><span style="font-size: 18px"><span style="color: #4f81bd"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">快速启动</span></span></span></h2><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体">现在让我们直接进入</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">的世界。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">你只需要下载一个</span><span><span style="font-family: Calibri">jar</span></span><span style="font-family: 宋体">包，就可以使用</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">的强大功能方便地调用动态链接库中的</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，下载</span><span><span style="font-family: Calibri">jna.jar</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="font-family: 宋体"><span style="color: #000000">在这里</span></span><span><a href="https://jna.dev.java.net/servlets/ProjectDocumentList?folderID=7408&amp;expandFolder=7408&amp;folderID=0"><u><span style="font-family: Calibri; color: #800080">https://jna.dev.java.net/servlets/ProjectDocumentList?folderID=7408&amp;expandFolder=7408&amp;folderID=0</span></u></a></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，现在你已经可以使用</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">了。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">为了方便你参考</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">的</span><span><span style="font-family: Calibri">java</span></span><span style="font-family: 宋体">类库，我制作了《</span><span><span style="font-family: Calibri">JNA3.09API</span></span><span style="font-family: 宋体">参考手册》，是</span><span><span style="font-family: Calibri">CHM</span></span><span style="font-family: 宋体">格式的。你可以到这里下载</span></span><span><span style="font-family: Calibri"><span style="color: #000000"> </span><span><a href="http://download.csdn.net/source/900438"><u><span style="color: #800080">http://download.csdn.net/source/900438</span></u></a></span></span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h3 style="margin: 10pt 0cm 0pt"><span style="font-size: 16px"><span style="color: #4f81bd"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">例子</span></span></span></h3><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h4 style="margin: 10pt 0cm 0pt"><span style="font-style: italic"><span style="color: #4f81bd"><span style="font-family: 宋体">例子</span><span><span style="font-family: Cambria">1<span>&nbsp;&nbsp;&nbsp; </span></span></span></span></span></h4><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">现在让我们运行一个</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">程序，感受它的强大威力。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">项目中引入</span><span><span style="font-family: Calibri">jna.jar</span></span><span style="font-family: 宋体">包。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，创建一个类：</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.Library;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.Native;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.Platform;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">/** Simple example of native library declaration and usage. */</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">public class HelloWorld &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>public interface CLibrary extends Library &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CLibrary INSTANCE = (CLibrary)</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Native.loadLibrary((Platform.isWindows() ? &quot;msvcrt&quot; : &quot;c&quot;),</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CLibrary.class);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span></span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>void printf(String format, Object... args);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>public static void main(String[] args) &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CLibrary.INSTANCE.printf(&quot;Hello, World/n&quot;);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for (int i=0;i &lt; args.length;i++) &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CLibrary.INSTANCE.printf(&quot;Argument %d: %s/n&quot;, i, args[i]);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">3</span></span><span style="font-family: 宋体">，执行，可以看到控制台中打印出了</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">Hello, World</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体">但是，请注意，这个程序实际上是使用</span><span><span style="font-family: Calibri">msvcrt.dll</span></span><span style="font-family: 宋体">这个</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">运行时库中的</span><span><span style="font-family: Calibri">printf</span></span><span style="font-family: 宋体">函数打印出上面这些字符的。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体">看，多简单，不需要写一行</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">代码，就可以直接在</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">中调用外部动态链接库中的函数！</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h4 style="margin: 10pt 0cm 0pt"><span style="font-style: italic"><span style="color: #4f81bd"><span style="font-family: 宋体">例子</span><span><span style="font-family: Cambria">2<span>&nbsp;&nbsp;&nbsp; </span></span></span></span></span></h4><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span><span style="font-family: Calibri">&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family: 宋体">上面那个例子使用了操作系统自带的动态链接库，现在我们再自己写一个动态链接库试试。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，在</span><span><span style="font-family: Calibri">VS</span></span><span style="font-family: 宋体">中选择</span><span><span style="font-family: Calibri">C++</span></span><span style="font-family: 宋体">语言，然后选择创建一个</span><span><span style="font-family: Calibri">Win32</span></span><span style="font-family: 宋体">程序。</span><span><span style="font-family: Calibri"> </span></span><span style="font-family: 宋体">选择</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">类型。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，发布的</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数是：</span></span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; font-size: 9pt"></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; color: blue; font-size: 9pt">#define</span><span style="font-family: 新宋体; font-size: 9pt"><span style="color: #000000"> MYLIBAPI<span>&nbsp; </span></span><span style="color: blue">extern</span><span><span style="color: #000000">&nbsp;&nbsp; </span></span><span style="color: #a31515">&quot;C&quot;</span><span><span style="color: #000000">&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="color: blue">__declspec</span><span style="color: #000000">( </span><span style="color: blue">dllexport</span><span style="color: #000000"> )<span>&nbsp; </span></span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; font-size: 9pt"></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-family: 新宋体; font-size: 9pt"><span style="color: #000000">MYLIBAPI </span><span style="color: blue">void</span><span style="color: #000000"> say(</span><span style="color: blue">wchar_t</span><span style="color: #000000">* pValue);</span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-family: 新宋体; font-size: 9pt"></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">这个函数的实现是：</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; color: blue; font-size: 9pt">void</span><span style="font-family: 新宋体; font-size: 9pt"><span style="color: #000000"><span>&nbsp; </span>say(</span><span style="color: blue">wchar_t</span><span style="color: #000000">* pValue)&#123;</span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; font-size: 9pt"><span style="color: #000000"><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>std::wcout.imbue(std::locale(</span><span style="color: #a31515">&quot;chs&quot;</span><span style="color: #000000">));</span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; font-size: 9pt"></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 新宋体; font-size: 9pt"><span style="color: #000000"><span>&nbsp;&nbsp;&nbsp;&nbsp; </span>std::wcout&lt;&lt;L</span><span style="color: #a31515">&quot;上帝说：&quot;</span><span style="color: #000000">&lt;&lt;pValue&lt;&lt;std::endl;</span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="color: #000000"><span style="font-family: 新宋体; font-size: 9pt">&#125;</span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">它需要传入一个</span><span><span style="font-family: Calibri">Unicode</span></span><span style="font-family: 宋体">编码的字符数组。然后在控制台上打印出一段中文字符。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">3</span></span><span style="font-family: 宋体">，生成</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">。然后把生成的</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">文件复制到</span><span><span style="font-family: Calibri">Eclipse</span></span><span style="font-family: 宋体">项目中，放在项目下面。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">4</span></span><span style="font-family: 宋体">，在</span><span><span style="font-family: Calibri">Eclipse</span></span><span style="font-family: 宋体">中编写以下代码：</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.Library;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.Native;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">import com.sun.jna.WString;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">/**</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;</span>* @author </span></span><span style="font-family: 宋体">沈东良</span><span><span style="font-family: Calibri"> Edward Shen shendl_s@hotmail.com</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;</span>* 2008-11-23 </span></span><span style="font-family: 宋体">下午</span><span><span style="font-family: Calibri">05:07:14</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;</span>*TestDll1.dll</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;</span>*/</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">public class TestDll1Service &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public interface TestDll1 extends Library &#123; </span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/**</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>* </span></span><span style="font-family: 宋体">当前路径是在项目下，而不是</span><span><span style="font-family: Calibri">bin</span></span><span style="font-family: 宋体">输出目录下。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>*/</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>TestDll1 INSTANCE = (TestDll1)Native.loadLibrary(&quot;TestDll1&quot;, TestDll1.class);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public void say(WString value);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/**</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>* </span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>*/</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public TestDll1Service() &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// TODO Auto-generated constructor stub</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/**</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>* @param args</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>*/</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public static void main(String[] args) &#123;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// TODO Auto-generated method stub</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>TestDll1.INSTANCE.say(new WString(&quot;Hello World!&quot;));</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>System.out.println(&quot;HHEEH</span></span><span style="font-family: 宋体">我我们无法万恶</span><span><span style="font-family: Calibri">&quot;);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">5</span></span><span style="font-family: 宋体">，执行这个</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">类。可以看到控制台下如下输出：</span></span></span></p><p style="line-height: normal; margin: 0cm 0cm 0pt" class="MsoNormal"><span style="font-family: 宋体; color: black; font-size: 10pt">上帝说：</span><span style="font-family: 'Courier New'; color: black; font-size: 10pt">Hello World!</span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-family: 'Courier New'; color: black; font-size: 10pt">HHEEH</span><span style="font-family: 宋体; color: black; font-size: 10pt">我我们无法万恶</span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">6</span></span><span style="font-family: 宋体">，上面一行是</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言使用</span><span><span style="font-family: Calibri">C++</span></span><span style="font-family: 宋体">的</span><span><span style="font-family: Calibri">std::wcout</span></span><span style="font-family: 宋体">输出的。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">下面一行是</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">语言输出的。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">技术解密</span></span></span></h1><h2 style="margin: 10pt 0cm 0pt"><span style="font-size: 18px"><span style="color: #4f81bd"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">工作原理</span></span></span></h2><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">是建立在</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术基础之上的一个</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">类库，它使您可以方便地使用</span><span><span style="font-family: Calibri">java</span></span><span style="font-family: 宋体">直接访问动态链接库中的函数。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">原来使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">，你必须手工用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">写一个动态链接库，在</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言中映射</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">的数据类型。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">中，它提供了一个动态的</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言编写的转发器，可以自动实现</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">和</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">的数据类型映射。你不再需要编写</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">动态链接库。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">当然，这也意味着，使用</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">技术比使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术调用动态链接库会有些微的性能损失。可能速度会降低几倍。但影响不大。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h2 style="margin: 10pt 0cm 0pt"><span style="font-size: 18px"><span style="color: #4f81bd"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">技术难点</span></span></span></h2><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，当前路径是在项目下，而不是</span><span><span style="font-family: Calibri">bin</span></span><span style="font-family: 宋体">输出目录下。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，数据结构的对应关系：</span></span></span></p><h4 style="margin: 10pt 0cm 0pt"><span style="font-style: italic"><span style="color: #4f81bd"><span><span style="font-family: Cambria">Java&mdash;C</span></span><span style="font-family: 宋体">和操作系统数据类型的对应表</span></span></span></h4><div align="center"><table border="1" cellpadding="0" width="100%" class="MsoNormalTable" style="width: 100%; border: white 1pt outset"><tbody><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><strong><span>Java Type</span></strong></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><strong><span>C Type</span></strong></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><strong><span>Native Representation</span></strong></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>boolean</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>int</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>32-bit integer (customizable)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>byte</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>char</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>8-bit integer</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>char</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>wchar_t</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>platform-dependent</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>short</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>short</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>16-bit integer</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>int</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>int</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>32-bit integer</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>long</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>long long, __int64</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>64-bit integer</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>float</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>float</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>32-bit floating point</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>double</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>double</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>64-bit floating point</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/Buffer.html" title="class or interface in java.nio"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Buffer</span></u></span></a><br /><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Pointer</span></u></span></a><span style="font-family: Calibri; color: #000000; font-size: 16px"> </span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>pointer</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>platform-dependent (32- or 64-bit pointer to memory)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&lt;T&gt;[] (array of primitive type)</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>pointer<br />array</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>32- or 64-bit pointer to memory (argument/return)<br />contiguous memory (struct member)</span></span></span></span></p></td></tr><tr><td colspan="3" style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">除了上面的类型，</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">还支持常见的数据类型的映射。</span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">String</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>char*</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">NUL-terminated array (native encoding or </span></span><span style="line-height: 115%; font-size: 12pt"><span style="font-family: 宋体">jna.encoding</span></span><span style="font-family: Calibri"><span>)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">WString</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>wchar_t*</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>NUL-terminated array (unicode)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html" title="class or interface in java.lang"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">String[]</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>char**</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>NULL-terminated array of C strings</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">WString[]</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>wchar_t**</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>NULL-terminated array of wide C strings</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Structure</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>struct*<br />struct</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><span style="font-family: Calibri; color: #000000; font-size: 16px">pointer to struct (argument or return) (</span><a href="/" title="interface in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">or explicitly</span></u></span></a><span style="font-family: Calibri; color: #000000; font-size: 16px">)<br />struct by value (member of struct) (</span><a href="/" title="interface in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">or explicitly</span></u></span></a><span style="font-family: Calibri; color: #000000; font-size: 16px">)</span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Union</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>union</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="color: #000000"><span style="font-size: 16px"><span><span style="font-family: Calibri">same as </span></span><span style="line-height: 115%; font-size: 12pt"><span style="font-family: 宋体">Structure</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Structure[]</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>struct[]</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>array of structs, contiguous in memory</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="interface in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">Callback</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&lt;T&gt; (*fp)()</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>function pointer (Java or native)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="interface in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">NativeMapped</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>varies</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>depends on definition</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">NativeLong</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>long</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>platform-dependent (32- or 64-bit integer)</span></span></span></span></p></td></tr><tr><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span><a href="/" title="class in com.sun.jna"><span style="line-height: 115%; color: blue; font-size: 12pt"><u><span style="font-family: 宋体">PointerType</span></u></span></a></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>pointer</span></span></span></span></p></td><td style="padding-bottom: 0.75pt; background-color: transparent; padding-left: 0.75pt; padding-right: 0.75pt; padding-top: 0.75pt; border: white 1pt inset"><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="color: #000000"><span style="font-size: 16px"><span><span style="font-family: Calibri">same as </span></span><span style="line-height: 115%; font-size: 12pt"><span style="font-family: 宋体">Pointer</span></span></span></span></p></td></tr></tbody></table></div><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h2 style="margin: 10pt 0cm 0pt"><span style="font-size: 18px"><span style="color: #4f81bd"><span><span style="font-family: Cambria">JNA</span></span><span style="font-family: 宋体">编程过程</span></span></span></h2><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">把一个</span><span><span style="font-family: Calibri">dll/.so</span></span><span style="font-family: 宋体">文件看做是一个</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">接口。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">Dll</span></span><span style="font-family: 宋体">是</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数的集合、容器，这正和接口的概念吻合。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp; </span><span>&nbsp;</span></span></span><span style="font-family: 宋体">我们定义这样一个接口，</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">public interface TestDll1 extends Library &#123; </span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>/**</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>* </span></span><span style="font-family: 宋体">当前路径是在项目下，而不是</span><span><span style="font-family: Calibri">bin</span></span><span style="font-family: 宋体">输出目录下。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;</span>*/</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>TestDll1 INSTANCE = (TestDll1)Native.loadLibrary(&quot;TestDll1&quot;, TestDll1.class);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>public void say(WString value);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>&#125;</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">如果</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">是以</span><span><span style="font-family: Calibri">stdcall</span></span><span style="font-family: 宋体">方式输出函数，那么就继承</span><span><span style="font-family: Calibri">StdCallLibrary</span></span><span style="font-family: 宋体">。否则就继承默认的</span><span><span style="font-family: Calibri">Library</span></span><span style="font-family: 宋体">接口。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">接口内部需要一个公共静态常量：</span><span><span style="font-family: Calibri">instance</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">TestDll1 INSTANCE = (TestDll1)Native.loadLibrary(&quot;TestDll1&quot;, TestDll1.class);</span></span></span></span></p><p style="text-indent: 22pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">通过这个常量，就可以获得这个接口的实例，从而使用接口的方法。也就是调用外部</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">的函数！</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">注意：</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，</span><span><span style="font-family: Calibri">Native.loadLibrary()</span></span><span style="font-family: 宋体">函数有</span><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">个参数：</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>1</span></span><span style="font-family: 宋体">，</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">或者</span><span><span style="font-family: Calibri">.so</span></span><span style="font-family: 宋体">文件的名字，但不带后缀名。这符合</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">的规范，因为带了后缀名就不可以跨操作系统平台了。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">搜索</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">的路径是：</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">）项目的根路径</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">）操作系统的全局路径、</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">3</span></span><span style="font-family: 宋体">）</span><span><span style="font-family: Calibri">path</span></span><span style="font-family: 宋体">指定的路径。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，第二个参数是本接口的</span><span><span style="font-family: Calibri">Class</span></span><span style="font-family: 宋体">类型。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">通过这个</span><span><span style="font-family: Calibri">Class</span></span><span style="font-family: 宋体">类型，根据指定的</span><span><span style="font-family: Calibri">dll/.so</span></span><span style="font-family: 宋体">文件，动态创建接口的实例。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，接口中你只需要定义你需要的函数或者公共变量，不需要的可以不定义。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: Calibri">public void say(WString value);</span></span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">参数和返回值的类型，应该和</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">中的</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数的类型一致。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">这是</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">，甚至所有跨平台调用的难点。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">这里，</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言的函数参数是：</span></span></span><span style="line-height: 115%; font-family: 新宋体; color: blue; font-size: 9pt">wchar_t</span><span style="color: #000000"><span style="line-height: 115%; font-family: 新宋体; font-size: 9pt">*</span><span style="line-height: 115%; font-family: 新宋体; font-size: 9pt">。</span></span></p><p style="margin: 0cm 0cm 10pt" class="MsoNormal"><span style="color: #000000"><span style="line-height: 115%; font-family: 新宋体; font-size: 12pt">JNA</span><span style="line-height: 115%; font-family: 新宋体; font-size: 12pt">中对应的<span>Java</span>类型是<span>WStirng</span>。</span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span style="font-family: 宋体">所有跨平台、跨语言调用的难点</span></span></span></h1><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">有过跨语言、跨平台开发的程序员都知道，跨平台、语言调用的难点，就是不同语言之间数据类型不一致造成的问题。绝大部分跨平台调用的失败，都是这个问题造成的。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">关于这一点，不论何种语言，何种技术方案，都无法解决这个问题。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">这需要程序员的仔细开发和设计。这是程序员的责任。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h3 style="margin: 10pt 0cm 0pt"><span style="font-size: 16px"><span style="color: #4f81bd"><span style="font-family: 宋体">常见的跨平台调用有：</span></span></span></h3><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">1</span></span><span style="font-family: 宋体">，</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">调用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言编写的</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">、</span><span><span style="font-family: Calibri">.so</span></span><span style="font-family: 宋体">动态链接库中的函数。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">2</span></span><span style="font-family: 宋体">，</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">通过</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">调用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言编写的</span><span><span style="font-family: Calibri">dll</span></span><span style="font-family: 宋体">、</span><span><span style="font-family: Calibri">.so</span></span><span style="font-family: 宋体">动态链接库中的函数。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">3</span></span><span style="font-family: 宋体">，通过</span><span><span style="font-family: Calibri">WEBService</span></span><span style="font-family: 宋体">，在</span><span><span style="font-family: Calibri">C,C++,Java,.NET</span></span><span style="font-family: 宋体">等种种语言间调用。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri"><span>&nbsp;&nbsp;&nbsp; </span>WebService</span></span><span style="font-family: 宋体">传递的是</span><span><span style="font-family: Calibri">xml</span></span><span style="font-family: 宋体">格式的数据。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">即使是强大的</span><span><span style="font-family: Calibri">P/Invoke</span></span><span style="font-family: 宋体">或者</span><span><span style="font-family: Calibri">WebService</span></span><span style="font-family: 宋体">，在遇到复杂的数据类型和大数据量的传递时，还是会碰到很大的困难。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h3 style="margin: 10pt 0cm 0pt"><span style="font-size: 16px"><span style="color: #4f81bd"><span style="font-family: 宋体">因为，一种语言的复杂的数据类型，很难用另一种语言来表示。这就是跨平台调用问题的本质。</span></span></span></h3><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">如，</span><span><span style="font-family: Calibri">WEBService</span></span><span style="font-family: 宋体">调用中，很多语言，如</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">，</span><span><span style="font-family: Calibri">.NET</span></span><span style="font-family: 宋体">都有自动实现的</span><span><span style="font-family: Calibri">Java/.NET</span></span><span style="font-family: 宋体">类型和</span><span><span style="font-family: Calibri">XML</span></span><span style="font-family: 宋体">类型之间的映射的类库或者工具。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">但是，在现实的编程环境中，如果类型非常复杂，那么这些自动转换工具常常力不从心。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">要么</span><span><span style="font-family: Calibri">Object-XML</span></span><span style="font-family: 宋体">映射错误。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">要么映射掉大量的内存。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">因此，我个人对这些</span><span><span style="font-family: Calibri">Object-XML</span></span><span style="font-family: 宋体">映射框架相当不感冒。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">我现在使用</span><span><span style="font-family: Calibri">WEBService</span></span><span style="font-family: 宋体">，都是直接手工使用</span><span><span style="font-family: Calibri">xml</span></span><span style="font-family: 宋体">处理工具提取</span><span><span style="font-family: Calibri">xml</span></span><span style="font-family: 宋体">中的数据构建对象。或者反过来，手工根据</span><span><span style="font-family: Calibri">Object</span></span><span style="font-family: 宋体">中的属性值构建</span><span><span style="font-family: Calibri">xml</span></span><span style="font-family: 宋体">数据。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">和</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言之间的调用问题，也是如此。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">要调用</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言的函数，那么就必须严格按照</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言要求的内存数量提供</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">格式的数据。要用</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">的数据类型完美模拟</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言的数据类型。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">已经提供了大量的类型匹配</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言的数据类型。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h3 style="margin: 10pt 0cm 0pt"><span style="font-size: 16px"><span style="color: #4f81bd"><span style="font-family: 宋体">跨平台、跨语言调用的第一原则：就是尽量使用基本、简单的数据类型，尽量少跨语言、平台传递数据！</span></span></span></h3><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">只有你才能拯救你自己。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">如果在你的程序中，有复杂的数据类型和庞大的跨平台数据传递。那么你必须另外写一些</span><span><span style="font-family: Calibri">Fa&ccedil;ade</span></span><span style="font-family: 宋体">接口，把需要传递的数据类型简化，把需要传递的数据量简化。</span></span></span></p><p style="text-indent: 21pt; margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">否则，不论是实现的难度还是程序的性能都很难提高。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span></span></p><h1 style="margin: 24pt 0cm 0pt"><span style="font-size: 24px"><span style="color: #365f91"><span><span style="font-family: Cambria">JNI</span></span><span style="font-family: 宋体">还是不能废</span></span></span></h1><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">我们已经见识了</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">的强大。</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">和它相比是多么的简陋啊！</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">但是，有些需求还是必须求助于</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">是建立在</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术基础之上的一个框架。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术，不仅可以实现</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">访问</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数，也可以实现</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言调用</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">代码。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span style="font-family: 宋体">而</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">只能实现</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">访问</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">函数，作为一个</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">框架，自然不能实现</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">语言调用</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">代码。此时，你还是需要使用</span><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">技术。</span></span></span></p><p style="margin: 0cm 0cm 0pt" class="MsoNoSpacing"><span style="font-size: 16px"><span style="color: #000000"><span><span style="font-family: Calibri">JNI</span></span><span style="font-family: 宋体">是</span><span><span style="font-family: Calibri">JNA</span></span><span style="font-family: 宋体">的基础。是</span><span><span style="font-family: Calibri">Java</span></span><span style="font-family: 宋体">和</span><span><span style="font-family: Calibri">C</span></span><span style="font-family: 宋体">互操作的技术基础。</span></span></span></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2995</link>
<title><![CDATA[JAVA 对象引用，以及对象赋值]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Sun, 19 Aug 2012 06:46:42 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2995</guid> 
<description>
<![CDATA[ 
	<p>关键字<span style="font-family: 'Times New Roman'">:&nbsp;&nbsp;java</span>对象 引用</p> <p><span style="font-family: 'Times New Roman'">Java</span>对象及其引用</p> <p>关于对象与引用之间的一些基本概念。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 初学<span style="font-family: 'Times New Roman'">Java</span>时，在很长一段时间里，总觉得基本概念很模糊。后来才知道，在许多<span style="font-family: 'Times New Roman'">Java</span>书中，把对象和对象的引用混为一谈。可是，如果我分不清对象与对象引用，</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;那实在没法很好地理解下面的面向对象技术。把自己的一点认识写下来，或许能让初学<span style="font-family: 'Times New Roman'">Java</span>的朋友们少走一点弯路。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 为便于说明，我们先定义一个简单的类：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class&nbsp;&nbsp;Vehicle &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;passengers;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;fuelcap;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;mpg;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;</span></p> <p>有了这个模板，就可以用它来创建对象：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vehicle&nbsp;&nbsp;veh1 = new Vehicle();</span></p> <p>通常把这条语句的动作称之为创建一个对象，其实，它包含了四个动作。</p> <p><span style="font-family: 'Times New Roman'">1</span>）右边的&ldquo;<span style="font-family: 'Times New Roman'">new Vehicle</span>&rdquo;，是以<span style="font-family: 'Times New Roman'">Vehicle</span>类为模板，在堆空间里创建一个<span style="font-family: 'Times New Roman'">Vehicle</span>类对象（也简称为<span style="font-family: 'Times New Roman'">Vehicle</span>对象）。</p> <p><span style="font-family: 'Times New Roman'">2</span>）末尾的<span style="font-family: 'Times New Roman'">()</span>意味着，在对象创建后，立即调用<span style="font-family: 'Times New Roman'">Vehicle</span>类的构造函数，对刚生成的对象进行初始化。构造函数是肯定有的。如果你没写，<span style="font-family: 'Times New Roman'">Java</span>会给你补上一个默认的构造函数。</p> <p><span style="font-family: 'Times New Roman'">3</span>）左边的&ldquo;<span style="font-family: 'Times New Roman'">Vehicle veh</span> <span style="font-family: 'Times New Roman'">1</span>&rdquo;创建了一个<span style="font-family: 'Times New Roman'">Vehicle</span>类引用变量。所谓<span style="font-family: 'Times New Roman'">Vehicle</span>类引用，就是以后可以用来指向<span style="font-family: 'Times New Roman'">Vehicle</span>对象的对象引用。</p> <p><span style="font-family: 'Times New Roman'">4</span>）&ldquo;<span style="font-family: 'Times New Roman'">=</span>&rdquo;操作符使对象引用指向刚创建的那个<span style="font-family: 'Times New Roman'">Vehicle</span>对象。</p> <p>我们可以把这条语句拆成两部分：</p> <p><span style="font-family: 'Times New Roman'">Vehicle&nbsp;&nbsp;veh1;</span></p> <p><span style="font-family: 'Times New Roman'">veh1 = new&nbsp;&nbsp;Vehicle();</span></p> <p>效果是一样的。这样写，就比较清楚了，有两个实体：一是对象引用变量，一是对象本身。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;在堆空间里创建的实体，与在数据段以及栈空间里创建的实体不同。尽管它们也是确确实实存在的实体，但是，我们看不见，也摸不着。不仅如此，</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;我们仔细研究一下第二句，找找刚创建的对象叫什么名字？有人说，它叫&ldquo;<span style="font-family: 'Times New Roman'">Vehicle</span>&rdquo;。不对，&ldquo;<span style="font-family: 'Times New Roman'">Vehicle</span>&rdquo;是类（对象的创建模板）的名字。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 一个<span style="font-family: 'Times New Roman'">Vehicle</span>类可以据此创建出无数个对象，这些对象不可能全叫&ldquo;<span style="font-family: 'Times New Roman'">Vehicle</span>&rdquo;。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;对象连名都没有，没法直接访问它。我们只能通过对象引用来间接访问对象。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;为了形象地说明对象、引用及它们之间的关系，可以做一个或许不很妥当的比喻。对象好比是一只很大的气球，大到我们抓不住它。引用变量是一根绳，&nbsp;&nbsp;可以用来系汽球。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;如果只执行了第一条语句，还没执行第二条，此时创建的引用变量<span style="font-family: 'Times New Roman'">veh1</span>还没指向任何一个对象，它的值是<span style="font-family: 'Times New Roman'">null</span>。引用变量可以指向某个对象，或者为<span style="font-family: 'Times New Roman'">null</span>。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;它是一根绳，一根还没有系上任何一个汽球的绳。执行了第二句后，一只新汽球做出来了，并被系在<span style="font-family: 'Times New Roman'">veh1</span>这根绳上。我们抓住这根绳，就等于抓住了那只汽球。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 再来一句：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vehicle&nbsp;&nbsp;veh2;</span></p> <p>就又做了一根绳，还没系上汽球。如果再加一句：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; veh2 =&nbsp;&nbsp;veh1;</span></p> <p>系上了。这里，发生了复制行为。但是，要说明的是，对象本身并没有被复制，被复制的只是对象引用。结果是，<span style="font-family: 'Times New Roman'">veh2</span>也指向了<span style="font-family: 'Times New Roman'">veh1</span>所指向的对象。两根绳系的是同一只汽球。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 如果用下句再创建一个对象：</p> <p><span style="font-family: 'Times New Roman'">veh2 = new&nbsp;&nbsp;Vehicle();</span></p> <p>则引用变量<span style="font-family: 'Times New Roman'">veh2</span>改指向第二个对象。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;从以上叙述再推演下去，我们可以获得以下结论：</p> <p>（<span style="font-family: 'Times New Roman'">1</span>）一个对象引用可以指向<span style="font-family: 'Times New Roman'">0</span>个或<span style="font-family: 'Times New Roman'">1</span>个对象（一根绳子可以不系汽球，也可以系一个汽球）；</p> <p>（<span style="font-family: 'Times New Roman'">2</span>）一个对象可以有<span style="font-family: 'Times New Roman'">N</span>个引用指向它（可以有<span style="font-family: 'Times New Roman'">N</span>条绳子系住一个汽球）。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 如果再来下面语句：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; veh1 =&nbsp;&nbsp;veh2;</span></p> <p>按上面的推断，<span style="font-family: 'Times New Roman'">veh1</span>也指向了第二个对象。这个没问题。问题是第一个对象呢？没有一条绳子系住它，它飞了。多数书里说，它被<span style="font-family: 'Times New Roman'">Java</span>的垃圾回收机制回收了。</p> <p>这不确切。正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;由此看来，下面的语句应该不合法吧？至少是没用的吧？</p> <p><span style="font-family: 'Times New Roman'">new&nbsp;&nbsp;Vehicle();</span></p> <p>不对。它是合法的，而且可用的。譬如，如果我们仅仅为了打印而生成一个对象，就不需要用引用变量来系住它。最常见的就是打印字符串：</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&ldquo;I&nbsp;&nbsp;am Java!&rdquo;);</span></p> <p>字符串对象&ldquo;<span style="font-family: 'Times New Roman'">I am&nbsp;&nbsp;Java!</span>&rdquo;在打印后即被丢弃。有人把这种对象称之为临时对象。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 对象与引用的关系将持续到对象回收。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">Java</span>对象及引用</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">Java</span>对象及引用是容易混淆却又必须掌握的基础知识，本章阐述<span style="font-family: 'Times New Roman'">Java</span>对象和引用的概念，以及与其密切相关的参数传递。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>先看下面的程序：</p> <p><span style="font-family: 'Times New Roman'">StringBuffer&nbsp;&nbsp;s;</span></p> <p><span style="font-family: 'Times New Roman'">s = new&nbsp;&nbsp;StringBuffer(&quot;Hello World!&quot;);</span></p> <p>第一个语句仅为引用<span style="font-family: 'Times New Roman'">(reference)</span>分配了空间，而第二个语句则通过调用类<span style="font-family: 'Times New Roman'">(StringBuffer)</span>的构造函数<span style="font-family: 'Times New Roman'">StringBuffer(String&nbsp;&nbsp;str)</span>为类生成了一个实例（或称为对象）。这两个操作被完成后，对象的内容则可通过<span style="font-family: 'Times New Roman'">s</span>进行访问&mdash;&mdash;在<span style="font-family: 'Times New Roman'">Java</span>里都是通过引用来操纵对象的。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">Java</span>对象和引用的关系可以说是互相关联，却又彼此独立。彼此独立主要表现在：引用是可以改变的，它可以指向别的对象，譬如上面的<span style="font-family: 'Times New Roman'">s</span>，你可以给它另外的对象，如：</p> <p><span style="font-family: 'Times New Roman'">s = new&nbsp;&nbsp;StringBuffer(&quot;Java&quot;);</span></p> <p>这样一来，<span style="font-family: 'Times New Roman'">s</span>就和它指向的第一个对象脱离关系。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>从存储空间上来说，对象和引用也是独立的，它们存储在不同的地方，对象一般存储在堆中，而引用存储在速度更快的堆栈中。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>引用可以指向不同的对象，对象也可以被多个引用操纵，如：</p> <p><span style="font-family: 'Times New Roman'">StringBuffer s1 =&nbsp;&nbsp;s;</span></p> <p>这条语句使得<span style="font-family: 'Times New Roman'">s1</span>和<span style="font-family: 'Times New Roman'">s</span>指向同一个对象。既然两个引用指向同一个对象，那么不管使用哪个引用操纵对象，对象的内容都发生改变，并且只有一份，通过<span style="font-family: 'Times New Roman'">s1</span>和<span style="font-family: 'Times New Roman'">s</span>得到的内容自然也一样，<span style="font-family: 'Times New Roman'">(String</span>除外，因为<span style="font-family: 'Times New Roman'">String</span>始终不变，<span style="font-family: 'Times New Roman'">String s1=&rdquo;AAAA&rdquo;; String&nbsp;&nbsp;s=s1,</span>操作<span style="font-family: 'Times New Roman'">s,s1</span>由于始终不变，所以为<span style="font-family: 'Times New Roman'">s</span>另外开辟了空间来存储<span style="font-family: 'Times New Roman'">s,)</span>如下面的程序：</p> <p><span style="font-family: 'Times New Roman'">StringBuffer&nbsp;&nbsp;s;</span></p> <p><span style="font-family: 'Times New Roman'">s = new&nbsp;&nbsp;StringBuffer(&quot;Java&quot;);</span></p> <p><span style="font-family: 'Times New Roman'">StringBuffer s1 =&nbsp;&nbsp;s;</span></p> <p><span style="font-family: 'Times New Roman'">s1.append(&quot;&nbsp;&nbsp;World&quot;);</span></p> <p><span style="font-family: 'Times New Roman'">System.out.println(&quot;s1=&quot; +&nbsp;&nbsp;s1.toString());//</span>打印结果为：<span style="font-family: 'Times New Roman'">s1=Java&nbsp;&nbsp;World</span></p> <p><span style="font-family: 'Times New Roman'">System.out.println(&quot;s=&quot; +&nbsp;&nbsp;s.toString());//</span>打印结果为：<span style="font-family: 'Times New Roman'">s=Java&nbsp;&nbsp;World</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>上面的程序表明，<span style="font-family: 'Times New Roman'">s1</span>和<span style="font-family: 'Times New Roman'">s</span>打印出来的内容是一样的，这样的结果看起来让人非常疑惑，但是仔细想想，<span style="font-family: 'Times New Roman'">s1</span>和<span style="font-family: 'Times New Roman'">s</span>只是两个引用，它们只是操纵杆而已，它们指向同一个对象，操纵的也是同一个对象，通过它们得到的是同一个对象的内容。这就像汽车的刹车和油门，它们操纵的都是车速，假如汽车开始的速度是<span style="font-family: 'Times New Roman'">80</span>，然后你踩了一次油门，汽车加速了，假如车速升到了<span style="font-family: 'Times New Roman'">120</span>，然后你踩一下刹车，此时车速是从<span style="font-family: 'Times New Roman'">120</span>开始下降的，假如下降到<span style="font-family: 'Times New Roman'">60</span>，再踩一次油门，车速则从<span style="font-family: 'Times New Roman'">60</span>开始上升，而不是从第一次踩油门后的<span style="font-family: 'Times New Roman'">120</span>开始。也就是说车速同时受油门和刹车影响，它们的影响是累积起来的，而不是各自独立（除非刹车和油门不在一辆车上）。所以，在上面的程序中，不管使用<span style="font-family: 'Times New Roman'">s1</span>还是<span style="font-family: 'Times New Roman'">s</span>操纵对象，它们对对象的影响也是累积起来的（更多的引用同理）。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>只有理解了对象和引用的关系，才能理解参数传递。</p> <p>一般面试题中都会考<span style="font-family: 'Times New Roman'">Java</span>传参的问题，并且它的标准答案是<span style="font-family: 'Times New Roman'">Java</span>只有一种参数传递方式：那就是按值传递，即<span style="font-family: 'Times New Roman'">Java</span>中传递任何东西都是传值。如果传入方法的是基本类型的东西，你就得到此基本类型的一份拷贝。如果是传递引用，就得到引用的拷贝。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>一般来说，对于基本类型的传递，我们很容易理解，而对于对象，总让人感觉是按引用传递，看下面的程序：</p> <p><span style="font-family: 'Times New Roman'">public class&nbsp;&nbsp;ObjectRef &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span>基本类型的参数传递</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; public static&nbsp;&nbsp;void testBasicType(int m) &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;m=&quot; + m);//m=50</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m =&nbsp;&nbsp;100;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;m=&quot; + m);//m=100</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; &#125;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span>参数为对象，不改变引用的值 ？？？？？？</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; public static&nbsp;&nbsp;void add(StringBuffer s) &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.append(&quot;_add&quot;);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; &#125;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//</span>参数为对象，改变引用的值 ？？？？？</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; public static&nbsp;&nbsp;void changeRef(StringBuffer s) &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s = new&nbsp;&nbsp;StringBuffer(&quot;Java&quot;);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; &#125;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; public static&nbsp;&nbsp;void main(String[] args) &#123;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i =&nbsp;&nbsp;50;</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testBasicType(i);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i);//i=50</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer sMain = new StringBuffer(&quot;init&quot;);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add(sMain);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changeRef(sMain);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;sMain=&quot; + sMain.toString());//sMain=init_add</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; &#125;</span></p> <p><span style="font-family: 'Times New Roman'">&#125;</span></p> <p>以上程序的允许结果显示出，<span style="font-family: 'Times New Roman'">testBasicType</span>方法的参数是基本类型，尽管参数<span style="font-family: 'Times New Roman'">m</span>的值发生改变，但并不影响<span style="font-family: 'Times New Roman'">i</span>。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add</span>方法的参数是一个对象，当把<span style="font-family: 'Times New Roman'">sMain</span>传给参数<span style="font-family: 'Times New Roman'">s</span>时，<span style="font-family: 'Times New Roman'">s</span>得到的是<span style="font-family: 'Times New Roman'">sMain</span>的拷贝，所以<span style="font-family: 'Times New Roman'">s</span>和<span style="font-family: 'Times New Roman'">sMain</span>指向同一个对象，因此，使用<span style="font-family: 'Times New Roman'">s</span>操作影响的其实就是<span style="font-family: 'Times New Roman'">sMain</span>指向的对象，故调用<span style="font-family: 'Times New Roman'">add</span>方法后，<span style="font-family: 'Times New Roman'">sMain</span>指向的对象的内容发生了改变。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> 在<span style="font-family: 'Times New Roman'">changeRef</span>方法中，参数也是对象，当把<span style="font-family: 'Times New Roman'">sMain</span>传给参数<span style="font-family: 'Times New Roman'">s</span>时，<span style="font-family: 'Times New Roman'">s</span>得到的是<span style="font-family: 'Times New Roman'">sMain</span>的拷贝，但与<span style="font-family: 'Times New Roman'">add</span>方法不同的是，<strong>在方法体内改变了</strong><strong><span style="font-family: 'Times New Roman'">s</span></strong><strong>指向的对象（也就是</strong><strong><span style="font-family: 'Times New Roman'">s</span></strong><strong>指向了别的对象</strong><strong><span style="font-family: 'Times New Roman'">,</span></strong><strong>牵着气球的绳子换气球了</strong><strong>），给</strong><strong><span style="font-family: 'Times New Roman'">s</span></strong><strong>重新赋值后，</strong><strong><span style="font-family: 'Times New Roman'">s</span></strong><strong>与</strong><strong><span style="font-family: 'Times New Roman'">sMain</span></strong><strong>已经毫无关联</strong>，它和<span style="font-family: 'Times New Roman'">sMain</span>指向了不同的对象，所以不管对<span style="font-family: 'Times New Roman'">s</span>做什么操作，都不会影响<span style="font-family: 'Times New Roman'">sMain</span>指向的对象，故调用<span style="font-family: 'Times New Roman'">changeRef</span>方法前后<span style="font-family: 'Times New Roman'">sMain</span>指向的对象内容并未发生改变。</p> <p><span style="font-family: 'Times New Roman'">&nbsp;</span></p> <p>对于<span style="font-family: 'Times New Roman'">add</span>方法的调用结果，可能很多人会有这种感觉：这不明明是按引用传递吗？对于这种问题，还是套用<span style="font-family: 'Times New Roman'">Bruce&nbsp;&nbsp;Eckel</span>的话：这依赖于你如何看待引用，最终你会明白，这个争论并没那么重要。真正重要的是，你要理解，传引用使得（调用者的）对象的修改变得不可预期。</p> <p>&nbsp;</p> <p><span style="font-family: 'Times New Roman'">&nbsp;public&nbsp;&nbsp; class&nbsp;&nbsp; Test<br />&#123;&nbsp;&nbsp; public int&nbsp;&nbsp;&nbsp;&nbsp;i,j;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp; public&nbsp;&nbsp; void&nbsp;&nbsp; test_m(Test&nbsp;&nbsp; a)<br />&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; Test&nbsp;&nbsp; b&nbsp;&nbsp; =&nbsp; new&nbsp;&nbsp;&nbsp;&nbsp;Test();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.i&nbsp;&nbsp; =&nbsp;&nbsp; 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.j&nbsp;&nbsp; =&nbsp;&nbsp; 2;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;b;<br />&nbsp;&nbsp;&nbsp; &#125;<br />&nbsp;&nbsp;&nbsp; public&nbsp;&nbsp; void&nbsp;&nbsp; test_m1(Test&nbsp;&nbsp; a&nbsp;&nbsp; )<br />&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; a.i&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;1;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.j&nbsp;&nbsp; =&nbsp;&nbsp; 2;<br />&nbsp;&nbsp;&nbsp; &#125;<br />&nbsp;&nbsp;&nbsp; public&nbsp;&nbsp; static&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;main(String&nbsp;&nbsp; argv[])<br />&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; Test&nbsp;&nbsp; t=&nbsp;&nbsp; new&nbsp;&nbsp; Test();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.i&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp; 5;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.j&nbsp;&nbsp; =&nbsp;&nbsp; 6;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println( &quot;t.i&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&quot;+&nbsp;&nbsp; t.i&nbsp;&nbsp; +&nbsp;&nbsp; &quot;&nbsp;&nbsp; t.j=&nbsp;&nbsp; &quot;&nbsp;&nbsp; +&nbsp;&nbsp; t.j); //5,6<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.test_m(t);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println( &quot;t.i&nbsp;&nbsp; =&nbsp;&nbsp; &quot;+&nbsp;&nbsp; t.i&nbsp;&nbsp; +&nbsp;&nbsp; &quot;&nbsp;&nbsp;&nbsp;&nbsp;t.j=&nbsp;&nbsp; &quot;&nbsp;&nbsp; +&nbsp;&nbsp; t.j); //5,6,</span><span style="font-family: 'Times New Roman'">a</span>和<span style="font-family: 'Times New Roman'">t</span>都指向了一个对象，而在<span style="font-family: 'Times New Roman'">test_m</span>中<span style="font-family: 'Times New Roman'">s</span>又指向了另一个对象，所以对象<span style="font-family: 'Times New Roman'">t</span>不变！！！</p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.test_m1(t);</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println( &quot;t.i&nbsp;&nbsp; =&nbsp;&nbsp; &quot;+&nbsp;&nbsp; t.i&nbsp;&nbsp; +&nbsp;&nbsp; &quot;&nbsp;&nbsp; t.j=&nbsp;&nbsp; &quot;&nbsp;&nbsp; +&nbsp;&nbsp; t.j);&nbsp;&nbsp;//1,2</span></p> <p><span style="font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp; &#125;</span></p> <p><span style="font-family: 'Times New Roman'">&#125;</span></p> <p>答案只有一个：<span style="font-family: 'Times New Roman'">Java</span>里都是按值传递参数。而实际上，我们要明白，当参数是对象时，传引用会发生什么状况（就像上面的<span style="font-family: 'Times New Roman'">add</span>方法）？</p> <p>&nbsp;</p> <p>=========================================================================</p> <p>楼主，这样来记这个问题<br />如下表达式：<br />A a1 = new&nbsp;&nbsp;A();<br />它代表A是类，a1是引用，a1不是对象，new A()才是对象，a1引用指向new A()这个对象。</p> <p>在JAVA里，&ldquo;=&rdquo;不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，&ldquo;=&rdquo;语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。</p> <p>&nbsp;</p> <p>再如：<br />A&nbsp;&nbsp;a2;<br />它代表A是类，a2是引用，a2不是对象，a2所指向的对象为空null;</p> <p>&nbsp;</p> <p>再如：<br />a2 =&nbsp;&nbsp;a1;<br />它代表，a2是引用，a1也是引用，a1所指向的对象的地址传给了a2(传址），使得a2和a1指向了同一对象。</p> <p>综上所述，可以简单的记为，在初始化时，&ldquo;=&rdquo;语句左边的是引用，右边new出来的是对象。<br />在后面的左右都是引用的&ldquo;=&rdquo;语句时，左右的引用同时指向了右边引用所指向的对象。</p> <p>再所谓实例，其实就是对象的同义词。</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>如果需要赋值，就需要类实现Cloneable接口，实现clone()方法。</p> <div class="wp_syntax"> <table border="0"> <tbody> <tr> <td class="line_numbers"><pre>1 2 3 4 5 6 7 8 9 10 11 </pre></td> <td class="code"><pre class="java"><span style="font-weight: bold">class</span> D <span style="font-weight: bold">implements</span> <span style="color: #003399">Cloneable</span><span style="color: #009900">&#123;</span><span style="font-style: italic; color: #666666">//实现Cloneable接口</span> &nbsp;&nbsp;<span style="color: #003399">String</span> sex<span style="color: #339933">;</span> &nbsp;&nbsp;D<span style="color: #009900">(</span><span style="color: #003399">String</span> sex<span style="color: #009900">)</span><span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">this</span>.<span style="color: #006633">sex</span><span style="color: #339933">=</span>sex<span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> &nbsp;&nbsp;@Override &nbsp;&nbsp;<span style="font-weight: bold">protected</span> <span style="color: #003399">Object</span> clone<span style="color: #009900">(</span><span style="color: #009900">)</span> <span style="font-weight: bold">throws</span> <span style="color: #003399">CloneNotSupportedException</span> <span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-style: italic; color: #666666">// 实现clone方法</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">return</span> <span style="font-weight: bold">super</span>.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> <span style="color: #009900">&#125;</span></pre></td></tr></tbody></table></div> <p>赋值的时候：</p> <div class="wp_syntax"> <table border="0"> <tbody> <tr> <td class="line_numbers"><pre>1 2 </pre></td> <td class="code"><pre class="java">D d<span style="color: #339933">=</span><span style="font-weight: bold">new</span> D<span style="color: #009900">(</span><span style="color: #0000ff">&quot;男&quot;</span><span style="color: #009900">)</span><span style="color: #339933">;</span> D d2<span style="color: #339933">=</span><span style="color: #009900">(</span>D<span style="color: #009900">)</span> d.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span><span style="font-style: italic; color: #666666">//把d赋值给d2</span></pre></td></tr></tbody></table></div> <p>如果类中的变量不是主类型，而是对象，也需要调用该对象的clone()方法<br />下面是一个完整的例子：</p> <div class="wp_syntax"> <table border="0"> <tbody> <tr> <td class="line_numbers"><pre>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 </pre></td> <td class="code"><pre class="java"><span style="font-weight: bold">public</span> <span style="font-weight: bold">class</span> Test2 <span style="color: #009900">&#123;</span> &nbsp;&nbsp;<span style="font-weight: bold">public</span> <span style="font-weight: bold">static</span> <span style="font-weight: bold; color: #000066">void</span> main<span style="color: #009900">(</span><span style="color: #003399">String</span><span style="color: #009900">[</span><span style="color: #009900">]</span> args<span style="color: #009900">)</span> <span style="font-weight: bold">throws</span> <span style="color: #003399">CloneNotSupportedException</span> <span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-style: italic; color: #666666">// TODO Auto-generated method stub</span> &nbsp;&nbsp;&nbsp;&nbsp;D d<span style="color: #339933">=</span><span style="font-weight: bold">new</span> D<span style="color: #009900">(</span><span style="color: #0000ff">&quot;男&quot;</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;C c<span style="color: #339933">=</span><span style="font-weight: bold">new</span> C<span style="color: #009900">(</span><span style="color: #0000ff">&quot;张三&quot;</span>,<span style="color: #0000ff">&quot;20&quot;</span>,d<span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;C new_c<span style="color: #339933">=</span><span style="color: #009900">(</span>C<span style="color: #009900">)</span> c.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span><span style="font-style: italic; color: #666666">//调用clone方法来赋值</span> &nbsp;&nbsp;&nbsp;&nbsp;new_c.<span style="color: #006633">name</span><span style="color: #339933">=</span><span style="color: #0000ff">&quot;李四&quot;</span><span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;d.<span style="color: #006633">sex</span><span style="color: #339933">=</span><span style="color: #0000ff">&quot;女&quot;</span><span style="color: #339933">;</span><span style="font-style: italic; color: #666666">//d</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #003399">System</span>.<span style="color: #006633">out</span>.<span style="color: #006633">println</span><span style="color: #009900">(</span>c.<span style="color: #006633">d</span>.<span style="color: #006633">sex</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #003399">System</span>.<span style="color: #006633">out</span>.<span style="color: #006633">println</span><span style="color: #009900">(</span>c.<span style="color: #006633">name</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp; &nbsp;&nbsp;<span style="color: #009900">&#125;</span> &nbsp; <span style="color: #009900">&#125;</span> &nbsp; <span style="font-weight: bold">class</span> C <span style="font-weight: bold">implements</span> <span style="color: #003399">Cloneable</span><span style="color: #009900">&#123;</span> &nbsp;&nbsp;<span style="color: #003399">String</span> name<span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #003399">String</span> age<span style="color: #339933">;</span> &nbsp;&nbsp;D d<span style="color: #339933">;</span> &nbsp;&nbsp;C<span style="color: #009900">(</span><span style="color: #003399">String</span> name,<span style="color: #003399">String</span> age,D d<span style="color: #009900">)</span> <span style="font-weight: bold">throws</span> <span style="color: #003399">CloneNotSupportedException</span><span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">this</span>.<span style="color: #006633">name</span><span style="color: #339933">=</span>name<span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">this</span>.<span style="color: #006633">age</span><span style="color: #339933">=</span>age<span style="color: #339933">;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">this</span>.<span style="color: #006633">d</span><span style="color: #339933">=</span><span style="color: #009900">(</span>D<span style="color: #009900">)</span> d.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span><span style="font-style: italic; color: #666666">//调用clone方法来赋值，这样即便外部的d发生变化，c里的也不会变</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> &nbsp;&nbsp;@Override &nbsp;&nbsp;<span style="font-weight: bold">protected</span> <span style="color: #003399">Object</span> clone<span style="color: #009900">(</span><span style="color: #009900">)</span> <span style="font-weight: bold">throws</span> <span style="color: #003399">CloneNotSupportedException</span> <span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-style: italic; color: #666666">// TODO Auto-generated method stub</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">return</span> <span style="font-weight: bold">super</span>.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> <span style="color: #009900">&#125;</span> <span style="font-weight: bold">class</span> D <span style="font-weight: bold">implements</span> <span style="color: #003399">Cloneable</span><span style="color: #009900">&#123;</span><span style="font-style: italic; color: #666666">//实现Cloneable接口</span> &nbsp;&nbsp;<span style="color: #003399">String</span> sex<span style="color: #339933">;</span> &nbsp;&nbsp;D<span style="color: #009900">(</span><span style="color: #003399">String</span> sex<span style="color: #009900">)</span><span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">this</span>.<span style="color: #006633">sex</span><span style="color: #339933">=</span>sex<span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> &nbsp;&nbsp;@Override &nbsp;&nbsp;<span style="font-weight: bold">protected</span> <span style="color: #003399">Object</span> clone<span style="color: #009900">(</span><span style="color: #009900">)</span> <span style="font-weight: bold">throws</span> <span style="color: #003399">CloneNotSupportedException</span> <span style="color: #009900">&#123;</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-style: italic; color: #666666">// 实现clone方法</span> &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold">return</span> <span style="font-weight: bold">super</span>.<span style="color: #006633">clone</span><span style="color: #009900">(</span><span style="color: #009900">)</span><span style="color: #339933">;</span> &nbsp;&nbsp;<span style="color: #009900">&#125;</span> <span style="color: #009900">&#125;</span></pre></td></tr></tbody></table> <p>原文：<a href="http://blog.sina.com.cn/s/blog_4cd5d2bb0100ve9r.html">http://blog.sina.com.cn/s/blog_4cd5d2bb0100ve9r.html</a></p> <p>clone:<a href="http://bxkqzjt521.blog.163.com/blog/static/202818420119102362458/">http://bxkqzjt521.blog.163.com/blog/static/202818420119102362458/</a></p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2994</link>
<title><![CDATA[java,传递和返回对象]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Sun, 19 Aug 2012 06:46:13 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2994</guid> 
<description>
<![CDATA[ 
	到目前为止，读者应对对象的&ldquo;传递&rdquo;有了一个较为深刻的认识，记住实际传递的只是一个句柄。<br />在许多<a href="http://edu.gamfe.com/gamedev.html" title="程序设计" class="ReKeyword">程序设计</a>语言中，我们可用语言的&ldquo;普通&rdquo;方式到处传递对象，而且大多数时候都不会遇到问题。但有些时候却不得不采取一些非常做法，使得情况突然变得稍微复杂起来（在C++中则是变得非常复杂）。Java亦不例外，我们十分有必要准确认识在对象传递和赋值时所发生的一切。这正是本章的宗旨。<br />若读者是从某些特殊的<a href="http://edu.gamfe.com/gamedev.html" title="程序设计" class="ReKeyword">程序设计</a>环境中转移过来的，那么一般都会问到：&ldquo;Java有指针吗？&rdquo;有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的&ldquo;危险品&rdquo;。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有&ldquo;戒心&rdquo;，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做&ldquo;句柄&rdquo;，但你可以把它想像成&ldquo;安全指针&rdquo;。和预备学校为学生提供的安全剪刀类似&mdash;&mdash;除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。<br /><br />12.1&nbsp;&nbsp;传递句柄<br />将句柄传递进入一个方法时，指向的仍然是相同的对象。一个简单的实验可以证明这一点（若执行这个程序时有麻烦，请参考第3章3.1.2小节&ldquo;赋值&rdquo;）：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: PassHandles.java</span> <span style="color: #009900">// Passing handles around</span> <span style="color: #0000ff">package</span> c12;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> PassHandles &#123;&nbsp;&nbsp; <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> f(PassHandles h) &#123;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;h inside f(): &quot;</span> + h);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; PassHandles p = <span style="color: #0000ff">new</span> PassHandles();&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;p inside main(): &quot;</span> + p);&nbsp;&nbsp;&nbsp;&nbsp; f(p);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />toString方法会在打印语句里自动调用，而PassHandles直接从Object继承，没有toString的重新定义。因此，这里会采用toString的Object版本，打印出对象的类，接着是那个对象所在的位置（不是句柄，而是对象的实际存储位置）。输出结果如下：<br />p&nbsp;&nbsp;inside main(): PassHandles@1653748<br />h inside f() :&nbsp;&nbsp;PassHandles@1653748<br />可以看到，无论p还是h引用的都是同一个对象。这比复制一个新的PassHandles对象有效多了，使我们能将一个参数发给一个方法。但这样做也带来了另一个重要的问题。<br /><br />12.1.1&nbsp;&nbsp;别名问题<br />&ldquo;别名&rdquo;意味着多个句柄都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他句柄的所有者不希望那个对象改变，恐怕就要失望了。这可用下面这个简单的例子说明：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Alias1.java</span> <span style="color: #009900">// Aliasing two handles to one object</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Alias1 &#123;&nbsp;&nbsp; <span style="color: #0000ff">int</span> i;&nbsp;&nbsp; Alias1(<span style="color: #0000ff">int</span> ii) &#123; i = ii; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Alias1 x = <span style="color: #0000ff">new</span> Alias1(7);&nbsp;&nbsp;&nbsp;&nbsp; Alias1 y = x; <span style="color: #009900">// Assign the handle</span>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x: &quot;</span> + x.i);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;y: &quot;</span> + y.i);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Incrementing x&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; x.i++;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x: &quot;</span> + x.i);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;y: &quot;</span> + y.i);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />对下面这行：<br />Alias1&nbsp;&nbsp;y = x; // Assign the&nbsp;&nbsp;handle<br />它会新建一个Alias1句柄，但不是把它分配给由new创建的一个新鲜对象，而是分配给一个现有的句柄。所以句柄x的内容&mdash;&mdash;即对象x指向的地址&mdash;&mdash;被分配给y，所以无论x还是y都与相同的对象连接起来。这样一来，一旦x的i在下述语句中增值：<br />x.i++;<br />y的i值也必然受到影响。从最终的输出就可以看出：<br /> <blockquote><span style="font-size: xx-small"><pre>x: 7 y: 7 Incrementing x x: 8 y: 8</pre></span></blockquote><br />此时最直接的一个解决办法就是干脆不这样做：不要有意将多个句柄指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将句柄作为一个自变量或参数传递&mdash;&mdash;这是Java设想的正常方法&mdash;&mdash;别名问题就会自动出现，因为创建的本地句柄可能修改&ldquo;外部对象&rdquo;（在方法作用域之外创建的对象）。下面是一个例子：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Alias2.java</span> <span style="color: #009900">// Method calls implicitly alias their</span> <span style="color: #009900">// arguments.</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Alias2 &#123;&nbsp;&nbsp; <span style="color: #0000ff">int</span> i;&nbsp;&nbsp; Alias2(<span style="color: #0000ff">int</span> ii) &#123; i = ii; &#125;&nbsp;&nbsp; <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> f(Alias2 handle) &#123;&nbsp;&nbsp;&nbsp;&nbsp; handle.i++;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Alias2 x = <span style="color: #0000ff">new</span> Alias2(7);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x: &quot;</span> + x.i);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Calling f(x)&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; f(x);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x: &quot;</span> + x.i);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />输出如下：<br />x:&nbsp;&nbsp;7<br />Calling f(x)<br />x:&nbsp;&nbsp;8<br /><br />方法改变了自己的参数&mdash;&mdash;外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。<br />通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象&ldquo;发一条消息&rdquo;的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的&ldquo;副作用&rdquo;（Side&nbsp;&nbsp;Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。<br />若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。<br /><br />12.2&nbsp;&nbsp;制作本地副本<br />稍微总结一下：Java中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递&ldquo;一个对象&rdquo;时，实际传递的只是指向位于方法外部的那个对象的&ldquo;一个句柄&rdquo;。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：<br />■参数传递过程中会自动产生别名问题<br />■不存在本地对象，只有本地句柄<br />■句柄有自己的作用域，而对象没有<br />■对象的&ldquo;存在时间&rdquo;在Java里不是个问题<br />■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）<br />若只是从对象中读取信息，而不修改它，传递句柄便是自变量传递中最有效的一种形式。这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作&ldquo;本地的&rdquo;对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多<a href="http://edu.gamfe.com/gamedev.html" title="程序设计" class="ReKeyword">程序设计</a>语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。<br /><br />①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。<br /><br />12.2.1&nbsp;&nbsp;按值传递<br />首先要解决术语的问题，最适合&ldquo;按值传递&rdquo;的看起来是自变量。&ldquo;按值传递&rdquo;以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于&ldquo;按值传递&rdquo;的含义，目前存在两种存在明显区别的见解：<br />(1)&nbsp;&nbsp;Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个句柄传递进入方法，得到的是句柄的副本。所以人们认为&ldquo;一切&rdquo;都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个句柄。也就是说，它允许我们将句柄假想成&ldquo;对象&rdquo;，因为在发出方法调用时，系统会自动照管两者间的差异。<br />(2)&nbsp;&nbsp;Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个&ldquo;别名&rdquo;，所以不考虑传递句柄的问题，而是直接指出&ldquo;我准备传递对象&rdquo;。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它&ldquo;保留但未实现&rdquo;的关键字之一便是byvalue（按值）。但没人知道那个关键字什么时候可以发挥作用。<br />尽管存在两种不同的见解，但其间的分歧归根到底是由于对&ldquo;句柄&rdquo;的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的&mdash;&mdash;最重要的是理解一个句柄的传递会使调用者的对象发生意外的改变。<br /><br />12.2.2&nbsp;&nbsp;克隆对象<br />若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是&ldquo;克隆&rdquo;的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成&ldquo;protected&rdquo;（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为&ldquo;public&rdquo;模式。例如，标准库类Vector覆盖了clone()，所以能为Vector调用clone()，如下所示：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Cloning.java</span> <span style="color: #009900">// The clone() operation works for only a few</span> <span style="color: #009900">// items in the standard Java library.</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Int &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> i;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Int(<span style="color: #0000ff">int</span> ii) &#123; i = ii; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> increment() &#123; i++; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> String toString() &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">return</span> Integer.toString(i);&nbsp;&nbsp;&nbsp;&nbsp;&#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Cloning &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Vector v = <span style="color: #0000ff">new</span> Vector();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; 10; i++ )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.addElement(<span style="color: #0000ff">new</span> Int(i));&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;v: &quot;</span> + v);&nbsp;&nbsp;&nbsp;&nbsp; Vector v2 = (Vector)v.clone();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Increment all v2's elements:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(Enumeration e = v2.elements();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.hasMoreElements(); )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Int)e.nextElement()).increment();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// See if it changed v's elements:</span>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;v: &quot;</span> + v);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />clone()方法产生了一个Object，后者必须立即重新造型为正确类型。这个例子指出Vector的clone()方法不能自动尝试克隆Vector内包含的每个对象&mdash;&mdash;由于别名问题，老的Vector和克隆的Vector都包含了相同的对象。我们通常把这种情况叫作&ldquo;简单复制&rdquo;或者&ldquo;浅层复制&rdquo;，因为它只复制了一个对象的&ldquo;表面&rdquo;部分。实际对象除包含这个&ldquo;表面&rdquo;以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是&ldquo;对象网&rdquo;或&ldquo;对象关系网&rdquo;的由来。若能复制下所有这张网，便叫作&ldquo;全面复制&rdquo;或者&ldquo;深层复制&rdquo;。<br />在输出中可看到浅层复制的结果，注意对v2采取的行动也会影响到v：<br /> <blockquote><span style="font-size: xx-small"><pre>v: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] v: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</pre></span></blockquote><br />一般来说，由于不敢保证Vector里包含的对象是&ldquo;可以克隆&rdquo;（注释②）的，所以最好不要试图克隆那些对象。<br /><br />②：&ldquo;可以克隆&rdquo;用英语讲是cloneable，请留意Java库中专门保留了这样的一个关键字。<br /><br />12.2.3&nbsp;&nbsp;使类具有克隆能力<br />尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基础类方法在衍生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。<br /><br />1.&nbsp;&nbsp;使用protected时的技巧<br />为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object里得到了&ldquo;保留&rdquo;（设为protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式&mdash;&mdash;而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码：<br />Integer&nbsp;&nbsp;x = new Integer(l);<br />x =&nbsp;&nbsp;x.clone();<br />那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问clone()&mdash;&mdash;因为Integer并没有覆盖它，而且它对protected版本来说是默认的）。<br />但是，假若我们是在一个从Object衍生出来的类中（所有类都是从Object衍生的），就有权调用Object.clone()，因为它是&ldquo;protected&rdquo;，而且我们在一个继承器中。基础类clone()提供了一个有用的功能&mdash;&mdash;它进行的是对衍生类对象的真正&ldquo;按位&rdquo;复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为public，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。<br />有时还想在更深层的衍生类中覆盖clone()，否则就直接使用我们的clone()（现在已成为public），而那并不一定是我们所希望的（然而，由于Object.clone()已制作了实际对象的一个副本，所以也有可能允许这种情况）。protected的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成&ldquo;能够克隆&rdquo;。而在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java不可能在衍生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其&ldquo;关闭&rdquo;克隆能力。<br /><br />2.&nbsp;&nbsp;实现Cloneable接口<br />为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现Cloneable接口。这个接口使人稍觉奇怪，因为它是空的！<br />interface&nbsp;&nbsp;Cloneable&nbsp;&nbsp;&#123;&#125;<br />之所以要实现这个空接口，显然不是因为我们准备上溯造型成一个Cloneable，以及调用它的某个方法。有些人认为在这里使用接口属于一种&ldquo;欺骗&rdquo;行为，因为它使用的特性打的是别的主意，而非原来的意思。Cloneable&nbsp;&nbsp;interface的实现扮演了一个标记的角色，封装到类的类型中。<br />两方面的原因促成了Cloneable&nbsp;&nbsp;interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用instanceof关键字（第11章有介绍）调查句柄是否确实同一个能克隆的对象连接：<br />if(myHandle&nbsp;&nbsp;instanceof Cloneable) //&nbsp;&nbsp;...<br />第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以Object.clone()会验证一个类是否真的是实现了Cloneable接口。若答案是否定的，则&ldquo;掷&rdquo;出一个CloneNotSupportedException违例。所以在一般情况下，我们必须将&ldquo;implement&nbsp;&nbsp;Cloneable&rdquo;作为对克隆能力提供支持的一部分。<br /><br />12.2.4&nbsp;&nbsp;成功的克隆<br />理解了实现clone()方法背后的所有细节后，便可创建出能方便复制的类，以便提供了一个本地副本：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: LocalCopy.java</span> <span style="color: #009900">// Creating local copies with clone()</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> MyObject <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">int</span> i;&nbsp;&nbsp; MyObject(<span style="color: #0000ff">int</span> ii) &#123; i = ii; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;MyObject can't clone&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> String toString() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> Integer.toString(i);&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> LocalCopy &#123;&nbsp;&nbsp; <span style="color: #0000ff">static</span> MyObject g(MyObject v) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Passing a handle, modifies outside object:</span>&nbsp;&nbsp;&nbsp;&nbsp; v.i++;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> v;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">static</span> MyObject f(MyObject v) &#123;&nbsp;&nbsp;&nbsp;&nbsp; v = (MyObject)v.clone(); <span style="color: #009900">// Local copy</span>&nbsp;&nbsp;&nbsp;&nbsp; v.i++;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> v;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; MyObject a = <span style="color: #0000ff">new</span> MyObject(11);&nbsp;&nbsp;&nbsp;&nbsp; MyObject b = g(a);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Testing handle equivalence,</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// not object equivalence:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(a == b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color: #004488">&quot;a == b&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">else</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color: #004488">&quot;a != b&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;a = &quot;</span> + a);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;b = &quot;</span> + b);&nbsp;&nbsp;&nbsp;&nbsp; MyObject c = <span style="color: #0000ff">new</span> MyObject(47);&nbsp;&nbsp;&nbsp;&nbsp; MyObject d = f(c);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(c == d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color: #004488">&quot;c == d&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">else</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color: #004488">&quot;c != d&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;c = &quot;</span> + c);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;d = &quot;</span> + d);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />不管怎样，clone()必须能够访问，所以必须将其设为public（公共的）。其次，作为clone()的初期行动，应调用clone()的基础类版本。这里调用的clone()是Object内部预先定义好的。之所以能调用它，是由于它具有protected（受到保护的）属性，所以能在衍生的类里访问。<br />Object.clone()会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作&ldquo;按位复制&rdquo;，而且按一般的想法，这个工作应该是由clone()方法来做的。但在Object.clone()正式开始操作前，首先会检查一个类是否Cloneable，即是否具有克隆能力&mdash;&mdash;换言之，它是否实现了Cloneable接口。若未实现，Object.clone()就掷出一个CloneNotSupportedException违例，指出我们不能克隆它。因此，我们最好用一个try-catch块将对super.clone()的调用代码包围（或封装）起来，试图捕获一个应当永不出现的违例（因为这里确实已实现了Cloneable接口）。<br />在LocalCopy中，两个方法g()和f()揭示出两种参数传递方法间的差异。其中，g()演示的是按引用传递，它会修改外部对象，并返回对那个外部对象的一个引用。而f()是对自变量进行克隆，所以将其分离出来，并让原来的对象保持独立。随后，它继续做它希望的事情。甚至能返回指向这个新对象的一个句柄，而且不会对原来的对象产生任何副作用。注意下面这个多少有些古怪的语句：<br />v&nbsp;&nbsp;=&nbsp;&nbsp;(MyObject)v.clone();<br />它的作用正是创建一个本地副本。为避免被这样的一个语句搞混淆，记住这种相当奇怪的编码形式在Java中是完全允许的，因为有一个名字的所有东西实际都是一个句柄。所以句柄v用于克隆一个它所指向的副本，而且最终返回指向基础类型Object的一个句柄（因为它在Object.clone()中是那样被定义的），随后必须将其造型为正确的类型。<br />在main()中，两种不同参数传递方式的区别在于它们分别测试了一个不同的方法。输出结果如下：<br /> <blockquote><span style="font-size: xx-small"><pre>a == b a = 12 b = 12 c != d c = 47 d = 48</pre></span></blockquote><br />大家要记住这样一个事实：Java对&ldquo;是否等价&rdquo;的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。==和!=运算符只是简单地对比句柄的内容。若句柄内的地址相同，就认为句柄指向同样的对象，所以认为它们是&ldquo;等价&rdquo;的。所以运算符真正检测的是&ldquo;由于别名问题，句柄是否指向同一个对象？&rdquo;<br /><br />12.2.5&nbsp;&nbsp;Object.clone()的效果<br />调用Object.clone()时，实际发生的是什么事情呢？当我们在自己的类里覆盖clone()时，什么东西对于super.clone()来说是最关键的呢？根类中的clone()方法负责建立正确的存储容量，并通过&ldquo;按位复制&rdquo;将二进制位从原始对象中复制到新对象的存储空间。也就是说，它并不只是预留存储空间以及复制一个对象&mdash;&mdash;实际需要调查出欲复制之对象的准确大小，然后复制那个对象。由于所有这些工作都是在由根类定义之clone()方法的内部代码中进行的（根类并不知道要从自己这里继承出去什么），所以大家或许已经猜到，这个过程需要用RTTI判断欲克隆的对象的实际大小。采取这种方式，clone()方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。<br />不管我们要做什么，克隆过程的第一个部分通常都应该是调用super.clone()。通过进行一次准确的复制，这样做可为后续的克隆进程建立起一个良好的基础。随后，可采取另一些必要的操作，以完成最终的克隆。<br />为确切了解其他操作是什么，首先要正确理解Object.clone()为我们带来了什么。特别地，它会自动克隆所有句柄指向的目标吗？下面这个例子可完成这种形式的检测：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Snake.java</span> <span style="color: #009900">// Tests cloning to see if destination of</span> <span style="color: #009900">// handles are also cloned.</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Snake <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> Snake next;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">char</span> c;&nbsp;&nbsp; <span style="color: #009900">// Value of i == number of segments</span>&nbsp;&nbsp; Snake(<span style="color: #0000ff">int</span> i, <span style="color: #0000ff">char</span> x) &#123;&nbsp;&nbsp;&nbsp;&nbsp; c = x;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(--i &gt; 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = <span style="color: #0000ff">new</span> Snake(i, (<span style="color: #0000ff">char</span>)(x + 1));&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">void</span> increment() &#123;&nbsp;&nbsp;&nbsp;&nbsp; c++;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(next != <span style="color: #0000ff">null</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next.increment();&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> String toString() &#123;&nbsp;&nbsp;&nbsp;&nbsp; String s = <span style="color: #004488">&quot;:&quot;</span> + c;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(next != <span style="color: #0000ff">null</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += next.toString();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> s;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Snake s = <span style="color: #0000ff">new</span> Snake(5, 'a');&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;s = &quot;</span> + s);&nbsp;&nbsp;&nbsp;&nbsp; Snake s2 = (Snake)s.clone();&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;s2 = &quot;</span> + s2);&nbsp;&nbsp;&nbsp;&nbsp; s.increment();&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;after s.increment, s2 = &quot;</span> + s2);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />一条Snake（蛇）由数段构成，每一段的类型都是Snake。所以，这是一个一段段链接起来的列表。所有段都是以循环方式创建的，每做好一段，都会使第一个构建器参数的值递减，直至最终为零。而为给每段赋予一个独一无二的标记，第二个参数（一个Char）的值在每次循环构建器调用时都会递增。<br />increment()方法的作用是循环递增每个标记，使我们能看到发生的变化；而toString则循环打印出每个标记。输出如下：<br /> <blockquote><span style="font-size: xx-small"><pre>s = :a:b:c:d:e s2 = :a:b:c:d:e after s.increment, s2 = :a:c:d:e:f</pre></span></blockquote><br />这意味着只有第一段才是由Object.clone()复制的，所以此时进行的是一种&ldquo;浅层复制&rdquo;。若希望复制整条蛇&mdash;&mdash;即进行&ldquo;深层复制&rdquo;&mdash;&mdash;必须在被覆盖的clone()里采取附加的操作。<br />通常可在从一个能克隆的类里调用super.clone()，以确保所有基础类行动（包括Object.clone()）能够进行。随着是为对象内每个句柄都明确调用一个clone()；否则那些句柄会别名变成原始对象的句柄。构建器的调用也大致相同&mdash;&mdash;首先构造基础类，然后是下一个衍生的构建器&hellip;&hellip;以此类推，直到位于最深层的衍生构建器。区别在于clone()并不是个构建器，所以没有办法实现自动克隆。为了克隆，必须由自己明确进行。<br /><br />12.2.6&nbsp;&nbsp;克隆合成对象<br />试图深层复制合成对象时会遇到一个问题。必须假定成员对象中的clone()方法也能依次对自己的句柄进行深层复制，以此类推。这使我们的操作变得复杂。为了能正常实现深层复制，必须对所有类中的代码进行控制，或者至少全面掌握深层复制中需要涉及的类，确保它们自己的深层复制能正确进行。<br />下面这个例子总结了面对一个合成对象进行深层复制时需要做哪些事情：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: DeepCopy.java</span> <span style="color: #009900">// Cloning a composed object</span>&nbsp;&nbsp;<span style="color: #0000ff">class</span> DepthReading <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">double</span> depth;&nbsp;&nbsp; <span style="color: #0000ff">public</span> DepthReading(<span style="color: #0000ff">double</span> depth) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">this</span>.depth = depth;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> TemperatureReading <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">long</span> time;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">double</span> temperature;&nbsp;&nbsp; <span style="color: #0000ff">public</span> TemperatureReading(<span style="color: #0000ff">double</span> temperature) &#123;&nbsp;&nbsp;&nbsp;&nbsp; time = System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">this</span>.temperature = temperature;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> OceanReading <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> DepthReading depth;&nbsp;&nbsp; <span style="color: #0000ff">private</span> TemperatureReading temperature;&nbsp;&nbsp; <span style="color: #0000ff">public</span> OceanReading(<span style="color: #0000ff">double</span> tdata, <span style="color: #0000ff">double</span> ddata)&#123;&nbsp;&nbsp;&nbsp;&nbsp; temperature = <span style="color: #0000ff">new</span> TemperatureReading(tdata);&nbsp;&nbsp;&nbsp;&nbsp; depth = <span style="color: #0000ff">new</span> DepthReading(ddata);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; OceanReading o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = (OceanReading)<span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Must clone handles:</span>&nbsp;&nbsp;&nbsp;&nbsp; o.depth = (DepthReading)o.depth.clone();&nbsp;&nbsp;&nbsp;&nbsp; o.temperature =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TemperatureReading)o.temperature.clone();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o; <span style="color: #009900">// Upcasts back to Object</span>&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> DeepCopy &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; OceanReading reading =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">new</span> OceanReading(33.9, 100.5);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Now clone it:</span>&nbsp;&nbsp;&nbsp;&nbsp; OceanReading r =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(OceanReading)reading.clone();&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />DepthReading和TemperatureReading非常相似；它们都只包含了基本数据类型。所以clone()方法能够非常简单：调用super.clone()并返回结果即可。注意两个类使用的clone()代码是完全一致的。<br />OceanReading是由DepthReading和TemperatureReading对象合并而成的。为了对其进行深层复制，clone()必须同时克隆OceanReading内的句柄。为达到这个目标，super.clone()的结果必须造型成一个OceanReading对象（以便访问depth和temperature句柄）。<br /><br />12.2.7&nbsp;&nbsp;用Vector进行深层复制<br />下面让我们复习一下本章早些时候提出的Vector例子。这一次Int2类是可以克隆的，所以能对Vector进行深层复制：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: AddingClone.java</span> <span style="color: #009900">// You must go through a few gyrations to</span> <span style="color: #009900">// add cloning to your own class.</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Int2 <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> i;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Int2(<span style="color: #0000ff">int</span> ii) &#123; i = ii; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> increment() &#123; i++; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> String toString() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> Integer.toString(i);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Int2 can't clone&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #009900">// Once it's cloneable, inheritance</span> <span style="color: #009900">// doesn't remove cloneability:</span> <span style="color: #0000ff">class</span> Int3 <span style="color: #0000ff">extends</span> Int2 &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> j; <span style="color: #009900">// Automatically duplicated</span>&nbsp;&nbsp; <span style="color: #0000ff">public</span> Int3(<span style="color: #0000ff">int</span> i) &#123; <span style="color: #0000ff">super</span>(i); &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> AddingClone &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Int2 x = <span style="color: #0000ff">new</span> Int2(10);&nbsp;&nbsp;&nbsp;&nbsp; Int2 x2 = (Int2)x.clone();&nbsp;&nbsp;&nbsp;&nbsp; x2.increment();&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;x = &quot;</span> + x + <span style="color: #004488">&quot;, x2 = &quot;</span> + x2);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Anything inherited is also cloneable:</span>&nbsp;&nbsp;&nbsp;&nbsp; Int3 x3 = <span style="color: #0000ff">new</span> Int3(7);&nbsp;&nbsp;&nbsp;&nbsp; x3 = (Int3)x3.clone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector v = <span style="color: #0000ff">new</span> Vector();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; 10; i++ )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v.addElement(<span style="color: #0000ff">new</span> Int2(i));&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;v: &quot;</span> + v);&nbsp;&nbsp;&nbsp;&nbsp; Vector v2 = (Vector)v.clone();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Now clone each element:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; v.size(); i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v2.setElementAt(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Int2)v2.elementAt(i)).clone(), i);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Increment all v2's elements:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(Enumeration e = v2.elements();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.hasMoreElements(); )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((Int2)e.nextElement()).increment();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// See if it changed v's elements:</span>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;v: &quot;</span> + v);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;v2: &quot;</span> + v2);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />Int3自Int2继承而来，并添加了一个新的基本类型成员int&nbsp;&nbsp;j。大家也许认为自己需要再次覆盖clone()，以确保j得到复制，但实情并非如此。将Int2的clone()当作Int3的clone()调用时，它会调用Object.clone()，判断出当前操作的是Int3，并复制Int3内的所有二进制位。只要没有新增需要克隆的句柄，对Object.clone()的一个调用就能完成所有必要的复制&mdash;&mdash;无论clone()是在层次结构多深的一级定义的。<br />至此，大家可以总结出对Vector进行深层复制的先决条件：在克隆了Vector后，必须在其中遍历，并克隆由Vector指向的每个对象。为了对Hashtable（散列表）进行深层复制，也必须采取类似的处理。<br />这个例子剩余的部分显示出克隆已实际进行&mdash;&mdash;证据就是在克隆了对象以后，可以自由改变它，而原来那个对象不受任何影响。<br /><br />12.2.8&nbsp;&nbsp;通过序列化进行深层复制<br />若研究一下第10章介绍的那个Java&nbsp;&nbsp;1.1对象序列化示例，可能发现若在一个对象序列化以后再撤消对它的序列化，或者说进行装配，那么实际经历的正是一个&ldquo;克隆&rdquo;的过程。<br />那么为什么不用序列化进行深层复制呢？下面这个例子通过计算执行时间对比了这两种方法：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Compete.java</span> <span style="color: #0000ff">import</span> java.io.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Thing1 <span style="color: #0000ff">implements</span> Serializable &#123;&#125; <span style="color: #0000ff">class</span> Thing2 <span style="color: #0000ff">implements</span> Serializable &#123;&nbsp;&nbsp; Thing1 o1 = <span style="color: #0000ff">new</span> Thing1(); &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Thing3 <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Object o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Thing3 can't clone&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Thing4 <span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; Thing3 o3 = <span style="color: #0000ff">new</span> Thing3();&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; Thing4 o = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o = (Thing4)<span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Thing4 can't clone&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Clone the field, too:</span>&nbsp;&nbsp;&nbsp;&nbsp; o.o3 = (Thing3)o3.clone();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> o;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Compete &#123;&nbsp;&nbsp; <span style="color: #0000ff">static</span> <span style="color: #0000ff">final</span> <span style="color: #0000ff">int</span> SIZE = 5000;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Thing2[] a = <span style="color: #0000ff">new</span> Thing2[SIZE];&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; a.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[i] = <span style="color: #0000ff">new</span> Thing2();&nbsp;&nbsp;&nbsp;&nbsp; Thing4[] b = <span style="color: #0000ff">new</span> Thing4[SIZE];&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; b.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b[i] = <span style="color: #0000ff">new</span> Thing4();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">long</span> t1 = System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ByteArrayOutputStream buf =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">new</span> ByteArrayOutputStream();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectOutputStream o =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> ObjectOutputStream(buf);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; a.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; o.writeObject(a[i]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Now get copies:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ObjectInputStream in =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> ObjectInputStream(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> ByteArrayInputStream(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf.toByteArray()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thing2[] c = <span style="color: #0000ff">new</span> Thing2[SIZE];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; c.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c[i] = (Thing2)in.readObject();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">long</span> t2 = System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;Duplication via serialization: &quot;</span> +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (t2 - t1) + <span style="color: #004488">&quot; Milliseconds&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Now try cloning:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t1 = System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thing4[] d = <span style="color: #0000ff">new</span> Thing4[SIZE];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; d.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d[i] = (Thing4)b[i].clone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t2 = System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;Duplication via cloning: &quot;</span> +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (t2 - t1) + <span style="color: #004488">&quot; Milliseconds&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span>(Exception e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />其中，Thing2和Thing4包含了成员对象，所以需要进行一些深层复制。一个有趣的地方是尽管Serializable类很容易设置，但在复制它们时却要做多得多的工作。克隆涉及到大量的类设置工作，但实际的对象复制是相当简单的。结果很好地说明了一切。下面是几次运行分别得到的结果：<br />的确<br /> <blockquote><span style="font-size: xx-small"><pre>Duplication via serialization: 3400 Milliseconds Duplication via cloning: 110 Milliseconds&nbsp;&nbsp;Duplication via serialization: 3410 Milliseconds Duplication via cloning: 110 Milliseconds&nbsp;&nbsp;Duplication via serialization: 3520 Milliseconds Duplication via cloning: 110 Milliseconds</pre></span></blockquote><br />除了序列化和克隆之间巨大的时间差异以外，我们也注意到序列化技术的运行结果并不稳定，而克隆每一次花费的时间都是相同的。<br /><br />12.2.9&nbsp;&nbsp;使克隆具有更大的深度<br />若新建一个类，它的基础类会默认为Object，并默认为不具备克隆能力（就象在下一节会看到的那样）。只要不明确地添加克隆能力，这种能力便不会自动产生。但我们可以在任何层添加它，然后便可从那个层开始向下具有克隆能力。如下所示：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: HorrorFlick.java</span> <span style="color: #009900">// You can insert Cloneability at any</span> <span style="color: #009900">// level of inheritance.</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Person &#123;&#125; <span style="color: #0000ff">class</span> Hero <span style="color: #0000ff">extends</span> Person &#123;&#125; <span style="color: #0000ff">class</span> Scientist <span style="color: #0000ff">extends</span> Person&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span> (CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// this should never happen:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// It's Cloneable already!</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> InternalError();&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp; &#125; &#125; <span style="color: #0000ff">class</span> MadScientist <span style="color: #0000ff">extends</span> Scientist &#123;&#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> HorrorFlick &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Person p = <span style="color: #0000ff">new</span> Person();&nbsp;&nbsp;&nbsp;&nbsp; Hero h = <span style="color: #0000ff">new</span> Hero();&nbsp;&nbsp;&nbsp;&nbsp; Scientist s = <span style="color: #0000ff">new</span> Scientist();&nbsp;&nbsp;&nbsp;&nbsp; MadScientist m = <span style="color: #0000ff">new</span> MadScientist();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #009900">// p = (Person)p.clone(); // Compile error</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// h = (Hero)h.clone(); // Compile error</span>&nbsp;&nbsp;&nbsp;&nbsp; s = (Scientist)s.clone();&nbsp;&nbsp;&nbsp;&nbsp; m = (MadScientist)m.clone();&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />添加克隆能力之前，编译器会阻止我们的克隆尝试。一旦在Scientist里添加了克隆能力，那么Scientist以及它的所有&ldquo;后裔&rdquo;都可以克隆。<br /><br />12.2.10&nbsp;&nbsp;为什么有这个奇怪的设计<br />之所以感觉这个方案的奇特，因为它事实上的确如此。也许大家会奇怪它为什么要象这样运行，而该方案背后的真正含义是什么呢？后面讲述的是一个未获证实的故事&mdash;&mdash;大概是由于围绕Java的许多买卖使其成为一种设计优良的语言&mdash;&mdash;但确实要花许多口舌才能讲清楚这背后发生的所有事情。<br />最初，Java只是作为一种用于控制硬件的语言而设计，与因特网并没有丝毫联系。象这样一类面向大众的语言一样，其意义在于程序员可以对任意一个对象进行克隆。这样一来，clone()就放置在根类Object里面，但因为它是一种公用方式，因而我们通常能够对任意一个对象进行克隆。看来这是最灵活的方式了，毕竟它不会带来任何害处。<br />正当Java看起来象一种终级因特网<a href="http://edu.gamfe.com/gamedev.html" title="程序设计" class="ReKeyword">程序设计</a>语言的时候，情况却发生了变化。突然地，人们提出了安全问题，而且理所当然，这些问题与使用对象有关，我们不愿望任何人克隆自己的保密对象。所以我们最后看到的是为原来那个简单、直观的方案添加的大量补丁：clone()在Object里被设置成&ldquo;protected&rdquo;。必须将其覆盖，并使用&ldquo;implement&nbsp;&nbsp;Cloneable&rdquo;，同时解决违例的问题。<br />只有在准备调用Object的clone()方法时，才没有必要使用Cloneable接口，因为那个方法会在运行期间得到检查，以确保我们的类实现了Cloneable。但为了保持连贯性（而且由于Cloneable无论如何都是空的），最好还是由自己实现Cloneable。<br /><br />12.3&nbsp;&nbsp;克隆的控制<br />为消除克隆能力，大家也许认为只需将clone()方法简单地设为private（私有）即可，但这样是行不通的，因为不能采用一个基础类方法，并使其在衍生类中更&ldquo;私有&rdquo;。所以事情并没有这么简单。此外，我们有必要控制一个对象是否能够克隆。对于我们设计的一个类，实际有许多种方案都是可以采取的：<br />(1)&nbsp;&nbsp;保持中立，不为克隆做任何事情。也就是说，尽管不可对我们的类克隆，但从它继承的一个类却可根据实际情况决定克隆。只有Object.clone()要对类中的字段进行某些合理的操作时，才可以作这方面的决定。<br />(2)&nbsp;&nbsp;支持clone()，采用实现Cloneable（可克隆）能力的标准操作，并覆盖clone()。在被覆盖的clone()中，可调用super.clone()，并捕获所有违例（这样可使clone()不&ldquo;掷&rdquo;出任何违例）。<br />(3)&nbsp;&nbsp;有条件地支持克隆。若类容纳了其他对象的句柄，而那些对象也许能够克隆（集合类便是这样的一个例子），就可试着克隆拥有对方句柄的所有对象；如果它们&ldquo;掷&rdquo;出了违例，只需让这些违例通过即可。举个例子来说，假设有一个特殊的Vector，它试图克隆自己容纳的所有对象。编写这样的一个Vector时，并不知道客户程序员会把什么形式的对象置入这个Vector中，所以并不知道它们是否真的能够克隆。<br />(4)&nbsp;&nbsp;不实现Cloneable()，但是将clone()覆盖成protected，使任何字段都具有正确的复制行为。这样一来，从这个类继承的所有东西都能覆盖clone()，并调用super.clone()来产生正确的复制行为。注意在我们实现方案里，可以而且应该调用super.clone()&mdash;&mdash;即使那个方法本来预期的是一个Cloneable对象（否则会掷出一个违例），因为没有人会在我们这种类型的对象上直接调用它。它只有通过一个衍生类调用；对那个衍生类来说，如果要保证它正常工作，需实现Cloneable。<br />(5)&nbsp;&nbsp;不实现Cloneable来试着防止克隆，并覆盖clone()，以产生一个违例。为使这一设想顺利实现，只有令从它衍生出来的任何类都调用重新定义后的clone()里的suepr.clone()。<br />(6)&nbsp;&nbsp;将类设为final，从而防止克隆。若clone()尚未被我们的任何一个上级类覆盖，这一设想便不会成功。若已被覆盖，那么再一次覆盖它，并&ldquo;掷&rdquo;出一个CloneNotSupportedException（克隆不支持）违例。为担保克隆被禁止，将类设为final是唯一的办法。除此以外，一旦涉及保密对象或者遇到想对创建的对象数量进行控制的其他情况，应该将所有构建器都设为private，并提供一个或更多的特殊方法来创建对象。采用这种方式，这些方法就可以限制创建的对象数量以及它们的创建条件&mdash;&mdash;一种特殊情况是第16章要介绍的singleton（独子）方案。<br /><br />下面这个例子总结了克隆的各种实现方法，然后在层次结构中将其&ldquo;关闭&rdquo;：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: CheckCloneable.java</span> <span style="color: #009900">// Checking to see if a handle can be cloned</span>&nbsp;&nbsp;<span style="color: #009900">// Can't clone this because it doesn't</span> <span style="color: #009900">// override clone():</span> <span style="color: #0000ff">class</span> Ordinary &#123;&#125;&nbsp;&nbsp;<span style="color: #009900">// Overrides clone, but doesn't implement</span> <span style="color: #009900">// Cloneable:</span> <span style="color: #0000ff">class</span> WrongClone <span style="color: #0000ff">extends</span> Ordinary &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">throws</span> CloneNotSupportedException &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">super</span>.clone(); <span style="color: #009900">// Throws exception</span>&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #009900">// Does all the right things for cloning:</span> <span style="color: #0000ff">class</span> IsCloneable <span style="color: #0000ff">extends</span> Ordinary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">implements</span> Cloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">throws</span> CloneNotSupportedException &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #009900">// Turn off cloning by throwing the exception:</span> <span style="color: #0000ff">class</span> NoMore <span style="color: #0000ff">extends</span> IsCloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">throws</span> CloneNotSupportedException &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> CloneNotSupportedException();&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> TryMore <span style="color: #0000ff">extends</span> NoMore &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">throws</span> CloneNotSupportedException &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Calls NoMore.clone(), throws exception:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">super</span>.clone();&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> BackOn <span style="color: #0000ff">extends</span> NoMore &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> BackOn duplicate(BackOn b) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Somehow make a copy of b</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// and return that copy. This is a dummy</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// copy, just to make the point:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> BackOn();&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Object clone() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Doesn't call NoMore.clone():</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> duplicate(<span style="color: #0000ff">this</span>);&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #009900">// Can't inherit from this, so can't override</span> <span style="color: #009900">// the clone method like in BackOn:</span> <span style="color: #0000ff">final</span> <span style="color: #0000ff">class</span> ReallyNoMore <span style="color: #0000ff">extends</span> NoMore &#123;&#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> CheckCloneable &#123;&nbsp;&nbsp; <span style="color: #0000ff">static</span> Ordinary tryToClone(Ordinary ord) &#123;&nbsp;&nbsp;&nbsp;&nbsp; String id = ord.getClass().getName();&nbsp;&nbsp;&nbsp;&nbsp; Ordinary x = <span style="color: #0000ff">null</span>;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">if</span>(ord <span style="color: #0000ff">instanceof</span> Cloneable) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">try</span> &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Attempting &quot;</span> + id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = (Ordinary)((IsCloneable)ord).clone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;Cloned &quot;</span> + id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125; <span style="color: #0000ff">catch</span>(CloneNotSupportedException e) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;Could not clone &quot;</span> + id);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> x;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Upcasting:</span>&nbsp;&nbsp;&nbsp;&nbsp; Ordinary[] ord = &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">new</span> IsCloneable(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> WrongClone(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> NoMore(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> TryMore(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> BackOn(),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">new</span> ReallyNoMore(),&nbsp;&nbsp;&nbsp;&nbsp; &#125;;&nbsp;&nbsp;&nbsp;&nbsp; Ordinary x = <span style="color: #0000ff">new</span> Ordinary();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// This won't compile, since clone() is</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// protected in Object:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">//! x = (Ordinary)x.clone();</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// tryToClone() checks first to see if</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// a class implements Cloneable:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; ord.length; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tryToClone(ord[i]);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />第一个类Ordinary代表着大家在本书各处最常见到的类：不支持克隆，但在它正式应用以后，却也不禁止对其克隆。但假如有一个指向Ordinary对象的句柄，而且那个对象可能是从一个更深的衍生类上溯造型来的，便不能判断它到底能不能克隆。<br />WrongClone类揭示了实现克隆的一种不正确途径。它确实覆盖了Object.clone()，并将那个方法设为public，但却没有实现Cloneable。所以一旦发出对super.clone()的调用（由于对Object.clone()的一个调用造成的），便会无情地掷出CloneNotSupportedException违例。<br />在IsCloneable中，大家看到的才是进行克隆的各种正确行动：先覆盖clone()，并实现了Cloneable。但是，这个clone()方法以及本例的另外几个方法并不捕获CloneNotSupportedException违例，而是任由它通过，并传递给调用者。随后，调用者必须用一个try-catch代码块把它包围起来。在我们自己的clone()方法中，通常需要在clone()内部捕获CloneNotSupportedException违例，而不是任由它通过。正如大家以后会理解的那样，对这个例子来说，让它通过是最正确的做法。<br />类NoMore试图按照Java设计者打算的那样&ldquo;关闭&rdquo;克隆：在衍生类clone()中，我们掷出CloneNotSupportedException违例。TryMore类中的clone()方法正确地调用super.clone()，并解析成NoMore.clone()，后者掷出一个违例并禁止克隆。<br />但在已被覆盖的clone()方法中，假若程序员不遵守调用super.clone()的&ldquo;正确&rdquo;方法，又会出现什么情况呢？在BackOn中，大家可看到实际会发生什么。这个类用一个独立的方法duplicate()制作当前对象的一个副本，并在clone()内部调用这个方法，而不是调用super.clone()。违例永远不会产生，而且新类是可以克隆的。因此，我们不能依赖&ldquo;掷&rdquo;出一个违例的方法来防止产生一个可克隆的类。唯一安全的方法在ReallyNoMore中得到了演示，它设为final，所以不可继承。这意味着假如clone()在final类中掷出了一个违例，便不能通过继承来进行修改，并可有效地禁止克隆（不能从一个拥有任意继承级数的类中明确调用Object.clone()；只能调用super.clone()，它只可访问直接基础类）。因此，只要制作一些涉及安全问题的对象，就最好把那些类设为final。<br />在类CheckCloneable中，我们看到的第一个类是tryToClone()，它能接纳任何Ordinary对象，并用instanceof检查它是否能够克隆。若答案是肯定的，就将对象造型成为一个IsCloneable，调用clone()，并将结果造型回Ordinary，最后捕获有可能产生的任何违例。请注意用运行期类型鉴定（见第11章）打印出类名，使自己看到发生的一切情况。<br />在main()中，我们创建了不同类型的Ordinary对象，并在数组定义中上溯造型成为Ordinary。在这之后的头两行代码创建了一个纯粹的Ordinary对象，并试图对其克隆。然而，这些代码不会得到编译，因为clone()是Object中的一个protected（受到保护的）方法。代码剩余的部分将遍历数组，并试着克隆每个对象，分别报告它们的成功或失败。输出如下：<br /> <blockquote><span style="font-size: xx-small"><pre>Attempting IsCloneable Cloned IsCloneable Attempting NoMore Could not clone NoMore Attempting TryMore Could not clone TryMore Attempting BackOn Cloned BackOn Attempting ReallyNoMore Could not clone ReallyNoMore</pre></span></blockquote><br />总之，如果希望一个类能够克隆，那么：<br />(1)&nbsp;&nbsp;实现Cloneable接口<br />(2) 覆盖clone()<br />(3) 在自己的clone()中调用super.clone()<br />(4)&nbsp;&nbsp;在自己的clone()中捕获违例<br />这一系列步骤能达到最理想的效果。<br /><br />12.3.1&nbsp;&nbsp;副本构建器<br />克隆看起来要求进行非常复杂的设置，似乎还该有另一种替代方案。一个办法是制作特殊的构建器，令其负责复制一个对象。在C++中，这叫作&ldquo;副本构建器&rdquo;。刚开始的时候，这好象是一种非常显然的解决方案（如果你是C++程序员，这个方法就更显亲切）。下面是一个实际的例子：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: CopyConstructor.java</span> <span style="color: #009900">// A constructor for copying an object</span> <span style="color: #009900">// of the same type, as an attempt to create</span> <span style="color: #009900">// a local copy.</span>&nbsp;&nbsp;<span style="color: #0000ff">class</span> FruitQualities &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> weight;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> color;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> firmness;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> ripeness;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> smell;&nbsp;&nbsp; <span style="color: #009900">// etc.</span>&nbsp;&nbsp; FruitQualities() &#123; <span style="color: #009900">// Default constructor</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// do something meaningful...</span>&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #009900">// Other constructors:</span>&nbsp;&nbsp; <span style="color: #009900">// ...</span>&nbsp;&nbsp; <span style="color: #009900">// Copy constructor:</span>&nbsp;&nbsp; FruitQualities(FruitQualities f) &#123;&nbsp;&nbsp;&nbsp;&nbsp; weight = f.weight;&nbsp;&nbsp;&nbsp;&nbsp; color = f.color;&nbsp;&nbsp;&nbsp;&nbsp; firmness = f.firmness;&nbsp;&nbsp;&nbsp;&nbsp; ripeness = f.ripeness;&nbsp;&nbsp;&nbsp;&nbsp; smell = f.smell;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// etc.</span>&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Seed &#123;&nbsp;&nbsp; <span style="color: #009900">// Members...</span>&nbsp;&nbsp; Seed() &#123; <span style="color: #009900">/* Default constructor */</span> &#125;&nbsp;&nbsp; Seed(Seed s) &#123; <span style="color: #009900">/* Copy constructor */</span> &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Fruit &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> FruitQualities fq;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> seeds;&nbsp;&nbsp; <span style="color: #0000ff">private</span> Seed[] s;&nbsp;&nbsp; Fruit(FruitQualities q, <span style="color: #0000ff">int</span> seedCount) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fq = q;&nbsp;&nbsp;&nbsp;&nbsp; seeds = seedCount;&nbsp;&nbsp;&nbsp;&nbsp; s = <span style="color: #0000ff">new</span> Seed[seeds];&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; seeds; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i] = <span style="color: #0000ff">new</span> Seed();&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #009900">// Other constructors:</span>&nbsp;&nbsp; <span style="color: #009900">// ...</span>&nbsp;&nbsp; <span style="color: #009900">// Copy constructor:</span>&nbsp;&nbsp; Fruit(Fruit f) &#123;&nbsp;&nbsp;&nbsp;&nbsp; fq = <span style="color: #0000ff">new</span> FruitQualities(f.fq);&nbsp;&nbsp;&nbsp;&nbsp; seeds = f.seeds;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Call all Seed copy-constructors:</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; seeds; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s[i] = <span style="color: #0000ff">new</span> Seed(f.s[i]);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Other copy-construction activities...</span>&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #009900">// To allow derived constructors (or other </span>&nbsp;&nbsp; <span style="color: #009900">// methods) to put in different qualities:</span>&nbsp;&nbsp; <span style="color: #0000ff">protected</span> <span style="color: #0000ff">void</span> addQualities(FruitQualities q) &#123;&nbsp;&nbsp;&nbsp;&nbsp; fq = q;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">protected</span> FruitQualities getQualities() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> fq;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> Tomato <span style="color: #0000ff">extends</span> Fruit &#123;&nbsp;&nbsp; Tomato() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">super</span>(<span style="color: #0000ff">new</span> FruitQualities(), 100);&nbsp;&nbsp; &#125;&nbsp;&nbsp; Tomato(Tomato t) &#123; <span style="color: #009900">// Copy-constructor</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">super</span>(t); <span style="color: #009900">// Upcast for base copy-constructor</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Other copy-construction activities...</span>&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> ZebraQualities <span style="color: #0000ff">extends</span> FruitQualities &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> stripedness;&nbsp;&nbsp; ZebraQualities() &#123; <span style="color: #009900">// Default constructor</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// do something meaningful...</span>&nbsp;&nbsp; &#125;&nbsp;&nbsp; ZebraQualities(ZebraQualities z) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">super</span>(z);&nbsp;&nbsp;&nbsp;&nbsp; stripedness = z.stripedness;&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">class</span> GreenZebra <span style="color: #0000ff">extends</span> Tomato &#123;&nbsp;&nbsp; GreenZebra() &#123;&nbsp;&nbsp;&nbsp;&nbsp; addQualities(<span style="color: #0000ff">new</span> ZebraQualities());&nbsp;&nbsp; &#125;&nbsp;&nbsp; GreenZebra(GreenZebra g) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">super</span>(g); <span style="color: #009900">// Calls Tomato(Tomato)</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Restore the right qualities:</span>&nbsp;&nbsp;&nbsp;&nbsp; addQualities(<span style="color: #0000ff">new</span> ZebraQualities());&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">void</span> evaluate() &#123;&nbsp;&nbsp;&nbsp;&nbsp; ZebraQualities zq =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ZebraQualities)getQualities();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Do something with the qualities</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// ...</span>&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> CopyConstructor &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> ripen(Tomato t) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// Use the &quot;copy constructor&quot;:</span>&nbsp;&nbsp;&nbsp;&nbsp; t = <span style="color: #0000ff">new</span> Tomato(t);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span style="color: #004488">&quot;In ripen, t is a &quot;</span> +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.getClass().getName());&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> slice(Fruit f) &#123;&nbsp;&nbsp;&nbsp;&nbsp; f = <span style="color: #0000ff">new</span> Fruit(f); <span style="color: #009900">// Hmmm... will this work?</span>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;In slice, f is a &quot;</span> +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.getClass().getName());&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Tomato tomato = <span style="color: #0000ff">new</span> Tomato();&nbsp;&nbsp;&nbsp;&nbsp; ripen(tomato); <span style="color: #009900">// OK</span>&nbsp;&nbsp;&nbsp;&nbsp; slice(tomato); <span style="color: #009900">// OOPS!</span>&nbsp;&nbsp;&nbsp;&nbsp; GreenZebra g = <span style="color: #0000ff">new</span> GreenZebra();&nbsp;&nbsp;&nbsp;&nbsp; ripen(g); <span style="color: #009900">// OOPS!</span>&nbsp;&nbsp;&nbsp;&nbsp; slice(g); <span style="color: #009900">// OOPS!</span>&nbsp;&nbsp;&nbsp;&nbsp; g.evaluate();&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />这个例子第一眼看上去显得有点奇怪。不同水果的质量肯定有所区别，但为什么只是把代表那些质量的数据成员直接置入Fruit（水果）类？有两方面可能的原因。第一个是我们可能想简便地插入或修改质量。注意Fruit有一个protected（受到保护的）addQualities()方法，它允许衍生类来进行这些插入或修改操作（大家或许会认为最合乎逻辑的做法是在Fruit中使用一个protected构建器，用它获取FruitQualities参数，但构建器不能继承，所以不可在第二级或级数更深的类中使用它）。通过将水果的质量置入一个独立的类，可以得到更大的灵活性，其中包括可以在特定Fruit对象的存在期间中途更改质量。<br />之所以将FruitQualities设为一个独立的对象，另一个原因是考虑到我们有时希望添加新的质量，或者通过继承与多形性改变行为。注意对GreenZebra来说（这实际是西红柿的一类&mdash;&mdash;我已栽种成功，它们简直令人难以置信），构建器会调用addQualities()，并为其传递一个ZebraQualities对象。该对象是从FruitQualities衍生出来的，所以能与基础类中的FruitQualities句柄联系在一起。当然，一旦GreenZebra使用FruitQualities，就必须将其下溯造型成为正确的类型（就象evaluate()中展示的那样），但它肯定知道类型是ZebraQualities。<br />大家也看到有一个Seed（种子）类，Fruit（大家都知道，水果含有自己的种子）包含了一个Seed数组。<br />最后，注意每个类都有一个副本构建器，而且每个副本构建器都必须关心为基础类和成员对象调用副本构建器的问题，从而获得&ldquo;深层复制&rdquo;的效果。对副本构建器的测试是在CopyConstructor类内进行的。方法ripen()需要获取一个Tomato参数，并对其执行副本构建工作，以便复制对象：<br />t&nbsp;&nbsp;= new Tomato(t);<br />而slice()需要获取一个更常规的Fruit对象，而且对它进行复制：<br />f = new&nbsp;&nbsp;Fruit(f);<br />它们都在main()中伴随不同种类的Fruit进行测试。下面是输出结果：<br /> <blockquote><span style="font-size: xx-small"><pre>In ripen, t is a Tomato In slice, f is a Fruit In ripen, t is a Tomato In slice, f is a Fruit</pre></span></blockquote><br />从中可以看出一个问题。在slice()内部对Tomato进行了副本构建工作以后，结果便不再是一个Tomato对象，而只是一个Fruit。它已丢失了作为一个Tomato（西红柿）的所有特征。此外，如果采用一个GreenZebra，ripen()和slice()会把它分别转换成一个Tomato和一个Fruit。所以非常不幸，假如想制作对象的一个本地副本，Java中的副本构建器便不是特别适合我们。<br /><br />1.&nbsp;&nbsp;为什么在C++的作用比在Java中大？<br />副本构建器是C++的一个基本构成部分，因为它能自动产生对象的一个本地副本。但前面的例子确实证明了它不适合在Java中使用，为什么呢？在Java中，我们操控的一切东西都是句柄，而在C++中，却可以使用类似于句柄的东西，也能直接传递对象。这时便要用到C++的副本构建器：只要想获得一个对象，并按值传递它，就可以复制对象。所以它在C++里能很好地工作，但应注意这套机制在Java里是很不通的，所以不要用它。<br /><br />12.4&nbsp;&nbsp;只读类<br />尽管在一些特定的场合，由clone()产生的本地副本能够获得我们希望的结果，但程序员（方法的作者）不得不亲自禁止别名处理的副作用。假如想制作一个库，令其具有常规用途，但却不能担保它肯定能在正确的类中得以克隆，这时又该怎么办呢？更有可能的一种情况是，假如我们想让别名发挥积极的作用&mdash;&mdash;禁止不必要的对象复制&mdash;&mdash;但却不希望看到由此造成的副作用，那么又该如何处理呢？<br />一个办法是创建&ldquo;不变对象&rdquo;，令其从属于只读类。可定义一个特殊的类，使其中没有任何方法能造成对象内部状态的改变。在这样的一个类中，别名处理是没有问题的。因为我们只能读取内部状态，所以当多处代码都读取相同的对象时，不会出现任何副作用。<br />作为&ldquo;不变对象&rdquo;一个简单例子，Java的标准库包含了&ldquo;封装器&rdquo;（wrapper）类，可用于所有基本数据类型。大家可能已发现了这一点，如果想在一个象Vector（只采用Object句柄）这样的集合里保存一个int数值，可以将这个int封装到标准库的Integer类内部。如下所示：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: ImmutableInteger.java</span> <span style="color: #009900">// The Integer class cannot be changed</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> ImmutableInteger &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Vector v = <span style="color: #0000ff">new</span> Vector();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; 10; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.addElement(<span style="color: #0000ff">new</span> Integer(i));&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// But how do you change the int</span>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// inside the Integer?</span>&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />Integer类（以及基本的&ldquo;封装器&rdquo;类）用简单的形式实现了&ldquo;不变性&rdquo;：它们没有提供可以修改对象的方法。<br />若确实需要一个容纳了基本数据类型的对象，并想对基本数据类型进行修改，就必须亲自创建它们。幸运的是，操作非常简单：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: MutableInteger.java</span> <span style="color: #009900">// A changeable wrapper class</span> <span style="color: #0000ff">import</span> java.util.*;&nbsp;&nbsp;<span style="color: #0000ff">class</span> IntValue &#123;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">int</span> n;&nbsp;&nbsp; IntValue(<span style="color: #0000ff">int</span> x) &#123; n = x; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> String toString() &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">return</span> Integer.toString(n);&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> MutableInteger &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Vector v = <span style="color: #0000ff">new</span> Vector();&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; 10; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.addElement(<span style="color: #0000ff">new</span> IntValue(i));&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(v);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">for</span>(<span style="color: #0000ff">int</span> i = 0; i &lt; v.size(); i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((IntValue)v.elementAt(i)).n++;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(v);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />注意n在这里简化了我们的编码。<br />若默认的初始化为零已经足够（便不需要构建器），而且不用考虑把它打印出来（便不需要toString），那么IntValue甚至还能更加简单。如下所示：<br />class&nbsp;&nbsp;IntValue &#123; int n;&nbsp;&nbsp;&#125;<br />将元素取出来，再对其进行造型，这多少显得有些笨拙，但那是Vector的问题，不是IntValue的错。<br /><br />12.4.1&nbsp;&nbsp;创建只读类<br />完全可以创建,自己的只读类，下面是个简单的例子：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Immutable1.java</span> <span style="color: #009900">// Objects that cannot be modified</span> <span style="color: #009900">// are immune to aliasing.</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Immutable1 &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> data;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable1(<span style="color: #0000ff">int</span> initVal) &#123;&nbsp;&nbsp;&nbsp;&nbsp; data = initVal;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span> read() &#123; <span style="color: #0000ff">return</span> data; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">boolean</span> nonzero() &#123; <span style="color: #0000ff">return</span> data != 0; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable1 quadruple() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> Immutable1(data * 4);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> f(Immutable1 i1) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Immutable1 quad = i1.quadruple();&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;i1 = &quot;</span> + i1.read());&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;quad = &quot;</span> + quad.read());&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Immutable1 x = <span style="color: #0000ff">new</span> Immutable1(47);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x = &quot;</span> + x.read());&nbsp;&nbsp;&nbsp;&nbsp; f(x);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;x = &quot;</span> + x.read());&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />所有数据都设为private，可以看到没有任何public方法对数据作出修改。事实上，确实需要修改一个对象的方法是quadruple()，但它的作用是新建一个Immutable1对象，初始对象则是原封未动的。<br />方法f()需要取得一个Immutable1对象，并对其采取不同的操作，而main()的输出显示出没有对x作任何修改。因此，x对象可别名处理许多次，不会造成任何伤害，因为根据Immutable1类的设计，它能保证对象不被改动。<br /><br />12.4.2&nbsp;&nbsp;&ldquo;一成不变&rdquo;的弊端<br />从表面看，不变类的建立似乎是一个好方案。但是，一旦真的需要那种新类型的一个修改的对象，就必须辛苦地进行新对象的创建工作，同时还有可能涉及更频繁的垃圾收集。对有些类来说，这个问题并不是很大。但对其他类来说（比如String类），这一方案的代价显得太高了。<br />为解决这个问题，我们可以创建一个&ldquo;同志&rdquo;类，并使其能够修改。以后只要涉及大量的修改工作，就可换为使用能修改的同志类。完事以后，再切换回不可变的类。<br />因此，上例可改成下面这个样子：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Immutable2.java</span> <span style="color: #009900">// A companion class for making changes</span> <span style="color: #009900">// to immutable objects.</span>&nbsp;&nbsp;<span style="color: #0000ff">class</span> Mutable &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> data;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Mutable(<span style="color: #0000ff">int</span> initVal) &#123;&nbsp;&nbsp;&nbsp;&nbsp; data = initVal;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Mutable add(<span style="color: #0000ff">int</span> x) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data += x;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Mutable multiply(<span style="color: #0000ff">int</span> x) &#123;&nbsp;&nbsp;&nbsp;&nbsp; data *= x;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable2 makeImmutable2() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> Immutable2(data);&nbsp;&nbsp; &#125; &#125;&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Immutable2 &#123;&nbsp;&nbsp; <span style="color: #0000ff">private</span> <span style="color: #0000ff">int</span> data;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable2(<span style="color: #0000ff">int</span> initVal) &#123;&nbsp;&nbsp;&nbsp;&nbsp; data = initVal;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span> read() &#123; <span style="color: #0000ff">return</span> data; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">boolean</span> nonzero() &#123; <span style="color: #0000ff">return</span> data != 0; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable2 add(<span style="color: #0000ff">int</span> x) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> Immutable2(data + x);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Immutable2 multiply(<span style="color: #0000ff">int</span> x) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> Immutable2(data * x);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> Mutable makeMutable() &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> Mutable(data);&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> Immutable2 modify1(Immutable2 y)&#123;&nbsp;&nbsp;&nbsp;&nbsp; Immutable2 val = y.add(12);&nbsp;&nbsp;&nbsp;&nbsp; val = val.multiply(3);&nbsp;&nbsp;&nbsp;&nbsp; val = val.add(11);&nbsp;&nbsp;&nbsp;&nbsp; val = val.multiply(2);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> val;&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #009900">// This produces the same result:</span>&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> Immutable2 modify2(Immutable2 y)&#123;&nbsp;&nbsp;&nbsp;&nbsp; Mutable m = y.makeMutable();&nbsp;&nbsp;&nbsp;&nbsp; m.add(12).multiply(3).add(11).multiply(2);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> m.makeImmutable2();&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; Immutable2 i2 = <span style="color: #0000ff">new</span> Immutable2(47);&nbsp;&nbsp;&nbsp;&nbsp; Immutable2 r1 = modify1(i2);&nbsp;&nbsp;&nbsp;&nbsp; Immutable2 r2 = modify2(i2);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;i2 = &quot;</span> + i2.read());&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;r1 = &quot;</span> + r1.read());&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(<span style="color: #004488">&quot;r2 = &quot;</span> + r2.read());&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />和往常一样，Immutable2包含的方法保留了对象不可变的特征，只要涉及修改，就创建新的对象。完成这些操作的是add()和multiply()方法。同志类叫作Mutable，它也含有add()和multiply()方法。但这些方法能够修改Mutable对象，而不是新建一个。除此以外，Mutable的一个方法可用它的数据产生一个Immutable2对象，反之亦然。<br />两个静态方法modify1()和modify2()揭示出获得同样结果的两种不同方法。在modify1()中，所有工作都是在Immutable2类中完成的，我们可看到在进程中创建了四个新的Immutable2对象（而且每次重新分配了val，前一个对象就成为垃圾）。<br />在方法modify2()中，可看到它的第一个行动是获取Immutable2&nbsp;&nbsp;y，然后从中生成一个Mutable（类似于前面对clone()的调用，但这一次创建了一个不同类型的对象）。随后，用Mutable对象进行大量修改操作，同时用不着新建许多对象。最后，它切换回Immutable2。在这里，我们只创建了两个新对象（Mutable和Immutable2的结果），而不是四个。<br />这一方法特别适合在下述场合应用：<br />(1)&nbsp;&nbsp;需要不可变的对象，而且<br />(2) 经常需要进行大量修改，或者<br />(3) 创建新的不变对象代价太高<br /><br />12.4.3&nbsp;&nbsp;不变字串<br />请观察下述代码：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: Stringer.java</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> Stringer &#123;&nbsp;&nbsp; <span style="color: #0000ff">static</span> String upcase(String s) &#123;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #0000ff">return</span> s.toUpperCase();&nbsp;&nbsp; &#125;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; String q = <span style="color: #0000ff">new</span> String(<span style="color: #004488">&quot;howdy&quot;</span>);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(q); <span style="color: #009900">// howdy</span>&nbsp;&nbsp;&nbsp;&nbsp; String qq = upcase(q);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(qq); <span style="color: #009900">// HOWDY</span>&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(q); <span style="color: #009900">// howdy</span>&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />q传递进入upcase()时，它实际是q的句柄的一个副本。该句柄连接的对象实际只在一个统一的物理位置处。句柄四处传递的时候，它的句柄会得到复制。<br />若观察对upcase()的定义，会发现传递进入的句柄有一个名字s，而且该名字只有在upcase()执行期间才会存在。upcase()完成后，本地句柄s便会消失，而upcase()返回结果&mdash;&mdash;还是原来那个字串，只是所有字符都变成了大写。当然，它返回的实际是结果的一个句柄。但它返回的句柄最终是为一个新对象的，同时原来的q并未发生变化。所有这些是如何发生的呢？<br /><br />1.&nbsp;&nbsp;隐式常数<br />若使用下述语句：<br />String s = &quot;asdf&quot;;<br />String x =&nbsp;&nbsp;Stringer.upcase(s);<br />那么真的希望upcase()方法改变自变量或者参数吗？我们通常是不愿意的，因为作为提供给方法的一种信息，自变量一般是拿给代码的读者看的，而不是让他们修改。这是一个相当重要的保证，因为它使代码更易编写和理解。<br />为了在C++中实现这一保证，需要一个特殊关键字的帮助：const。利用这个关键字，程序员可以保证一个句柄（C++叫&ldquo;指针&rdquo;或者&ldquo;引用&rdquo;）不会被用来修改原始的对象。但这样一来，C++程序员需要用心记住在所有地方都使用const。这显然易使人混淆，也不容易记住。<br /><br />2.&nbsp;&nbsp;覆盖&quot;+&quot;和StringBuffer<br />利用前面提到的技术，String类的对象被设计成&ldquo;不可变&rdquo;。若查阅联机文档中关于String类的内容（本章稍后还要总结它），就会发现类中能够修改String的每个方法实际都创建和返回了一个崭新的String对象，新对象里包含了修改过的信息&mdash;&mdash;原来的String是原封未动的。因此，Java里没有与C++的const对应的特性可用来让编译器支持对象的不可变能力。若想获得这一能力，可以自行设置，就象String那样。<br />由于String对象是不可变的，所以能够根据情况对一个特定的String进行多次别名处理。因为它是只读的，所以一个句柄不可能会改变一些会影响其他句柄的东西。因此，只读对象可以很好地解决别名问题。<br />通过修改产生对象的一个崭新版本，似乎可以解决修改对象时的所有问题，就象String那样。但对某些操作来讲，这种方法的效率并不高。一个典型的例子便是为String对象覆盖的运算符&ldquo;+&rdquo;。&ldquo;覆盖&rdquo;意味着在与一个特定的类使用时，它的含义已发生了变化（用于String的&ldquo;+&rdquo;和&ldquo;+=&rdquo;是Java中能被覆盖的唯一运算符，Java不允许程序员覆盖其他任何运算符&mdash;&mdash;注释④）。<br /><br />④：C++允许程序员随意覆盖运算符。由于这通常是一个复杂的过程（参见《Thinking&nbsp;&nbsp;in&nbsp;&nbsp;C++》，Prentice-Hall于1995年出版），所以Java的设计者认定它是一种&ldquo;糟糕&rdquo;的特性，决定不在Java中采用。但具有讽剌意味的是，运算符的覆盖在Java中要比在C++中容易得多。<br /><br />针对String对象使用时，&ldquo;+&rdquo;允许我们将不同的字串连接起来：<br /> <blockquote><span style="font-size: xx-small"><pre>String s = <span style="color: #004488">&quot;abc&quot;</span> + foo + <span style="color: #004488">&quot;def&quot;</span> + Integer.toString(47);</pre></span></blockquote><br />可以想象出它&ldquo;可能&rdquo;是如何工作的：字串&quot;abc&quot;可以有一个方法append()，它新建了一个字串，其中包含&quot;abc&quot;以及foo的内容；这个新字串然后再创建另一个新字串，在其中添加&quot;def&quot;；以此类推。<br />这一设想是行得通的，但它要求创建大量字串对象。尽管最终的目的只是获得包含了所有内容的一个新字串，但中间却要用到大量字串对象，而且要不断地进行垃圾收集。我怀疑Java的设计者是否先试过种方法（这是软件开发的一个教训&mdash;&mdash;除非自己试试代码，并让某些东西运行起来，否则不可能真正了解系统）。我还怀疑他们是否早就发现这样做获得的性能是不能接受的。<br />解决的方法是象前面介绍的那样制作一个可变的同志类。对字串来说，这个同志类叫作StringBuffer，编译器可以自动创建一个StringBuffer，以便计算特定的表达式，特别是面向String对象应用覆盖过的运算符+和+=时。下面这个例子可以解决这个问题：<br /> <blockquote><span style="font-size: xx-small"><pre><span style="color: #009900">//: ImmutableStrings.java</span> <span style="color: #009900">// Demonstrating StringBuffer</span>&nbsp;&nbsp;<span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> ImmutableStrings &#123;&nbsp;&nbsp; <span style="color: #0000ff">public</span> <span style="color: #0000ff">static</span> <span style="color: #0000ff">void</span> main(String[] args) &#123;&nbsp;&nbsp;&nbsp;&nbsp; String foo = <span style="color: #004488">&quot;foo&quot;</span>;&nbsp;&nbsp;&nbsp;&nbsp; String s = <span style="color: #004488">&quot;abc&quot;</span> + foo +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #004488">&quot;def&quot;</span> + Integer.toString(47);&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(s);&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #009900">// The &quot;equivalent&quot; using StringBuffer:</span>&nbsp;&nbsp;&nbsp;&nbsp; StringBuffer sb =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #0000ff">new</span> StringBuffer(<span style="color: #004488">&quot;abc&quot;</span>); <span style="color: #009900">// Creates String!</span>&nbsp;&nbsp;&nbsp;&nbsp; sb.append(foo);&nbsp;&nbsp;&nbsp;&nbsp; sb.append(<span style="color: #004488">&quot;def&quot;</span>); <span style="color: #009900">// Creates String!</span>&nbsp;&nbsp;&nbsp;&nbsp; sb.append(Integer.toString(47));&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(sb);&nbsp;&nbsp; &#125; &#125; <span style="color: #009900">///:~</span></pre></span></blockquote><br />创建字串s时，编译器做的工作大致等价于后面使用sb的代码&mdash;&mdash;创建一个StringBuffer，并用append()将新字符直接加入StringBuffer对象（而不是每次都产生新对象）。尽管这样做更有效，但不值得每次都创建象&quot;abc&quot;和&quot;def&quot;这样的引号字串，编译器会把它们都转换成String对象。所以尽管StringBuffer提供了更高的效率，但会产生比我们希望的多得多的对象。<br /><br />12.4.4&nbsp;&nbsp;String和StringBuffer类<br />这里总结一下同时适用于String和StringBuffer的方法，以便对它们相互间的沟通方式有一个印象。这些表格并未把每个单独的方法都包括进去，而是包含了与本次讨论有重要关系的方法。那些已被覆盖的方法用单独一行总结。<br />首先总结String类的各种方法：<br /><br />方法&nbsp;&nbsp;自变量，覆盖 用途<br /><br />构建器 已被覆盖：默认，String，StringBuffer，char数组，byte数组&nbsp;&nbsp;创建String对象<br />length() 无 String中的字符数量<br />charAt() int Index&nbsp;&nbsp;位于String内某个位置的char<br />getChars()，getBytes 开始复制的起点和终点，要向其中复制内容的数组，对目标数组的一个索引&nbsp;&nbsp;将char或byte复制到外部数组内部<br />toCharArray() 无&nbsp;&nbsp;产生一个char[]，其中包含了String内部的字符<br />equals()，equalsIgnoreCase() 用于对比的一个String&nbsp;&nbsp;对两个字串的内容进行等价性检查<br />compareTo() 用于对比的一个String&nbsp;&nbsp;结果为负、零或正，具体取决于String和自变量的字典顺序。注意大写和小写不是相等的！<br />regionMatches()&nbsp;&nbsp;这个String以及其他String的位置偏移，以及要比较的区域长度。覆盖加入了&ldquo;忽略大小写&rdquo;的特性&nbsp;&nbsp;一个布尔结果，指出要对比的区域是否相同<br />startsWith() 可能以它开头的String。覆盖在自变量里加入了偏移&nbsp;&nbsp;一个布尔结果，指出String是否以那个自变量开头<br />endsWith() 可能是这个String后缀的一个String&nbsp;&nbsp;一个布尔结果，指出自变量是不是一个后缀<br />indexOf(),lastIndexOf()&nbsp;&nbsp;已覆盖：char，char和起始索引，String，String和起始索引&nbsp;&nbsp;若自变量未在这个String里找到，则返回-1；否则返回自变量开始处的位置索引。lastIndexOf()可从终点开始回溯搜索<br />substring()&nbsp;&nbsp;已覆盖：起始索引，起始索引和结束索引 返回一个新的String对象，其中包含了指定的字符子集<br />concat() 想连结的String&nbsp;&nbsp;返回一个新String对象，其中包含了原始String的字符，并在后面加上由自变量提供的字符<br />relpace() 要查找的老字符，要用它替换的新字符&nbsp;&nbsp;返回一个新String对象，其中已完成了替换工作。若没有找到相符的搜索项，就沿用老字串<br />toLowerCase(),toUpperCase() 无&nbsp;&nbsp;返回一个新String对象，其中所有字符的大小写形式都进行了统一。若不必修改，则沿用老字串<br />trim() 无&nbsp;&nbsp;返回一个新的String对象，头尾空白均已删除。若毋需改动，则沿用老字串<br />valueOf()&nbsp;&nbsp;已覆盖：object，char[]，char[]和偏移以及计数，boolean，char，int，long，float，double&nbsp;&nbsp;返回一个String，其中包含自变量的一个字符表现形式<br />Intern() 无&nbsp;&nbsp;为每个独一无二的字符顺序都产生一个（而且只有一个）String句柄<br /><br />可以看到，一旦有必要改变原来的内容，每个String方法都小心地返回了一个新的String对象。另外要注意的一个问题是，若内容不需要改变，则方法只返回指向原来那个String的一个句柄。这样做可以节省存储空间和系统开销。<br />下面列出有关StringBuffer（字串缓冲）类的方法：<br /><br />方法&nbsp;&nbsp;自变量，覆盖 用途<br /><br />构建器 已覆盖：默认，要创建的缓冲区长度，要根据它创建的String&nbsp;&nbsp;新建一个StringBuffer对象<br />toString() 无 根据这个StringBuffer创建一个String<br />length() 无&nbsp;&nbsp;StringBuffer中的字符数量<br />capacity() 无 返回目前分配的空间大小<br />ensureCapacity() 用于表示希望容量的一个整数&nbsp;&nbsp;使StringBuffer容纳至少希望的空间大小<br />setLength() 用于指示缓冲区内字串新长度的一个整数&nbsp;&nbsp;缩短或扩充前一个字符串。如果是扩充，则用null值填充空隙<br />charAt() 表示目标元素所在位置的一个整数&nbsp;&nbsp;返回位于缓冲区指定位置处的char<br />setCharAt() 代表目标元素位置的一个整数以及元素的一个新char值&nbsp;&nbsp;修改指定位置处的值<br />getChars() 复制的起点和终点，要在其中复制的数组以及目标数组的一个索引&nbsp;&nbsp;将char复制到一个外部数组。和String不同，这里没有getBytes()可供使用<br />append()&nbsp;&nbsp;已覆盖：Object，String，char[]，特定偏移和长度的char[]，boolean，char，int，long，float，double&nbsp;&nbsp;将自变量转换成一个字串，并将其追加到当前缓冲区的末尾。若有必要，同时增大缓冲区的长度<br />insert()&nbsp;&nbsp;已覆盖，第一个自变量代表开始插入的位置：Object，String，char[]，boolean，char，int，long，float，double&nbsp;&nbsp;第二个自变量转换成一个字串，并插入当前缓冲区。插入位置在偏移区域的起点处。若有必要，同时会增大缓冲区的长度<br />reverse() 无&nbsp;&nbsp;反转缓冲内的字符顺序<br /><br />最常用的一个方法是append()。在计算包含了+和+=运算符的String表达式时，编译器便会用到这个方法。insert()方法采用类似的形式。这两个方法都能对缓冲区进行重要的操作，不需要另建新对象。<br /><br />12.4.5&nbsp;&nbsp;字串的特殊性<br />现在，大家已知道String类并非仅仅是Java提供的另一个类。String里含有大量特殊的类。通过编译器和特殊的覆盖或过载运算符+和+=，可将引号字符串转换成一个String。在本章中，大家已见识了剩下的一种特殊情况：用同志StringBuffer精心构造的&ldquo;不可变&rdquo;能力，以及编译器中出现的一些有趣现象。<br /><br />12.5&nbsp;&nbsp;总结<br />由于Java中的所有东西都是句柄，而且由于每个对象都是在内存堆中创建的&mdash;&mdash;只有不再需要的时候，才会当作垃圾收集掉，所以对象的操作方式发生了变化，特别是在传递和返回对象的时候。举个例子来说，在C和C++中，如果想在一个方法里初始化一些存储空间，可能需要请求用户将那片存储区域的地址传递进入方法。否则就必须考虑由谁负责清除那片区域。因此，这些方法的接口和对它们的理解就显得要复杂一些。但在Java中，根本不必关心由谁负责清除，也不必关心在需要一个对象的时候它是否仍然存在。因为系统会为我们照料一切。我们的程序可在需要的时候创建一个对象。而且更进一步地，根本不必担心那个对象的传输机制的细节：只需简单地传递句柄即可。有些时候，这种简化非常有价值，但另一些时候却显得有些多余。<br />可从两个方面认识这一机制的缺点：<br />(1)&nbsp;&nbsp;肯定要为额外的内存管理付出效率上的损失（尽管损失不大），而且对于运行所需的时间，总是存在一丝不确定的因素（因为在内存不够时，垃圾收集器可能会被强制采取行动）。对大多数应用来说，优点显得比缺点重要，而且部分对时间要求非常苛刻的段落可以用native方法写成（参见附录A）。<br />(2)&nbsp;&nbsp;别名处理：有时会不慎获得指向同一个对象的两个句柄。只有在这两个句柄都假定指向一个&ldquo;明确&rdquo;的对象时，才有可能产生问题。对这个问题，必须加以足够的重视。而且应该尽可能地&ldquo;克隆&rdquo;一个对象，以防止另一个句柄被不希望的改动影响。除此以外，可考虑创建&ldquo;不可变&rdquo;对象，使它的操作能返回同种类型或不同种类型的一个新对象，从而提高程序的执行效率。但千万不要改变原始对象，使对那个对象别名的其他任何方面都感觉不出变化。<br /><br />有些人认为Java的克隆是一个笨拙的家伙，所以他们实现了自己的克隆方案（注释⑤），永远杜绝调用Object.clone()方法，从而消除了实现Cloneable和捕获CloneNotSupportException违例的需要。这一做法是合理的，而且由于clone()在Java标准库中很少得以支持，所以这显然也是一种&ldquo;安全&rdquo;的方法。只要不调用Object.clone()，就不必实现Cloneable或者捕获违例，所以那看起来也是能够接受的。<br /><br />⑤：Doug&nbsp;&nbsp;Lea特别重视这个问题，并把这个方法推荐给了我，他说只需为每个类都创建一个名为duplicate()的函数即可。<br /><br />Java中一个有趣的关键字是byvalue（按值），它属于那些&ldquo;保留但未实现&rdquo;的关键字之一。在理解了别名和克隆问题以后，大家可以想象byvalue最终有一天会在Java中用于实现一种自动化的本地副本。这样做可以解决更多复杂的克隆问题，并使这种情况下的编写的代码变得更加简单和健壮。<br /><br />12.6&nbsp;&nbsp;练习<br />(1)&nbsp;&nbsp;创建一个myString类，在其中包含了一个String对象，以便用在构建器中用构建器的自变量对其进行初始化。添加一个toString()方法以及一个concatenate()方法，令其将一个String对象追加到我们的内部字串。在myString中实现clone()。创建两个static方法，每个都取得一个myString&nbsp;&nbsp;x句柄作为自己的自变量，并调用x.concatenate(&quot;test&quot;)。但在第二个方法中，请首先调用clone()。测试这两个方法，观察它们不同的结果。<br />(2)&nbsp;&nbsp;创建一个名为Battery（电池）的类，在其中包含一个int，用它表示电池的编号（采用独一无二的标识符的形式）。接下来，创建一个名为Toy的类，其中包含了一个Battery数组以及一个toString，用于打印出所有电池。为Toy写一个clone()方法，令其自动关闭所有Battery对象。克隆Toy并打印出结果，完成对它的测试。<br />(3)&nbsp;&nbsp;修改CheckCloneable.java，使所有clone()方法都能捕获CloneNotSupportException违例，而不是把它直接传递给调用者。<br />(4)&nbsp;&nbsp;修改Compete.java，为Thing2和Thing4类添加更多的成员对象，看看自己是否能判断计时随复杂性变化的规律&mdash;&mdash;是一种简单的线性关系，还是看起来更加复杂。<br />(5)&nbsp;&nbsp;从Snake.java开始，创建Snake的一个深层复制版本。&nbsp;
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2531</link>
<title><![CDATA[探索JVM上的LISP]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Wed, 09 May 2012 08:49:31 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2531</guid> 
<description>
<![CDATA[ 
	<p>当前Java领域最激动人心的事情莫过于可允许其它编程语言运行于Java虚拟机上。围绕JRuby、Groovy、Scala还有 Rhino(JavaScript引擎)的讨论已经甚嚣尘上。可为什么要墨守陈规呢？如果你真的想跳出主流，投身于一种与Java截然不同的的语言，Lisp就不失为一种很好的选择。现在已有几种可运行于JVM上的Lisp程序设计语言的开源实现，准备好开始我们的探索之旅吧！</p><div class="content-sidebar-wide"><div class="vendor-content-box-float"><h3>相关<span class="vendor">厂商</span>内容</h3><p class="entrypdf f_vcrembed"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=1847" target="_blank">同样的架构，如果用不同语言实现，对最终效果有何影响？ </a></p><p class="entrypdf f_vcrembed"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=1854" target="_blank">EF Labs代码挑战赛，写代码，赢new iPad！ </a></p><p class="entrypdf f_vcrembed"><a href="http://www.infoq.com/cn/vendorcontent/show.action?vcr=1844">百度技术沙龙第二十六期：前端组件原理及开发实践（5月20日 周日） </a></p></div></div><p>Lisp有什么值得研究呢？首先，作为已有50年历史的语言，它促成许多被我们今日视为理所当然的观念。if-then-else结构、早期的面向对象和带垃圾回收的自动内存管理的尝试都来源于此。目前Java程序员的热点话题&mdash;&mdash;词汇闭包（Lexical Closure），最初的探索也是七十年代在Lisp中展开的。除此以外，Lisp还具备其它许多语言至今都未采用的特性，这些出色的思想必将在未来引起复兴潮流。</p><p>本文的目标读者是有意了解Lisp的Java开发人员。我们将在接下来的内容中讨论当前可以用在JVM上的不同Lisp方言(dialect)，令你快速了解Lisp程序设计工作机理和其独特之处，文章的最后会演示如何将Lisp代码与Java系统进行整合。</p><p>目前存在许多可用于不同平台的Lisp系统，有免费的也有商业的。对于想要开始探索Lisp的Java用户，不离开JVM是首选，这样的话起步很容易，还可以很方便的使用所有自己熟悉的Java库和相关工具。</p><h2>Common Lisp和Scheme</h2><p>Lisp有两种主要方言（dialect）：Common Lisp和Scheme。虽然设计理念大体相似，但是它们的差别仍然足够引起孰优孰劣的激烈争论。</p><p>Common Lisp是1991年完成的ANSI标准。统一了几种早期Lisp的理念，是可用于多种应用开发的大型环境，其最为著名的应用是人工智能。而Scheme 产生于学术界，特意进行了精简化设计，经验证是一种很好的语言，既可用于计算机科学教学，又可以作为嵌入式脚本语言。你还可能会遇到其它一些比较有名的 Lisp：小型的特定于应用的DSLs，如Emacs Lisp或AutoCAD的AutoLISP。 </p><p>上面提到的两种主要方言（dialect）在JVM上都有相应的实现，相较而言Schemes的实现要成熟一些。Armed Bear Common Lisp（<a href="http://www.armedbear.org/abcl.html">www.armedbear.org/abcl.html</a>）非常彻底的实现了Common Lisp标准，但它存在一个问题，如果你没有安装别的Common List系统，就不能构建分发版本，这对新手可能是个困难。</p><p>在Scheme方面，两个主要的产品是Kawa（<a href="http://www.gnu.org/software/kawa">www.gnu.org/software/kawa</a>）和SISC（<a href="http://www.sisc-scheme.org/">www.sisc-scheme.org</a>&mdash;&mdash;the Second Interpreter of Scheme Code）。在这篇文章的例子当中，我们会用到Kawa，它实际上是个框架，能创造可编译成Java字节码的新语言。Scheme只是它的实现之一。顺便说一句，Kawa的创建者Per Bothner目前就职于Sun，主要从事JavaFX项目的编译器方面的工作。</p><p>另外一个值得一提的竟争对手是Clojure（<a href="http://clojure.sourceforge.net/">clojure.sourceforge.net</a>）。这是一种新的语言，其Lisp方言（dialect）介于Scheme和Common Lisp之间。它是直接为JVM量身打造的，因此在上面提到的所有Lisp当中，有着最为清晰Java整合方案。它还具有其它一些激动人心的特性，例如内建的支持并发和事务内存。Clojure目前仍然处于探索测试阶段，因此在它基础上构建程序还有些为时尚早，但它绝对是一个值得关注的项目。</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2138</link>
<title><![CDATA[怎样运行jar文件]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Mon, 19 Mar 2012 14:47:38 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2138</guid> 
<description>
<![CDATA[ 
	<span style="border-collapse: collapse; font-family: Verdana, Helvetica, Arial, sans-serif; color: #444444">一、制作jar文件&nbsp;<br /><br />在制作.jar 文件之前你必须先编译好你的.java文件。假设我们的文件目录是c:javamyJavahelloHello.java&nbsp;<br />现在假设Hello.java的文件内容为：&nbsp;<br /><br />/*&nbsp;<br />*&nbsp;<br />* Hello.java&nbsp;<br />*&nbsp;<br />*/&nbsp;<br /><br /><br />public class Hello &#123;&nbsp;<br /><br />public static void mian(String[] args)&#123;&nbsp;<br /><br />System.out.println(&quot;Hello, World !&quot;);&nbsp;<br /><br />&#125;&nbsp;<br /><br />&#125;&nbsp;<br /><br />在进行.jar 制作的时候你必须把路径切换到Hello.java 所在的文件目录的外一层文件夹(.jar文件要在Dos才能创建（windows平台）)，即myJava&nbsp;<br />运行如下的命令可以把当前文件夹下的所有内容都包含在.jar 文件内。&nbsp;<br /><br />c:javamyJava&gt;jar cf Hello.jar .&nbsp;<br /><br />说明一下：命令行中 jar 是生成.jar文件的程序的调用接口。 cf 是一对可选项（options）后面的Hello.jar 就是我们给文件取的名字了，最后一个点号（.）指示工具将当前目录下的所有文件都放进jar文件，jar工具进行地归操作，当文件夹中含有不止一个文件时。&nbsp;<br /><br /><br /><br />二、察看jar文件&nbsp;<br />其实，jar文件是采用WinZip 的格式进行文件压缩的，所以你可采用WinZip 解压缩文件的，还可以利用如下的命令行察看：&nbsp;<br /><br />c:javamyJava&gt;jar tf Hello.jar&nbsp;<br />你会看到本地机子里的jvm 的版本以及其生产厂家信息&nbsp;<br />还有 Main-Class: Hello.Hello 等信息。&nbsp;<br /><br /><br />三、把文件移到你喜欢的目录&nbsp;<br />假设你想把jar 文件移到目录：d:Java2myFirst 下面，请运行如下的命令：&nbsp;<br />d:Java2myFirst&gt; jar xf c:javaHello.jar&nbsp;<br />说明一下：jar 文件可以封闭，就意味着指定的包中的每一个类必须包含在同一个目录下。&nbsp;<br /><br />四：内容清单 manifest.fm&nbsp;<br />manifest.fm 文件是由键值对组成的。其中包含前面所说的jvm 的版本号 / 创建他的厂商等。&nbsp;<br /><br />五、增加清单的内容&nbsp;<br />当若我们编辑了如下的一个addContents.txt 文件&nbsp;<br /><br />Name: myJavaHello&nbsp;<br />Sealed: true&nbsp;<br /><br />则可以通过如下命令把其加入到我们的清单文件中：&nbsp;<br /><br />c:javamyJava&gt;jar umf addContents.txt Hello.jar&nbsp;<br /><br />六、运行jar文件&nbsp;<br /><br />你可以通过以下的方式来运行jar文件：&nbsp;<br />c:javamyJava&gt;java -classpath . -jar Hello.jar&nbsp;<br /><br />说明：需要命令的 -classpath . 部分是因为类的路径环境变量中没有（.）路径。&nbsp;<br /><br /><br />也可以&nbsp;<br />c:javamyJavaHello&gt;java -jar Hello.jar&nbsp;<br /><br />假如你的电脑是windows XP 版本 你还可以直接到你的c:javamyJavaHello 下双击Hello.jar 文件 但是你看不到运行的结果&nbsp;<br />（图形界面程序可以这样运行），在windows 2000 上面,jar 文件被视作.zip 文件所以你一双击他就会把你的文件解压，而不是运行文件。所以你只有采用命令行的方式了。&nbsp;<br /><br /><br />运行命令之后，你会看到在你的屏幕上显示的&nbsp;<br />Hello, World !&nbsp;<br />字样。&nbsp;<br /><br /><br />结束语：&nbsp;<br /><br />到这里我们jar 文件的创建和运行等相关的介绍算结束了。你可以试着去验证一下。然后创建复杂的程序，比如具有界面的高级程序。&nbsp;<br /><br /><br />假如你对jar 文件 很感爱好 或者 想对她有更深刻的了解那么你可以在dos 低下敲入 jar 察看更多的帮助信息和许多options 的解释。&nbsp;<br /><br /><br />jar 帮组文档内容：&nbsp;<br /><br /><br />C:&gt;jar&nbsp;<br /><br />用法：jar &#123;ctxu&#125;[vfm0Mi] [jar-文件] [manifest-文件] [-C 目录] 文件名 ...&nbsp;<br />选项：&nbsp;<br />-c 创建新的存档&nbsp;<br />-t 列出存档内容的列表&nbsp;<br />-x 展开存档中的命名的（或所有的〕文件&nbsp;<br />-u 更新已存在的存档&nbsp;<br />-v 生成具体输出到标准输出上&nbsp;<br />-f 指定存档文件名&nbsp;<br />-m 包含来自标明文件的标明信息&nbsp;<br />-0 只存储方式；未用ZIP压缩格式&nbsp;<br />-M 不产生所有项的清单（manifest〕文件&nbsp;<br />-i 为指定的jar文件产生索引信息&nbsp;<br />-C 改变到指定的目录，并且包含下列文件：&nbsp;<br />假如一个文件名是一个目录，它将被递归处理。&nbsp;<br />清单（manifest〕文件名和存档文件名都需要被指定，按'm' 和 'f'标志指定的相同顺序。&nbsp;<br />示例1：将两个class文件存档到一个名为 'classes.jar' 的存档文件中：&nbsp;<br />jar cvf classes.jar Foo.class Bar.class&nbsp;<br />示例2：用一个存在的清单（manifest）文件 'mymanifest' 将 foo/ 目录下的所有&nbsp;<br />文件存档到一个名为 'classes.jar' 的存档文件中：&nbsp;<br />jar cvfm classes.jar mymanifest -C foo/ .&nbsp;<br /><br /><br />转载自：<a style="padding-bottom: 0px; line-height: normal; margin: 0px; padding-left: 0px; padding-right: 0px; word-wrap: break-word; color: #0099cc; text-decoration: none; padding-top: 0px" rel="nofollow" href="http://jiaogen.com/show.php?tid=1265" target="_blank">http://jiaogen.com/show.php?tid=1265</a>&nbsp;<br /><br /></span>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2066</link>
<title><![CDATA[Java正确处理InterruptedException的方法]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Tue, 13 Mar 2012 09:25:35 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2066</guid> 
<description>
<![CDATA[ 
	要想讨论正确处理InterrupedtException的方法，就要知道InterruptedException是什么。<br /><br />根据Java Doc的定义<br /><br /><em>Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception.</em><br />意思是说当一个线程处于等待，睡眠，或者占用，也就是说阻塞状态，而这时线程被中断就会抛出这类错误。Java6之后结束某个线程A的方法是A.interrupt()。如果这个线程正处于非阻塞状态，比如说线程正在执行某些代码的时候，不过被interrupt，那么该线程的interrupt变量会被置为true，告诉别人说这个线程被中断了（只是一个标志位，这个变量本身并不影响线程的中断与否），而且线程会被中断，这时不会有interruptedException。但如果这时线程被阻塞了，比如说正在睡眠，那么就会抛出这个错误。请注意，这个时候变量interrupt没有被置为true,而且也没有人来中断这个线程。比如如下的代码：<br /><br /><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><strong>[java]</strong> </div></div><ol class="dp-j"><li class="alt"><span><span class="keyword">while</span><span>(</span><span class="keyword">true</span><span>)&#123; </span></span></li><li><span class="keyword">try</span><span> &#123; </span></li><li class="alt"><span>Thread.sleep(</span><span class="number">1000</span><span>); </span></li><li><span>&#125;</span><span class="keyword">catch</span><span>(InterruptedException ex) </span></li><li class="alt"><span>&#123; </span></li><li><span>logger.error(</span><span class="string">&quot;thread interrupted&quot;</span><span>,ex); </span></li><li class="alt"><span>&#125; </span></li><li><span>&#125; </span></li></ol></div><p>当线程执行sleep(1000)之后会被立即阻塞，如果在阻塞时外面调用interrupt来中断这个线程，那么就会执行</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><strong>[java]</strong> </div></div><ol class="dp-j"><li class="alt"><span><span>logger.error(</span><span class="string">&quot;thread interrupted&quot;</span><span>,ex); </span></span></li></ol></div><br />这个时候其实线程并未中断，执行完这条语句之后线程会继续执行while循环，开始sleep，所以说如果没有对InterruptedException进行处理，后果就是线程可能无法中断<br /><br /><p>所以，在任何时候碰到InterruptedException，都要手动把自己这个线程中断。由于这个时候已经处于非阻塞状态，所以可以正常中断，<span style="color: #ff0000">最正确的代码如下</span>：</p><p></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><strong>[java]</strong> </div></div><ol class="dp-j"><li class="alt"><span><span class="keyword">while</span><span>(!Thread.isInterrupted())&#123; </span></span></li><li><span class="keyword">try</span><span> &#123; </span></li><li class="alt"><span>Thread.sleep(</span><span class="number">1000</span><span>); </span></li><li><span>&#125;</span><span class="keyword">catch</span><span>(InterruptedException ex) </span></li><li class="alt"><span>&#123; </span></li><li><span>Thread.interrupt() </span></li><li class="alt"><span>&#125; </span></li><li><span>&#125; </span></li></ol></div><br />这样可以保证线程一定能够被及时中断。<br /><br />对于更为复杂的情况，除了要把自己的线程中断之外，还有可能需要抛出InterruptedException给上一层代码<br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?2065</link>
<title><![CDATA[Java中throws和throw的区别]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Tue, 13 Mar 2012 09:23:05 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?2065</guid> 
<description>
<![CDATA[ 
	<span style="font-weight: bold">java处理异常方式</span><br /><br />&nbsp;&nbsp;&nbsp;&nbsp; 在java代码中如果发生异常的话，jvm会抛出异常对象，导致程序代码中断，这个时候jvm在做的操作就是：创建异常对象，然后抛出，比如：<br /><br />int i= 1；<br />int j = 0；<br />int res = 0；<br />res = i/j；//除0错误<br />System.out.println(res);<br /><br />这5句代码运行到第四句会中断，因为jvm抛出了异常<br /><br /><span style="font-weight: bold">throw的作用</span><br />手动抛出异常<br /><br />但是有时候有些错误在jvm看来不是错误，比如说<br />int age = 0;<br />age = -100;<br />System.out.println(age);<br /><br />&nbsp;&nbsp;&nbsp; 很正常的整形变量赋值，但是在我们眼中看来就不正常，谁的年龄会是负的呢。 所以我们需要自己手动引发异常，这就是throw的作用。<br />int age = 0;<br />age = -100;<br />if(age&lt;0)<br />&#123;<br />&nbsp;&nbsp; Exception e = new Exception(&quot;throw exception&quot;);//创建异常对象<br />&nbsp;&nbsp; throw e;//抛出异常<br />&#125;<br />System.out.println(age);<br /><br /><span style="font-weight: bold">throws的作用</span> <p class="Tby149"></p><br />声明方法可能回避的异常<br /><br />&nbsp;&nbsp;&nbsp; 有异常被抛出了，就要做处理，所以java中有try-catch。可是有时候一个方法中产生了异常，但是不知道该怎么处理它，那么就放着不管，当有异常抛出时会中断该方法，而异常被抛到这个方法的调用者那里。这个有点像下属处理不了的问题就交到上司手里一样，这种情况称为回避异常。<br /><br />&nbsp;&nbsp; 但是这使得调用这个方法就有了危险，因为谁也不知道这个方法什么时候会丢一个什么样的异常给调用者，所以在定义方法时，就需要在方法头部分使用throws来声明这个方法可能回避的异常。<br />void fun()throws IOException,SQLException<br />&#123;<br />...<br />&#125;<br /><br />这表示 fun方法可能会丢两个异常出来，那么在调用fun的时候就会做好准备，比如可以这样<br />try&#123;<br />&nbsp;&nbsp; fun();<br />&#125;catch(IOException e) &#123; &#125;<br />catch(SQLException e) &#123; &#125;<br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1960</link>
<title><![CDATA[System.load 和 System.loadLibrary详解]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Sat, 03 Mar 2012 05:52:35 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1960</guid> 
<description>
<![CDATA[ 
	<div id="blog_text" class="cnt"><p></p><p>1.它们都可以用来装载库文件，不论是JNI库文件还是非JNI库文件。在任何本地方法被调用之前必须先用这个两个方法之一把相应的JNI库文件装载。<br /><br />2.System.load 参数为库文件的绝对路径，可以是任意路径。<br />例如你可以这样载入一个windows平台下JNI库文件：<br />System.load(&quot;C:&#92;&#92;Documents and Settings&#92;&#92;TestJNI.dll&quot;);。<br /><br />3. System.loadLibrary 参数为库文件名，不包含库文件的扩展名。<br />例如你可以这样载入一个windows平台下JNI库文件<br />System. loadLibrary (&quot;TestJNI&quot;);<br /><br />这里，TestJNI.dll 必须是在java.library.path这一jvm变量所指向的路径中。<br />可以通过如下方法来获得该变量的值：<br />System.getProperty(&quot;java.library.path&quot;);<br />默认情况下，在Windows平台下，该值包含如下位置：<br />1）和jre相关的一些目录<br />2）程序当前目录<br />3）Windows目录<br />4）系统目录（system32）<br />5）系统环境变量path指定目录<br /><br />4.如果你要载入的库文件静态链接到其它动态链接库，例如TestJNI.dll 静态链接到dependency.dll, 那么你必须注意：<br />1）如果你选择<br />System.load(&quot;C:&#92;&#92;Documents and Settings&#92;&#92; TestJNI.dll&quot;);<br />那 么即使你把dependency.dll同样放在C:&#92;&#92;Documents and Settings&#92;&#92;下，load还是会因为找不到依赖的dll而失败。因为jvm在载入TestJNI.dll会先去载入TestJNI.dll所依赖 的库文件dependency.dll，而dependency.dll并不位于java.library.path所指定的目录下，所以jvm找不到 dependency.dll。<br />你有两个方法解决这个问题：一是把C:&#92;&#92;Documents and Settings&#92;&#92;加入到java.library.path的路径中，例如加入到系统的path中。二是先调用<br />System.load(&quot;C:&#92;&#92;Documents and Settings&#92;&#92; dependency.dll&quot;); 让jvm先载入dependency.dll，然后再调用System.load(&quot;C:&#92;&#92;Documents and Settings&#92;&#92; TestJNI.dll&quot;);<br />2）如果你选择<br />System. loadLibrary (&quot;TestJNI&quot;);<br />那么你只要把dependency.dll放在任何java.library.path包含的路径中即可，当然也包括和TestJNI.dll相同的目录。</p></div><br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?1959</link>
<title><![CDATA[用 JNI 进行 Java 编程－高级主题]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[Java]]></category>
<pubDate>Sat, 03 Mar 2012 05:52:05 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?1959</guid> 
<description>
<![CDATA[ 
	<p><a name="N1063B"></a><span class="smalltitle">概述</span></p><p>从 Java 程序内调用本机代码破坏了 Java 程序的可移植性和安全性。尽管已编译的 Java 字节码保持了很好的可移植性，但必须为您打算用来运行该应用程序的每个平台重新编译本机代码。另外，由于本机代码在 JVM 之外执行，所以约束它的安全性协议不必和 Java 代码的相同。</p><p>从本机程序调用 Java 代码也很复杂。因为 Java 语言是面向对象的，所以从本机应用程序调用 Java 代码通常涉及面向对象技术。有些本机语言不支持面向对象编程或只是有限地支持面向对象编程（譬如 C），使用这些语言调用 Java 方法可能会产生问题。在本节中，我们将讨论使用 JNI 所带来的若干复杂性，并研究解决它们的方法。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10646"></a><span class="smalltitle">Java 字符串 vs. C 字符串</span></p><p>Java 字符串是作为 16 位 Unicode 字符存储的，而 C 字符串是作为一组 8 位且以空字符为结束的字符存储的。JNI 提供了几个有用的函数，它们用于在 Java 字符串和 C 字符串之间进行转换并操作这两种字符串。下面的代码片段演示了如何将 C 字符串转换成 Java 字符串：</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* Convert a C string to a Java String. */&nbsp;&nbsp;2. char[]&nbsp;&nbsp;str&nbsp;&nbsp;= &quot;To be or not to be.&#92;n&quot;;&nbsp;&nbsp;3. jstring jstr = (*env)-&gt;NewStringUTF(env, str); </pre></td></tr></tbody></table><br /><p>接下来，我们研究将 Java 字符串转换成 C 字符串的代码。请注意第 5 行对 ReleaseStringUTFChars() 函数的调用。当您不再使用 Java 字符串时，应该使用这个函数来释放它们。当本机代码不再需要引用字符串时，请总是确保释放它们。不这样做可能导致内存泄漏。</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* Convert a Java String into a C string. */&nbsp;&nbsp;2. char buf[128;&nbsp;&nbsp; 3. const char *newString = (*env)-&gt;GetStringUTFChars(env, jstr, 0);&nbsp;&nbsp;4. ...&nbsp;&nbsp;5. (*env)-&gt;ReleaseStringUTFChars(env, jstr, newString); </pre></td></tr></tbody></table><br /><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N1065D"></a><span class="smalltitle">Java 数组 vs. C 数组</span></p><p>与字符串类似，Java 数组和 C 数组在内存中的表示不同。幸运的是，一组 JNI 函数可以提供指向数组中元素的指针。下图显示了如何将 Java 数组映射到 JNI C 类型。</p><p>C 类型 jarray 表示通用数组。在 C 语言中，所有数组类型实际上只是 jobject 的同义类型。但是，在 C++ 语言中，所有的数组类型都继承了 jarray，jarray 又依次继承了 jobject 。有关所有 C 类型对象的继承图，请参阅<a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section6.html#appendixa">附录 A：JNI 类型</a>。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10689"></a><span class="smalltitle">使用数组</span></p><p>通常，处理数组时，首先想到要做的是确定其大小。为了做到这一点，应该使用 GetArrayLength() 函数，它返回一个表示数组大小的 jsize。</p><p>接下来，会想要获取一个指向数组元素的指针。可以使用 GetXXXArrayElement() 和 SetXXXArrayElement() 函数（根据数组的类型替换方法名中的 XXX：Object、Boolean、Byte、Char、Int、Long 等等）来访问数组中的元素。</p><p>当本机代码完成了对 Java 数组的使用时，必须调用函数 ReleaseXXXArrayElements() 来释放它。否则，可能导致内存泄漏。下面的代码段显示了如何循环遍历一个整型数组的所有元素：</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* Looping through the elements in an array. */&nbsp;&nbsp;2. int* elem = (*env)-&gt;GetIntArrayElements(env, intArray, 0);&nbsp;&nbsp;3. for (i=0; I &lt; (*env)-&gt;GetIntArrayLength(env, intArray); i++)&nbsp;&nbsp;4.&nbsp;&nbsp;&nbsp;&nbsp;sum += elem[i]&nbsp;&nbsp;5. (*env)-&gt;ReleaseIntArrayElements(env, intArray, elem, 0); </pre></td></tr></tbody></table><br /><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N106CB"></a><span class="smalltitle">局部引用 vs. 全局引用</span></p><p>当使用 JNI 编程时，会需要使用对 Java 对象的引用。缺省情况下，JNI 创建局部引用以确保它们可以被垃圾收集。由于这一点，您可能会因为尝试存储一个本地引用，以便稍后重用它而无意间编写出非法代码，如下面的代码样本所示：</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* This code is invalid! */&nbsp;&nbsp;2. static jmethodID mid;&nbsp;&nbsp;3.&nbsp;&nbsp; 4. JNIEXPORT jstring JNICALL&nbsp;&nbsp;5. Java_Sample1_accessMethod(JNIEnv *env, jobject obj)&nbsp;&nbsp;6. &#123;&nbsp;&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;8.&nbsp;&nbsp; cls = (*env)-&gt;GetObjectClass(env, obj);&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;if (cls != 0) 10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;addInt&quot;, &quot;(I)I&quot;); 11.&nbsp;&nbsp;&nbsp;&nbsp;... 12. &#125; </pre></td></tr></tbody></table><br /><p>因为第 10 行的错误，所以这个代码段是非法的。mid 是 methodID，并且 GetStaticMethodID() 返回 methodID。但是，返回的 methodID 是一个局部引用，而您不应该将一个局部引用赋给全局引用。而 mid 是一个全局引用。</p><p>在 Java_Sample1_accessMethod() 返回之后，mid 引用就不再有效，因为赋给它现在超出作用域以外的局部引用。尝试使用 mid 将导致错误结果或 JVM 崩溃。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10701"></a><span class="smalltitle">创建全局引用</span></p><p>要纠正这个问题，需要创建和使用全局引用。全局引用将在显式释放之前一直有效，您必须记住去显式地释放它。没有释放引用可能导致内存泄漏。</p><p>使用 NewGlobalRef() 创建全局引用，并用 DeleteGlobalRef() 删除它，如下面的代码样本所示：</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* This code is valid! */&nbsp;&nbsp;2. static jmethodID mid;&nbsp;&nbsp;3.&nbsp;&nbsp; 4. JNIEXPORT jstring JNICALL&nbsp;&nbsp;5. Java_Sample1_accessMethod(JNIEnv *env, jobject obj)&nbsp;&nbsp;6. &#123;&nbsp;&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;8.&nbsp;&nbsp; cls = (*env)-&gt;GetObjectClass(env, obj);&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;if (cls != 0) 10.&nbsp;&nbsp;&nbsp;&nbsp;&#123; 11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid1 = (*env)-&gt;GetStaticMethodID(env, cls, &quot;addInt&quot;, &quot;(I)I&quot;); 12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mid = (*env)-&gt;NewGlobalRef(env, mid1); 13.&nbsp;&nbsp;&nbsp;&nbsp;... 14. &#125; </pre></td></tr></tbody></table><br /><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="advancederror"></a><span class="smalltitle">错误处理</span></p><p>在 Java 程序中使用本机方法，就以某种基本的方式破坏了 Java 安全性模型。因为 Java 程序在一个受控的运行时系统（JVM）中运行，所以 Java 平台设计师决定通过检查常见运行时系统错误（如数组下标、越界错误、空指针错误）来帮助程序员。从另一方面讲，由于 C 和 C++ 不使用此类错误检查，所以本机方法程序员必须自己处理所有错误情况，而在运行时，这些错误可以在 JVM 中被捕获。</p><p>例如，对于 Java 程序而言，通过抛出一个异常来向 JVM 报告出错是常见和正确的操作。C 没有异常，因此必须使用 JNI 的异常处理函数。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10723"></a><span class="smalltitle">JNI 的异常处理函数</span></p><p>有两种方法用来在本机代码中抛出异常：可以调用 Throw() 函数或 ThrowNew() 函数。在调用 Throw() 之前，首先需要创建一个 Throwable 类型的对象。可以通过调用 ThrowNew() 跳过这一步，因为这个函数为您创建了该对象。在下面的示例代码片段中，我们使用这两个函数抛出 IOException：</p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td class="code-outline"><pre class="displaycode"> 1. /* Create the Throwable object. */&nbsp;&nbsp;2. jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/IOException&quot;);&nbsp;&nbsp;3. jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);&nbsp;&nbsp;4. jthrowable e = (*env)-&gt;NewObject(env, cls, mid);&nbsp;&nbsp;5.&nbsp;&nbsp; 6. /* Now throw the exception */&nbsp;&nbsp;7. (*env)-&gt;Throw(env, e);&nbsp;&nbsp;8. ...&nbsp;&nbsp;9.&nbsp;&nbsp;10. /* Here we do it all in one step and provide a message*/ 11. (*env)-&gt;ThrowNew(env, 12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*env)-&gt;FindClass(&quot;java/io/IOException&quot;), 13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;An IOException occurred!&quot;); </pre></td></tr></tbody></table><br /><p>Throw() 和 ThrowNew() 函数并不中断本机方法中的控制流。直到本机方法返回，在 JVM 中才会将异常实际抛出。在 C 中，一旦碰到错误条件，不能使用 Throw() 和 ThrowNew() 函数立即退出方法，而在 Java 中，这可以使用 throw 语句来退出方法。相反，需要在 Throw() 和 ThrowNew() 函数之后立即使用 return 语句，以便在出错点退出本机方法。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10762"></a><span class="smalltitle">JNI 的异常捕获函数</span></p><p>当从 C 或 C++ 调用 Java 时，也可能需要捕获异常。许多 JNI 函数都能抛出希望捕获的异常。ExceptionCheck() 函数返回 jboolean 以表明是否抛出了异常，而 ExceptionOccured() 方法返回指向当前异常的 jthrowable 引用（或者返回 NULL，如果未抛出异常的话）。</p><p>如果正在捕获异常，可能要处理异常，在这种情况下需要在 JVM 中清除该异常。可以使用 ExceptionClear() 函数来进行这个操作。ExceptionDescribed() 函数用来显示异常的调试消息。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N10789"></a><span class="smalltitle">本机方法中的多线程</span></p><p>在使用 JNI 工作时，您将遇到的更高级的问题之一是在本机方法中使用多线程。即使是在不需要支持多线程的系统上运行时，Java 平台也是作为多线程系统来实现的；因此您有责任确保本机函数是线程安全的。</p><p>在 Java 程序中，可以通过使用 synchronized 语句实现线程安全的代码。synchronized 语句的语法使您能够获取对象上的锁。只要在 synchronized 块中，就可以执行任何数据操作，而不必担心其它线程会悄悄进入并访问您锁定的对象。</p><p>JNI 使用 MonitorEnter() 和 MonitorExit() 函数提供类似的结构。对于传递到 MonitorEnter() 函数中的对象，您会得到一个用于该对象的监视器（锁），并在使用 MonitorExit() 函数释放它之前一直持有该锁。对于您锁定的对象而言，MonitorEnter() 和 MonitorExit() 函数之间的所有代码保证是线程安全的。</p><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N107BB"></a><span class="smalltitle">本机方法中的同步</span></p><p>下表显示了如何在 Java、C 和 C++ 中同步一块代码。正如您所见，这些 C 和 C++ 函数类似于 Java 代码中的 synchronized 语句。</p><table border="1"><tbody><tr><td style="color: #ff0000">XML error: The image is not displayed because the width is greater than the maximum of 580 pixels. Please decrease the image width.</td></tr></tbody></table><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N107CD"></a><span class="smalltitle">随本机方法一起使用 synchronized </span></p><p>确保本机方法同步的另一种方法是：当在 Java 类中声明 native 方法时使用 synchronized 关键字。</p><p>使用 synchronized 关键字将确保任何时候从 Java 程序调用 native 方法，它都将是 synchronized。尽管用 synchronized 关键字来标记线程安全的本机方法是个好想法，但通常最好总是在本机方法实现中实现同步。这样做的主要原因如下：</p><ul><li>C 或 C++ 代码和 Java 本机方法声明不同，因此，如果方法声明有变动（即，如果一旦除去了 synchronized 关键字），此方法可能马上不再是线程安全的了。<br /><br /></li><li>如果有人对使用该函数的其它本机方法（或其它 C 或 C++ 函数）进行编码，他们可能并没有意识到该本机实现不是线程安全的。<br /><br /></li><li>如果将函数作为普通的 C 函数在 Java 程序之外使用，则它不是线程安全的。</li></ul><div class="ibm-alternate-rule"><hr /></div><p class="ibm-ind-link ibm-back-to-top"><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html#ibm-pcon" class="ibm-anchor-up-link">回页首</a></p><p><a name="N1080C"></a><span class="smalltitle">其它同步技术</span></p><p>Object.wait()、Object.notify() 和 Object.notifyAll() 方法也支持线程同步。因为所有 Java 对象都将 Object 类作为父类，所以所有 Java 对象都有这些方法。您可以象调用其它方法一样，从本机代码调用这些方法，并以 Java 代码中相同的方式来使用它们，以实现线程同步。</p>
]]>
</description>
</item>
</channel>
</rss>