<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
<title><![CDATA[流浪的龙－个人知识管理]]></title> 
<link>http://i.renjihe.com/blog/index.php</link> 
<description><![CDATA[]]></description> 
<language>zh-cn</language> 
<copyright><![CDATA[流浪的龙－个人知识管理]]></copyright>
<item>
<link>http://i.renjihe.com/blog/read.php?5226</link>
<title><![CDATA[php脚本的执行过程（编译与执行相分离）]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Wed, 10 Jul 2013 07:03:46 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?5226</guid> 
<description>
<![CDATA[ 
	<p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">php的编译和执行是分离开的，亦即：先执行完编译，而后再执行。很多人会说：c++也是如此啊，确实。不过php的这种分离可以给我们提供很多便利，当然不可避免也有很有缺点。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">先说一下整个过程：<br />①php会调用编译函数zend_compile_file()来进行编译。 这个函数的具体实现其实是包括两个主要过程的：词法分析（Lex实现），语法分析（Yacc实现）。当执行完这个函数之后:php脚本的编译就算结束了。 这个函数的输入是：php脚本文件，而输出则是op_array.简单一点说：编译过程就是把脚本给解析成一条条php虚拟机可以处理的指令，而op_array就是这些指令做成的一个array而已（这很类似一些编译型语言编译产生的汇编代码了，也是一条条的命令）。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">②：之后php虚拟机会调用zend_execute()这个函数来执行。该函数的输入就是上边编译阶段产生的op_array，在这里他会解析每条命令并进行处理。 由于op命令一共有150左右，所以它需要处理这150中命令。这里会产生一个很有意思的问题：它是如何处理这150种命令的呢？首先每条命令都是有对应的处理器来进行处理的。所以：虚拟机会依据op_array中各条命令的类型来分发给响应的处理器来进行处理。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">这里有两个小问题： 1：这里的处理器是什么？&nbsp; 2：如何分发的？</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">要解答这两个问题都是要从分发机制上来解释：php虚拟机分发命令的机制有三种：CALL, SWITCH, 和GOTO这三种类型.php默认是使用CALL方式, 也就是所有的opcode处理器都定义为函数, 然后供虚拟机调用. 这种方式是传统的方式, 也一般被认为是最稳定的方式.而SWITCH方式和GOTO方式则是通过switch和goto来分发opcode到对应的处理逻辑(段)执行的.</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">那现在来回答上边两个问题：</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">1：处理器其实是处理op命令的逻辑。其可以以函数的形式存在，也可能是以逻辑段的方式存在，这取决于命令的分发方式。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">2：分发方式有call,switch和goto三种。哪种效率高呢？其实从上边解释已经可以初步了解了。switch和goto都是在zend_execute()这个函数中有对应的逻辑段，直接执行就可以了。而call是在zend_execute()这个函数中执行函数调用。明摆着：函数调用效率是最低的，调用一次就得压栈啊！所以效率上：call是最低的。对于switch和goto：比如要执行第三种命令的处理：switch还要先挨个判断是不是前两种，而goto根本不需要判断，直接跳到第三种命令的逻辑代码段去执行，这比switch少了顺序从上到下判断的损耗，所以：goto效率又比switch要高。&nbsp; 所以这三种分发方式总体而言：goto &gt; switch &gt; call</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">题外话：由于php默认是call，如果你想进一步榨干php的效能，可以更改下其命令分发方式为goto。不过用goto方式虽然提高了执行速度，但是编译速度上其实最慢的喔。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">再说一下php这种编译和执行分离的弱点：</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">其实也不能算是弱点，虽然zend engine(php的虚拟机)将编译和执行严格分开，但是对于用户而言：就跟没分开一样，因为我每次执行一个php脚本请求都是要执行：编译-&gt;执行&nbsp; 这两个阶段。任何一个阶段都少不了。那么这一点我们可以拿来和c++这种编译型语言做一下对比： 同一个请求运行100遍</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">①对于c++，由于其前期只要编译一遍，编译好就不会再重复编译了，只需要执行就ok，所以其损耗为：</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">1次编译 + 100次执行</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">②对于php，其每次都要编译+执行，所以其损耗为：</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">100次编译 + 100次执行</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">显然:解释性语言从数量上来看：其消耗是比编译型语言多的多。说白了就是：php这种编译和执行相分离并不是真正的分离。而c++那种才算是真正的分离。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">php也早就意识到这个问题了，于是就想了一个办法来解决这个问题：这个解决方案就是eAccelerator。主要思路如下：</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">当脚本第一次运行后，以某种方式保存编译后脚本（里边存放的是op_array），在我们规定的缓存有效时间内，当第二次运行该脚本时就不在进行重复性的编译工作，而是直接调用执行前面保存的编译后文件，大大提高了程序性能。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">这种方式一定程度上提高了php的效率，但不是最终极的方法，最终极的还是改成编译型语言那种方式好了，吼吼~~~</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">最后说一下php编译和执行分离的优点；</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">这个优点其实是针对程序员而言，对用户而言没什么。因为这两个阶段的分离，我们可以在这里做一些我们想做的事情。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">比如想做文件加解密，你想把一些php脚本源码文件加密，让用户看不到源码。同时呢这个加密后的源码文件又可以被php虚拟机所解析和处理。当然：要实现这个前提是你先想好加解密算法并保证这个是可逆的过程。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">现在你对php源码文件已经加密了，此时你需要定义一下这种加密文件的后缀，假设为:*.buaa。 那问题就是：我们怎么让php虚拟机可以处理这种后缀的文件呢？这就要用到上边所说的编译和执行相分离的过程了。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">回想一下：编译阶段的输入是php源文件，输出是op_array。 ok,我们就在这个阶段做文章。主要思路为：首先在zend_compile_file()这个编译函数中：看一下输入文件的后缀：如果是正常的.php那就走正常逻辑，如果是*.buaa，那就先解密然后再走正常逻辑。。。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">哈~就是这么简单。当然:这个过程没有所说的这么简单，而且你也不可能直接修改zend_compile_file()函数，最后是自己扩展实现一个模块来处理这个过程。</p><p style="margin: 0px 0px 15px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px">本文参考了如下博文：<br />1：http://www.laruence.com/2008/08/14/250.html<br />2：http://yanbin.org/archive/zend-engines-fantasy.html<br />3：http://www.laruence.com/2008/06/18/221.html<br />4：http://www.laruence.com/2009/10/15/1131.html</p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?5223</link>
<title><![CDATA[PHP内核探索]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Wed, 10 Jul 2013 01:59:54 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?5223</guid> 
<description>
<![CDATA[ 
	<p style="text-indent: 2em; margin: 1.2em 0em 1em; line-height: 20px; letter-spacing: 1px; color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif">此文章所在专题列表如下：</p><ol style="color: #333333; font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; line-height: 18px"><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1285" target="_blank">PHP内核探索：从SAPI接口开始</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1286" target="_blank">PHP内核探索：一次请求的开始与结束</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1287" target="_blank">PHP内核探索：一次请求生命周期</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1289" target="_blank">PHP内核探索：单进程SAPI生命周期</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1290" target="_blank">PHP内核探索：多进程/线程的SAPI生命周期</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1291" target="_blank">PHP内核探索：Zend引擎</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1292" target="_blank">PHP内核探索：再次探讨SAPI</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1293" target="_blank">PHP内核探索：Apache模块介绍</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1299" target="_blank">PHP内核探索：通过mod_php5支持PHP</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1312" target="_blank">PHP内核探索：Apache运行与钩子函数</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1318" target="_blank">PHP内核探索：嵌入式PHP</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1321" target="_blank">PHP内核探索：PHP的FastCGI</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1322" target="_blank">PHP内核探索：如何执行PHP脚本</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1323" target="_blank">PHP内核探索：PHP脚本的执行细节</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1324" target="_blank">PHP内核探索：操作码OpCode</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1325" target="_blank">PHP内核探索：PHP里的opcode</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1332" target="_blank">PHP内核探索：解释器的执行过程</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1326" target="_blank">PHP内核探索：变量概述</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1327" target="_blank">PHP内核探索：变量存储与类型</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1344" target="_blank">PHP内核探索：PHP中的哈希表</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1348" target="_blank">PHP内核探索：理解Zend里的哈希表</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1349" target="_blank">PHP内核探索：PHP哈希算法设计</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1366" target="_blank">PHP内核探索：翻译一篇HashTables文章</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1367" target="_blank">PHP内核探索：哈希碰撞攻击是什么？</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1368" target="_blank">PHP内核探索：常量的实现</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1386" target="_blank">PHP内核探索：变量的存储</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1387" target="_blank">PHP内核探索：变量的类型</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1388" target="_blank">PHP内核探索：变量的值操作</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1389" target="_blank">PHP内核探索：变量的创建</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1390" target="_blank">PHP内核探索：预定义变量</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1393" target="_blank">PHP内核探索：变量的检索</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1394" target="_blank">PHP内核探索：变量的类型转换</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1401" target="_blank">PHP内核探索：弱类型变量的实现</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1402" target="_blank">PHP内核探索：静态变量的实现</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1409" target="_blank">PHP内核探索：变量类型提示</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1414" target="_blank">PHP内核探索：变量的生命周期</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1415" target="_blank">PHP内核探索：变量赋值与销毁</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1420" target="_blank">PHP内核探索：变量作用域</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1421" target="_blank">PHP内核探索：诡异的变量名</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1423" target="_blank">PHP内核探索：变量的value和type存储</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1424" target="_blank">PHP内核探索：全局变量Global</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1437" target="_blank">PHP内核探索：变量类型的转换</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1438" target="_blank">PHP内核探索：内存管理开篇</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1439" target="_blank">PHP内核探索：Zend内存管理器</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1440" target="_blank">PHP内核探索：PHP的内存管理</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1441" target="_blank">PHP内核探索：内存的申请与销毁</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1442" target="_blank">PHP内核探索：引用计数与写时复制</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1452" target="_blank">PHP内核探索：PHP5.3的垃圾回收机制</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1453" target="_blank">PHP内核探索：内存管理中的cache</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1454" target="_blank">PHP内核探索：写时复制COW机制</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1455" target="_blank">PHP内核探索：数组与链表</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1456" target="_blank">PHP内核探索：使用哈希表API</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1457" target="_blank">PHP内核探索：数组操作</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1458" target="_blank">PHP内核探索：数组源码分析</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1462" target="_blank">PHP内核探索：函数的分类</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1463" target="_blank">PHP内核探索：函数的内部结构</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1464" target="_blank">PHP内核探索：函数结构转换</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1465" target="_blank">PHP内核探索：定义函数的过程</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1466" target="_blank">PHP内核探索：函数的参数</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1467" target="_blank">PHP内核探索：zend_parse_parameters函数</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1473" target="_blank">PHP内核探索：函数返回值</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1474" target="_blank">PHP内核探索：形参return value</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1475" target="_blank">PHP内核探索：函数调用与执行</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1489" target="_blank">PHP内核探索：引用与函数执行</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1490" target="_blank">PHP内核探索：匿名函数及闭包</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1491" target="_blank">PHP内核探索：面向对象开篇</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1492" target="_blank">PHP内核探索：类的结构和实现</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1499" target="_blank">PHP内核探索：类的成员变量</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1500" target="_blank">PHP内核探索：类的成员方法</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1512" target="_blank">PHP内核探索：类的原型zend_class_entry</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1513" target="_blank">PHP内核探索：类的定义</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1514" target="_blank">PHP内核探索：访问控制</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1515" target="_blank">PHP内核探索：继承，多态与抽象类</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1519" target="_blank">PHP内核探索：魔术函数与延迟绑定</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1520" target="_blank">PHP内核探索：保留类与特殊类</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1521" target="_blank">PHP内核探索：对象</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1522" target="_blank">PHP内核探索：创建对象实例</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1523" target="_blank">PHP内核探索：对象属性读写</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1524" target="_blank">PHP内核探索：命名空间</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1525" target="_blank">PHP内核探索：定义接口</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1526" target="_blank">PHP内核探索：继承与实现接口</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1533" target="_blank">PHP内核探索：资源resource类型</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1540" target="_blank">PHP内核探索：Zend虚拟机</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1541" target="_blank">PHP内核探索：虚拟机的词法解析</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1542" target="_blank">PHP内核探索：虚拟机的语法分析</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1543" target="_blank">PHP内核探索：中间代码opcode的执行</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1544" target="_blank">PHP内核探索：代码的加密与解密</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1580" target="_blank">PHP内核探索：zend_execute的具体执行过程</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1581" target="_blank">PHP内核探索：变量的引用与计数规则</a></li><li style="margin: 4px 0px 6px; letter-spacing: 1px"><a style="color: #333333; text-decoration: none" href="http://www.nowamagic.net/librarys/veda/detail/1582" target="_blank">PHP内核探索：新垃圾回收机制说明</a></li></ol>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4322</link>
<title><![CDATA[[nachos] nachos 缺页置换 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:30:00 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4322</guid> 
<description>
<![CDATA[ 
	<p>Lab3 只是草草的做了一下，今天上课发现确实有很多问题。还是得用虚存来实现，不过实在是懒得弄了。。</p><br /><p>1 修改exception.cc中的方法，当发生TLB MISS时，如果该页不在内存中，从磁盘中加载该页。</p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>(which&nbsp;==&nbsp;PageFaultException)&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果发生了缺页中断 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEBUG(</span><span class="string">'p'</span><span>,</span><span class="string">&quot;page&nbsp;fault&#92;n&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//获得虚拟地址 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;addr&nbsp;=&nbsp;machine-&gt;ReadRegister(BadVAddrReg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果该页不在内存中,将硬盘中的数据拷贝到内存&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(!machine-&gt;LRUSwap(addr))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;swapPage(addr);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//再将页表项拷贝到tlb表中 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;LRUSwap(addr);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stats-&gt;numPageFaults++;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;swapNum&nbsp;is&nbsp;%d&#92;n&quot;,machine-&gt;swapNum); </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">else if(which == PageFaultException)&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;//如果发生了缺页中断 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEBUG('p',&quot;page fault&#92;n&quot;); &nbsp;&nbsp;//获得虚拟地址 &nbsp;&nbsp;int addr = machine-&gt;ReadRegister(BadVAddrReg);&nbsp;&nbsp; &nbsp;&nbsp;//如果该页不在内存中,将硬盘中的数据拷贝到内存&nbsp;&nbsp; &nbsp;&nbsp;if(!machine-&gt;LRUSwap(addr)) &nbsp;&nbsp;&#123; &nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;swapPage(addr); &nbsp;&nbsp;&nbsp;&nbsp;//再将页表项拷贝到tlb表中 &nbsp;&nbsp; &nbsp;&nbsp;machine-&gt;LRUSwap(addr); &nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stats-&gt;numPageFaults++; &nbsp;&nbsp;//DEBUG('p',&quot;swapNum is %d&#92;n&quot;,machine-&gt;swapNum);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;</pre><br /><br /><br /><br />2. 在machine中添加属性，以用于缺页处理，从文件中读取某一页的内容到内存。<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span>NoffHeader&nbsp;noffH;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;用来从磁盘中读取数据到内存 </span><span>&nbsp;&nbsp;</span></span></li><li><span>OpenFile&nbsp;*executable;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;打开文件</span><span>&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">&nbsp;&nbsp;&nbsp;&nbsp;NoffHeader noffH;&nbsp;&nbsp;&nbsp;&nbsp;// 用来从磁盘中读取数据到内存&nbsp;&nbsp;&nbsp;&nbsp; OpenFile *executable;&nbsp;&nbsp;// 打开文件</pre><br />&nbsp; &nbsp;在addrspace.cc中修改构造方法，为machine初始化属性<br />&nbsp; &nbsp;//用来处理缺页置换<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span>machine-&gt;noffH&nbsp;=&nbsp;noffH;&nbsp;&nbsp;</span></span></li><li><span>machine-&gt;executable&nbsp;=&nbsp;executable;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;noffH = noffH;&nbsp;&nbsp;&nbsp;&nbsp; machine-&gt;executable = executable;</pre><br />&nbsp; &nbsp;在此时方法时注释掉该句，由于文件在缺页置换时还会用到，不能及时删除&nbsp;<br />&nbsp; &nbsp;//delete executable;<span style="white-space: pre"> </span>// close file<br /><br /><br />3.当该页不在内存时，调用 swapPage方法，从磁盘中读取一页到内存的方法。<br /><br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581354#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>Machine::swapPage(</span><span class="datatypes">int</span><span>&nbsp;addr)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;vpn&nbsp;=&nbsp;addr/PageSize;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;offset&nbsp;=&nbsp;addr%PageSize;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;swapVpn&nbsp;=&nbsp;-1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;ppn&nbsp;=&nbsp;machine-&gt;mBitmap-&gt;Find();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;min&nbsp;=&nbsp;pageTable[0].lastUseTime;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(ppn==-1)&nbsp;</span><span class="comment">//内存中没有空闲空间，利用LRU找到被置换的页 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppn&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;pageTableSize;&nbsp;i++)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(pageTable[i].lastUseTime&nbsp;&lt;&nbsp;min&nbsp;&amp;&amp;&nbsp;pageTable[i].valid&nbsp;==&nbsp;TRUE)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;pageTable[i].lastUseTime;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ppn&nbsp;=&nbsp;pageTable[i].physicalPage;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swapVpn&nbsp;=&nbsp;i;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;ppn:%d&#92;n&quot;,ppn); </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(ppn&nbsp;==&nbsp;-1)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//从硬盘中加载该页的数据 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;NoffHeader&nbsp;noffH&nbsp;=&nbsp;machine-&gt;noffH;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//int&nbsp;vAddr&nbsp;=&nbsp;vpn*PageSize;&nbsp;//该页的虚拟起始地址&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;addr:%d,pAddr:%d,vAddr:%d&#92;n&quot;,addr,pAddr,vAddr);&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;code.virtualAddr:%d,code.size:%d,code.inFileAddr:%d&#92;n&quot;, </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;&nbsp;noffH.code.virtualAddr,noffH.code.size,noffH.code.inFileAddr);&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;initData.virtualAddr:%d,initData.size:%d,initData.inFileAddr:%d&#92;n&quot;, </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;&nbsp;noffH.initData.virtualAddr,noffH.initData.size,noffH.initData.inFileAddr);&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//DEBUG('p',&quot;openFile:%d&#92;n&quot;,executable-&gt;GetFileId());&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//判断置换页中的每一个字节是在代码段还是在数据段&nbsp;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;PageSize;i++)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;vAddr&nbsp;=&nbsp;vpn*PageSize&nbsp;+&nbsp;i;&nbsp;&nbsp;&nbsp;</span><span class="comment">//要拷贝的字节的虚拟地址 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;pAddr&nbsp;=&nbsp;ppn*PageSize&nbsp;+&nbsp;i;&nbsp;&nbsp;&nbsp;</span><span class="comment">//要拷贝的字节的物理地址 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果在代码段 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(vAddr&gt;=noffH.code.virtualAddr&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;vAddr&lt;(noffH.code.virtualAddr+noffH.code.size))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[pAddr]),&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,noffH.code.inFileAddr+vAddr);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;</span><span class="comment">//如果在数据段 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>(addr&gt;=noffH.initData.virtualAddr&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;addr&lt;(noffH.initData.virtualAddr+noffH.initData.size))&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;executable-&gt;ReadAt(&amp;(machine-&gt;mainMemory[pAddr]),&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,noffH.initData.inFileAddr+vAddr-noffH.initData.virtualAddr);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//更新pagevTable表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pageTable[vpn].virtualPage&nbsp;=&nbsp;vpn;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pageTable[vpn].physicalPage&nbsp;=&nbsp;ppn;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pageTable[vpn].valid&nbsp;=&nbsp;TRUE;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;pageTable[vpn].lastUseTime&nbsp;=&nbsp;stats-&gt;totalTicks;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//更新被置换掉的页表项 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(swapVpn&nbsp;!=&nbsp;-1)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pageTable[swapVpn].physicalPage&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pageTable[swapVpn].valid&nbsp;=&nbsp;FALSE;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果被置换掉的页已经被修改 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//写回到磁盘 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(pageTable[swapVpn].dirty&nbsp;==&nbsp;TRUE)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEBUG(</span><span class="string">'p'</span><span>,</span><span class="string">&quot;swap&nbsp;the&nbsp;page&nbsp;to&nbsp;disk.&#92;n&quot;</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;TRUE;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4321</link>
<title><![CDATA[[nachos] nachos 内存管理和多进程实现 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:29:37 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4321</guid> 
<description>
<![CDATA[ 
	1.首先利用位图来管理内存<br />mBitmap = new BitMap(NumPhysPages);<span style="white-space: pre"> </span><br /><br /><br />2.创建用户空间时，首先从位图中找到一个空闲页，如果没有空间为，置为0，并标识valid = FALSE<br />&nbsp;&nbsp; <div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span>&nbsp;pageTable&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;TranslationEntry[numPages];&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;numPages;&nbsp;i++)&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>pageTable[i].virtualPage&nbsp;=&nbsp;i;</span><span class="comment">//&nbsp;for&nbsp;now,&nbsp;virtual&nbsp;page&nbsp;#&nbsp;=&nbsp;phys&nbsp;page&nbsp;# </span><span>&nbsp;&nbsp;</span></li><li><span class="datatypes">int</span><span>&nbsp;ppn&nbsp;=&nbsp;machine-&gt;mBitmap-&gt;Find();</span><span class="comment">//查找一个空闲块 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">if</span><span>(ppn&nbsp;!=&nbsp;-1)&nbsp;</span><span class="comment">//如果有空闲块 </span><span>&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>pageTable[i].physicalPage&nbsp;=&nbsp;ppn;&nbsp;&nbsp;</span></li><li><span>pageTable[i].valid&nbsp;=&nbsp;TRUE;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span class="keyword">else</span><span>&nbsp;</span><span class="comment">//如果没有空闲块，无法将该页放入内存 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>pageTable[i].physicalPage&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li><li class="alt"><span>pageTable[i].valid&nbsp;=&nbsp;FALSE;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>pageTable[i].use&nbsp;=&nbsp;FALSE;&nbsp;&nbsp;</span></li><li><span>pageTable[i].dirty&nbsp;=&nbsp;FALSE;&nbsp;&nbsp;</span></li><li class="alt"><span>pageTable[i].readOnly&nbsp;=&nbsp;FALSE;&nbsp;&nbsp;</span><span class="comment">//&nbsp;if&nbsp;the&nbsp;code&nbsp;segment&nbsp;was&nbsp;entirely&nbsp;on&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span class="comment">//&nbsp;a&nbsp;separate&nbsp;page,&nbsp;we&nbsp;could&nbsp;set&nbsp;its&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="comment">//&nbsp;pages&nbsp;to&nbsp;be&nbsp;read-only </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none"> pageTable = new TranslationEntry[numPages];&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; numPages; i++) &#123; pageTable[i].virtualPage = i;// for now, virtual page # = phys page # int ppn = machine-&gt;mBitmap-&gt;Find();//查找一个空闲块 if(ppn != -1) //如果有空闲块 &#123; pageTable[i].physicalPage = ppn; pageTable[i].valid = TRUE; &#125; else //如果没有空闲块，无法将该页放入内存 &#123; pageTable[i].physicalPage = 0; pageTable[i].valid = FALSE; &#125; pageTable[i].use = FALSE; pageTable[i].dirty = FALSE; pageTable[i].readOnly = FALSE;&nbsp;&nbsp;// if the code segment was entirely on&nbsp;&nbsp;// a separate page, we could set its&nbsp;&nbsp;// pages to be read-only&nbsp;&nbsp;&nbsp;&nbsp; &#125; </pre><br /><br /><br />3.修改读入内存的代码，每次只读一个字节<br />&nbsp; <div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7581351#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(noffH.code.size&nbsp;&gt;&nbsp;0)&nbsp;&#123;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DEBUG(</span><span class="string">'a'</span><span>,&nbsp;</span><span class="string">&quot;Initializing&nbsp;code&nbsp;segment,&nbsp;at&nbsp;0x%x,&nbsp;size&nbsp;%d&#92;n&quot;</span><span>,&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>noffH.code.virtualAddr,&nbsp;noffH.code.size);&nbsp;&nbsp;</span></li><li><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&lt;noffH.code.size;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>vAddr&nbsp;=&nbsp;noffH.code.virtualAddr&nbsp;+&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>vpn&nbsp;=&nbsp;vAddr/PageSize;</span><span class="comment">//虚拟页号 </span><span>&nbsp;&nbsp;</span></li><li><span>offset&nbsp;=&nbsp;vAddr%PageSize;</span><span class="comment">//偏移量 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">if</span><span>(pageTable[vpn].valid&nbsp;!=&nbsp;FALSE)&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>ppn&nbsp;=&nbsp;pageTable[vpn].physicalPage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//物理块号 </span><span>&nbsp;&nbsp;</span></li><li><span>pAddr&nbsp;=&nbsp;ppn*PageSize&nbsp;+&nbsp;offset;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//物理地址 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>executable-&gt;ReadAt(&amp;(machine-&gt;mainMemeory[pAddr],1,noffH.code.inFileAddr+i));&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(noffH.initData.size&nbsp;&gt;&nbsp;0)&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&lt;noffH.initData.size;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>vAddr&nbsp;=&nbsp;noffH.initData.virtualAddr&nbsp;+&nbsp;i;&nbsp;&nbsp;</span></li><li class="alt"><span>vpn&nbsp;=&nbsp;vAddr/PageSize;</span><span class="comment">//虚拟页号 </span><span>&nbsp;&nbsp;</span></li><li><span>offset&nbsp;=&nbsp;vAddr%PageSize;</span><span class="comment">//偏移量 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">if</span><span>(pageTable[vpn].valid&nbsp;!=&nbsp;FALSE)&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>ppn&nbsp;=&nbsp;pageTable[vpn].physicalPage;</span><span class="comment">//物理块号 </span><span>&nbsp;&nbsp;</span></li><li><span>pAddr&nbsp;=&nbsp;ppn*PageSize&nbsp;+&nbsp;offset;</span><span class="comment">//物理地址 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>executable-&gt;ReadAt(&amp;(machine-&gt;mainMemeory[pAddr],1,noffH.initData.inFileAddr+i));&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">&nbsp;&nbsp; if (noffH.code.size &gt; 0) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEBUG('a', &quot;Initializing code segment, at 0x%x, size %d&#92;n&quot;,&nbsp;&nbsp;noffH.code.virtualAddr, noffH.code.size); for(int i = 0;i&lt;noffH.code.size;i++) &#123; vAddr = noffH.code.virtualAddr + i; vpn = vAddr/PageSize;//虚拟页号 offset = vAddr%PageSize;//偏移量 if(pageTable[vpn].valid != FALSE) &#123;&nbsp;&nbsp;ppn = pageTable[vpn].physicalPage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//物理块号 pAddr = ppn*PageSize + offset;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//物理地址 executable-&gt;ReadAt(&amp;(machine-&gt;mainMemeory[pAddr],1,noffH.code.inFileAddr+i)); &#125; &#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp; if (noffH.initData.size &gt; 0) &#123;&nbsp;&nbsp;for(int i = 0;i&lt;noffH.initData.size;i++) &#123; vAddr = noffH.initData.virtualAddr + i; vpn = vAddr/PageSize;//虚拟页号 offset = vAddr%PageSize;//偏移量 if(pageTable[vpn].valid != FALSE) &#123;&nbsp;&nbsp;ppn = pageTable[vpn].physicalPage;//物理块号 pAddr = ppn*PageSize + offset;//物理地址 executable-&gt;ReadAt(&amp;(machine-&gt;mainMemeory[pAddr],1,noffH.initData.inFileAddr+i)); &#125; &#125;&nbsp;&nbsp;&nbsp;&nbsp; &#125; </pre><br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4320</link>
<title><![CDATA[[nachos] nachos Lab3 TLB替换算法 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:29:15 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4320</guid> 
<description>
<![CDATA[ 
	<p>Lab3 最近才开始做，过今天又要交了，本来还想凑合凑合混一下。结果昨天得知一个噩耗，看来还是要认真做啊。</p><p>首先介绍一下nachos 的存储管理机制。</p><p>当我们运行./nachos -x ../test/halt时，运行了一个用户程序。</p><p>基本过程是：</p><p>&nbsp;OpenFile *executable = fileSystem-&gt;Open(filename);&nbsp;</p><p>&nbsp;首先打开该执行文件。</p><p>&nbsp;AddrSpace *space; &nbsp;</p><p>space = new AddrSpace(executable); &nbsp;</p><p>创建一个用户空间，该用户空间包含一个页表，记录了虚拟页号和物理页号的映射情况。</p><p>在创建用户空间时所做的事情有从文件中获取代码段和数据段。</p><p>初始化该页表，由于一开始内存中只能存放一个进程，所以虚拟地址跟物理地址是一样的。<br /></p><p>然后根据虚拟地址到物理地址的映射情况，将文件的代码段和数据段拷贝到内存。</p><p>&nbsp;space-&gt;InitRegisters();</p><p>初始化CPU的寄存器，让它指向需要执行的第一条指令。寄存器指向的地址为虚拟地址，</p><p>所以在执行之前，我们需要先将其转化为物理地址。</p><p>space-&gt;RestoreState();<br /></p><p>将进程的页表拷贝到CPU中维护。</p><p>&nbsp;machine-&gt;Run();<br /></p><p>该方法，循环的从寄存器中获得一条指令并运行。</p><br /><p>1 修改exception.cc，添加缺页异常的处理。<br /></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>(which&nbsp;==&nbsp;PageFaultException)&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//获得虚拟地址 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;addr&nbsp;=&nbsp;machine-&gt;ReadRegister(BadVAddrReg);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//tlb页面置换算法，这里用LRU置换法 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;machine-&gt;LRUSwap(</span><span class="datatypes">int</span><span>&nbsp;addr);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">else if(which == PageFaultException)&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp; &nbsp;&nbsp;//获得虚拟地址 &nbsp;&nbsp;int addr = machine-&gt;ReadRegister(BadVAddrReg); &nbsp;&nbsp;//tlb页面置换算法，这里用LRU置换法 &nbsp;&nbsp;machine-&gt;LRUSwap(int addr);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;</pre><p></p><p>2 在machine中添加你想要的置换算法，参考学长的做法用的LRU方法，确实更加简单方便。</p><p>在这里也可以写一个FIFO或者NRU的方法，以便于Execise 4中的比较。不过NRU的方法实现起来比较麻烦一点，所以就被我pass了。</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7572598#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="comment">//&nbsp;LRU&nbsp;置换算法 </span><span>&nbsp;&nbsp;</span></span></li><li><span class="keyword">void</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>Machine::LRUSwap(</span><span class="datatypes">int</span><span>&nbsp;addr)&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;DEBUG(</span><span class="string">'p'</span><span>,</span><span class="string">&quot;TLB&nbsp;MISS,use&nbsp;LRU&nbsp;swap&#92;n&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;vpn&nbsp;=&nbsp;addr&nbsp;/&nbsp;PageSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//虚拟页号 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;min&nbsp;=&nbsp;tlb[0].lastUseTime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//最小时间 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;TranslationEntry&nbsp;*entry&nbsp;=&nbsp;&amp;tlb[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//置换的页表项 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;&nbsp;TLBSize;i++)&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tlb[i].valid&nbsp;==&nbsp;FALSE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果有空项，直接返回 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry&nbsp;=&nbsp;&amp;tlb[i];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">break</span><span>;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tlb[i].lastUseTime&nbsp;&lt;&nbsp;min)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//找到时间最小的一项，即为需要置换的项 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;tlb[i].lastUseTime;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry&nbsp;=&nbsp;&amp;tlb[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//置换该项 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(entry-&gt;valid&nbsp;!=&nbsp;FALSE)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;pageTable[entry-&gt;virtualPage]&nbsp;=&nbsp;*entry;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*entry&nbsp;=&nbsp;pageTable[vpn];&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;entry-&gt;lastUseTime&nbsp;=&nbsp;stats-&gt;totalTicks;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//打印tlb中的内容 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">// LRU 置换算法 void Machine::LRUSwap(int addr)&#123; &nbsp;&nbsp;DEBUG('p',&quot;TLB MISS,use LRU swap&#92;n&quot;);&nbsp;&nbsp;&nbsp;&nbsp; int vpn = addr / PageSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//虚拟页号&nbsp;&nbsp;&nbsp;&nbsp; int min = tlb[0].lastUseTime;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//最小时间&nbsp;&nbsp;&nbsp;&nbsp; TranslationEntry *entry = &amp;tlb[0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//置换的页表项&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0; i&lt; TLBSize;i++)&#123; &nbsp;&nbsp;if(tlb[i].valid == FALSE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果有空项，直接返回 &nbsp;&nbsp;&#123; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry = &amp;tlb[i]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; &nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;if(tlb[i].lastUseTime &lt; min)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//找到时间最小的一项，即为需要置换的项 &nbsp;&nbsp;&#123; &nbsp;&nbsp;&nbsp;&nbsp; min = tlb[i].lastUseTime; &nbsp;&nbsp;&nbsp;&nbsp; entry = &amp;tlb[i];&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//置换该项&nbsp;&nbsp;&nbsp;&nbsp; if(entry-&gt;valid != FALSE) &nbsp;&nbsp;pageTable[entry-&gt;virtualPage] = *entry;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *entry = pageTable[vpn];&nbsp;&nbsp;&nbsp;&nbsp; entry-&gt;lastUseTime = stats-&gt;totalTicks;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//打印tlb中的内容&nbsp;&nbsp;&#125;</pre><br />最后记得修改修改machine中的ReadMem 和 WriteMem方法，TLB置换后，重新调用translate方法<br /><p></p><p>提醒，如果要用到TLB,需要在Makefile中添加DUSE_TLB，否则TLB是无法被启用的。</p><p>当然这里TLB跟pageTable 是需要共存的，因为在TLB中找不到的话需要在pageTable中去查找。</p><p>注释掉translate方法中这两句吧，不然肯定是会出错的。&nbsp;</p><p>&nbsp;// ASSERT(tlb == NULL &#124;&#124; pageTable == NULL);<span style="white-space: pre"> </span><br />&nbsp;// &nbsp; ASSERT(tlb != NULL &#124;&#124; pageTable != NULL);<span style="white-space: pre"> </span></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4319</link>
<title><![CDATA[[nachos] nachos文件系统-实现多级目录 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:28:43 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4319</guid> 
<description>
<![CDATA[ 
	<div id="article_content" class="article_content"><p>我在实现多级目录的时候是用递归来做的，在创建文件的时候文件名中可能包含有目录</p><p>比如创建一个文件 abc/efg ，首先从该字符串中找到第一个目录abc，剩余字符串为 efg。</p><p>首先入读根目录，从根目录的目录项中查找abc对应的头结点号。</p><p>然后根据该sector num 读取abc文件的内容，由于该文件是一个目录文件，它也保存了一个目录项，再往abc目录文件的目录项中插入该efg文件。</p><br /><p>不过在实现的过程中有一些BUG和乱码到现在也还没解决，只好凑合凑合了。</p><p>首先文件分为目录和普通文件两类，普通文件用'-' 标示，目录文件用'd'标示</p><br /><p>修改Directory<span style="font-family: 宋体">的</span><span style="font-family: Calibri">Add</span><span style="font-family: 宋体">方法，利用循环遍历</span></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7572528#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7572528#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7572528#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7572528#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;Directory::Add(</span><span class="datatypes">char</span><span>&nbsp;*name,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;newSector,&nbsp;</span><span class="datatypes">char</span><span>&nbsp;type,</span><span class="datatypes">char</span><span>&nbsp;*filepath)&nbsp;&nbsp;</span></span></li><li><span>&#123;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span><span class="datatypes">char</span><span>&nbsp;*p&nbsp;=&nbsp;strchr(name,</span><span class="string">'/'</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(p&nbsp;==&nbsp;NULL)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span><span class="comment">//如果名字中不包含目录 </span><span>&nbsp;&nbsp;</span></li><li><span class="keyword">if</span><span>&nbsp;(FindIndex(name)&nbsp;!=&nbsp;-1)&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;tableSize;&nbsp;i++)&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">if</span><span>&nbsp;(!table[i].inUse)&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;table[i].inUse&nbsp;=&nbsp;TRUE;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;strncpy(table[i].name,&nbsp;name,&nbsp;FileNameMaxLen);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(filepath!=NULL)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strncpy(table[i].path,&nbsp;filepath,&nbsp;PATH_LENGTH);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;table[i].filetype&nbsp;=&nbsp;type;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;table[i].sector&nbsp;=&nbsp;newSector;&nbsp;&nbsp;</span></li><li><span class="keyword">return</span><span>&nbsp;TRUE;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;no&nbsp;space.&nbsp;&nbsp;Fix&nbsp;when&nbsp;we&nbsp;have&nbsp;extensible&nbsp;files. </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&#125;</span><span class="keyword">else</span><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">char</span><span>&nbsp;path[PATH_LENGTH+1];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(filepath!=NULL)&nbsp;&nbsp;</span><span class="comment">//如果名字中包含目录 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;strncpy(path,filepath,PATH_LENGTH);&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;index&nbsp;=&nbsp;p-name;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">char</span><span>&nbsp;dname[index+1];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strncpy(dname,name,index);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dname[index]&nbsp;=&nbsp;</span><span class="string">'&#92;0'</span><span>;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//进入第一个目录&nbsp; </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;sector&nbsp;=&nbsp;Find(dname);&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(sector&nbsp;==-1)&nbsp;</span><span class="comment">//如果找不到该目录 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>printf(</span><span class="string">&quot;couldn't&nbsp;find&nbsp;the&nbsp;directory&nbsp;%s&#92;n&quot;</span><span>,dname);&nbsp;&nbsp;</span></li><li><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;</span><span class="comment">//创建目录文件 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenFile*&nbsp;openFile&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;OpenFile(sector);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Directory&nbsp;*directory1&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Directory(NumDirEntries);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory1-&gt;FetchFrom(openFile);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(!directory1-&gt;Add(p+1,newSector,type,path))&nbsp;</span><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory1-&gt;WriteBack(openFile);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">delete</span><span>&nbsp;directory1;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;TRUE;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">bool Directory::Add(char *name, int newSector, char type,char *filepath) &#123;&nbsp;&nbsp;&nbsp;&nbsp; char *p = strchr(name,'/');&nbsp;&nbsp;&nbsp;&nbsp;if(p == NULL)&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;//如果名字中不包含目录 if (FindIndex(name) != -1) return FALSE;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; tableSize; i++) if (!table[i].inUse) &#123;&nbsp;&nbsp;&nbsp;&nbsp; table[i].inUse = TRUE;&nbsp;&nbsp;&nbsp;&nbsp; strncpy(table[i].name, name, FileNameMaxLen);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(filepath!=NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strncpy(table[i].path, filepath, PATH_LENGTH);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;table[i].filetype = type;&nbsp;&nbsp;&nbsp;&nbsp; table[i].sector = newSector; return TRUE; &#125;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;&nbsp;&nbsp;// no space.&nbsp;&nbsp;Fix when we have extensible files.&nbsp;&nbsp;&nbsp;&nbsp;&#125;else&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char path[PATH_LENGTH+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(filepath!=NULL)&nbsp;&nbsp;//如果名字中包含目录&nbsp;&nbsp;strncpy(path,filepath,PATH_LENGTH);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int index = p-name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char dname[index+1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strncpy(dname,name,index);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dname[index] = '&#92;0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//进入第一个目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int sector = Find(dname);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(sector ==-1) //如果找不到该目录&nbsp;&nbsp;&nbsp;&nbsp; &#123; printf(&quot;couldn't find the directory %s&#92;n&quot;,dname); return FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp; //创建目录文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenFile* openFile = new OpenFile(sector);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Directory *directory1 = new Directory(NumDirEntries);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory1-&gt;FetchFrom(openFile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!directory1-&gt;Add(p+1,newSector,type,path)) return FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory1-&gt;WriteBack(openFile);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete directory1;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;</pre><br /><p></p><p><span style="font-family: 宋体">修改Find，List,Print，与Add方法类似，都是用循环递归来做。如果进入的是目录文件，则读取该目录文件，递归调用原方法。</span></p><p><span style="font-family: 宋体"><img class="insertimage" src="attachment.php?fid=1456" border="0" width="544" height="197" /><br /></span></p><p><span style="font-family: 宋体"><br /></span></p><p><span style="font-family: 宋体">文件系统部分，也只有多级目录这块是自己弄的，其他部分基本都是参考某学长的，估计他的报告大家应该也都是人手一份吧。</span></p><p><span style="font-family: 宋体">幸亏有他，不然这OS的实验都没什么思路，也不知道要费多少时间跟精力来弄。</span></p></div>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4318</link>
<title><![CDATA[[nachos] nachos 扩展文件长度 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:28:01 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4318</guid> 
<description>
<![CDATA[ 
	<p>前段时间又忙着投各种简历，面试，结果纷纷悲剧。只能当时锻炼胆量和总结经验了，结果也发现了自己很多不足，决定闭关一阵子好好巩固巩固再说。</p><p>Lab2 实在是没怎么认真做，基本都是参考上一些学长学姐做过的东西。也留下了很多BUG没有解决，所以也不敢放上来都。</p><p>Lab3 过几天又要交了，这今天又有的忙活了，这两天会写一些实验中的过程方出来，仅供参考，当然我也都是参考别人的做的。</p><p>攒人品，求过~</p><br /><p></p><p>1.&nbsp;<span style="font-family: 宋体">首先，为</span>FileHeader添加属性，一级索引和二级索引，同时减小<span style="font-family: Calibri">NumDirect</span><span style="font-family: 宋体">的大小</span><span style="font-family: 宋体">。</span></p><p></p><p>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;inDirectSector1; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;<span style="font-family: 宋体">一级索引</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;inDirectSector2;<span style="white-space: pre"> </span>&nbsp; &nbsp; &nbsp;&nbsp; //&nbsp;<span style="font-family: 宋体">二级索引</span></p><p></p><p>2.&nbsp;<span style="font-family: 宋体">修改</span><span style="font-family: Calibri">FileHeader::Allocate(BitMap&nbsp;*freeMap,&nbsp;int&nbsp;fileSize)</span><span style="font-family: 宋体">方法。</span></p><p><span style="font-family: 宋体">在这里只做了一级索引的方法，二级索引的方法类似。</span></p><p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="datatypes">bool</span><span>&nbsp;FileHeader::Allocate(BitMap&nbsp;*freeMap,&nbsp;</span><span class="datatypes">int</span><span>&nbsp;fileSize)&nbsp;&nbsp;</span></span></li><li><span>&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;numBytes&nbsp;=&nbsp;fileSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//文件大小 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;numSectors&nbsp;&nbsp;=&nbsp;divRoundUp(fileSize,&nbsp;SectorSize);&nbsp;&nbsp;&nbsp;</span><span class="comment">//根据文件大小计算所需块数 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(NumDirect&nbsp;&gt;=&nbsp;numSectors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果直接索引的数据块足够 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>&nbsp;(freeMap-&gt;NumClear()&nbsp;&lt;&nbsp;numSectors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果位图中空间块不足 </span><span>&nbsp;&nbsp;</span></li><li><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//&nbsp;not&nbsp;enough&nbsp;space </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;numSectors;&nbsp;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//找到一个空间块并分配 </span><span>&nbsp;&nbsp;</span></li><li><span>dataSectors[i]&nbsp;=&nbsp;freeMap-&gt;Find();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果直接索引的数据块不够&nbsp;&nbsp; </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(freeMap-&gt;NumClear()&nbsp;&lt;&nbsp;numSectors&nbsp;+1)&nbsp;</span><span class="keyword">return</span><span>&nbsp;FALSE;&nbsp;</span><span class="comment">//多一块用来存索引 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;&nbsp;NumDirect;&nbsp;i++)&nbsp;&nbsp;</span></li><li><span>dataSectors[i]&nbsp;=&nbsp;freeMap-&gt;Find();&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inDirectSector1&nbsp;=&nbsp;freeMap-&gt;Find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//分配一块用来存索引 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;index[numSectors-NumDirect];&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>&nbsp;(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&lt;&nbsp;numSectors&nbsp;-&nbsp;NumDirect;i++)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>index[i]&nbsp;=&nbsp;freeMap-&gt;Find();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchDisk-&gt;WriteSector(inDirectSector1,(</span><span class="datatypes">char</span><span>&nbsp;*)index);&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;TRUE;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">bool FileHeader::Allocate(BitMap *freeMap, int fileSize) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numBytes = fileSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //文件大小&nbsp;&nbsp;&nbsp;&nbsp; numSectors&nbsp;&nbsp;= divRoundUp(fileSize, SectorSize);&nbsp;&nbsp; //根据文件大小计算所需块数&nbsp;&nbsp;&nbsp;&nbsp;if(NumDirect &gt;= numSectors) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果直接索引的数据块足够&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (freeMap-&gt;NumClear() &lt; numSectors)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果位图中空间块不足 return FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;// not enough space&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; numSectors; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //找到一个空间块并分配 dataSectors[i] = freeMap-&gt;Find();&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果直接索引的数据块不够&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; if(freeMap-&gt;NumClear() &lt; numSectors +1) return FALSE; //多一块用来存索引&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i&lt; NumDirect; i++) dataSectors[i] = freeMap-&gt;Find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inDirectSector1 = freeMap-&gt;Find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分配一块用来存索引&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int index[numSectors-NumDirect];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (int i = 0; i&lt; numSectors - NumDirect;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123; index[i] = freeMap-&gt;Find();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchDisk-&gt;WriteSector(inDirectSector1,(char *)index);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; return TRUE; &#125;</pre><br /><br /><p></p><p></p><p>3.&nbsp;修改<span style="font-family: Calibri">ByteToSector&nbsp;</span><span style="font-family: 宋体">方法。</span></p><p></p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7572486#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="datatypes">int</span><span>&nbsp;FileHeader::ByteToSector(</span><span class="datatypes">int</span><span>&nbsp;offset)&nbsp;&nbsp;</span></span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;sector&nbsp;=&nbsp;offset&nbsp;/&nbsp;SectorSize;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(&nbsp;sector&nbsp;&lt;&nbsp;NumDirect)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果只用到了直接索引 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;(dataSectors[sector]);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果还用到了一级索引 </span><span>&nbsp;&nbsp;</span></li><li><span>sector&nbsp;-=NumDirect;&nbsp;&nbsp;</span></li><li class="alt"><span class="datatypes">int</span><span>&nbsp;index[numSectors&nbsp;-&nbsp;NumDirect];&nbsp;&nbsp;</span></li><li><span>synchDisk-&gt;ReadSector(inDirectSector1,(</span><span class="datatypes">char</span><span>&nbsp;*)index);&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">return</span><span>&nbsp;(index[sector]);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">int FileHeader::ByteToSector(int offset) &#123;&nbsp;&nbsp;&nbsp;&nbsp; int sector = offset / SectorSize;&nbsp;&nbsp;&nbsp;&nbsp; if( sector &lt; NumDirect)&nbsp;&nbsp; &nbsp;&nbsp; //如果只用到了直接索引&nbsp;&nbsp;&nbsp;&nbsp; return (dataSectors[sector]);&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //如果还用到了一级索引 sector -=NumDirect; int index[numSectors - NumDirect]; synchDisk-&gt;ReadSector(inDirectSector1,(char *)index); return (index[sector]);&nbsp;&nbsp;&nbsp;&nbsp; &#125; &#125;</pre><p></p><p></p><p>4.&nbsp;<span style="font-family: 宋体">删除文件时也需要判断，如果用到了一级索引，还需要将一级索引中的块号释放掉。</span></p><p>5.&nbsp;<span style="font-family: 宋体">修改</span><span style="font-family: Calibri">Print</span><span style="font-family: 宋体">方法。当文件用到了一级索引时，需要先读取存储间接索引的块内容，然后打开一级索中用到的块，读取块内容。</span></p><p>实验结果如下，可以看到直接索引指向的块号为<span style="font-family: Calibri">7-31</span><span style="font-family: 宋体">。</span><span style="font-family: 宋体">一级索引所保存的块号为</span><span style="font-family: Calibri">33-55</span><span style="font-family: 宋体">。</span></p><p style="margin-top: 0pt; margin-bottom: 0pt" class="p0"><img class="insertimage" src="attachment.php?fid=1455" border="0" width="540" height="282" /><br /></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4317</link>
<title><![CDATA[[nachos] nachos线程优先级控制 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:27:21 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4317</guid> 
<description>
<![CDATA[ 
	1.在thread.h中添加priority属性和set，get方法<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">private</span><span>:&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;priority;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//priority&nbsp;of&nbsp;thread </span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>pubclic:&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;getPriority()&#123;</span><span class="keyword">return</span><span>&nbsp;priority;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">void</span><span>&nbsp;setPriority(</span><span class="datatypes">int</span><span>&nbsp;p)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(p&nbsp;&gt;&nbsp;PRIORITY_MAX)&nbsp;priority&nbsp;=&nbsp;PRIORITY_MAX;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>(p&nbsp;&lt;&nbsp;PRIORITY_MIN)&nbsp;priority&nbsp;=&nbsp;PRIORITY_MIN;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;priority&nbsp;=&nbsp;p;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">private:&nbsp;&nbsp;&nbsp;&nbsp;int priority;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//priority of thread&nbsp;&nbsp;pubclic:&nbsp;&nbsp;&nbsp;&nbsp; int getPriority()&#123;return priority;&#125;&nbsp;&nbsp;&nbsp;&nbsp; void setPriority(int p)&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp; if(p &gt; PRIORITY_MAX) priority = PRIORITY_MAX;&nbsp;&nbsp;&nbsp;&nbsp; else if(p &lt; PRIORITY_MIN) priority = PRIORITY_MIN;&nbsp;&nbsp;&nbsp;&nbsp; priority = p;&nbsp;&nbsp;&nbsp;&nbsp; &#125;</pre><br />2.在thread.cc中修改Thread.Yield()方法<br />&nbsp;<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">if</span><span>&nbsp;(nextThread&nbsp;!=&nbsp;NULL)&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果下一个线程不为空 </span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;</span><span class="keyword">if</span><span>(nextThread-&gt;getPriority()&nbsp;&gt;&nbsp;</span><span class="keyword">this</span><span>-&gt;getPriority())&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果下一个线程优先级比当前线程低，继续运行当前线程 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheduler-&gt;ReadyToRun(nextThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;</span><span class="keyword">else</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//否则 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheduler-&gt;ReadyToRun(</span><span class="keyword">this</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//将该线程的状态设置为就绪状态 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scheduler-&gt;Run(nextThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//调度器运行下一个线程 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">&nbsp;&nbsp; if (nextThread != NULL) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//如果下一个线程不为空&nbsp;&nbsp;&nbsp;&nbsp; if(nextThread-&gt;getPriority() &gt; this-&gt;getPriority())&nbsp;&nbsp;&nbsp;&nbsp;//如果下一个线程优先级比当前线程低，继续运行当前线程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scheduler-&gt;ReadyToRun(nextThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//否则&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scheduler-&gt;ReadyToRun(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将该线程的状态设置为就绪状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scheduler-&gt;Run(nextThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调度器运行下一个线程&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&nbsp;&nbsp; &#125; </pre><br /><br />3.修改scheduler.cc中的ReadyToRun()方法<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span>readyList-&gt;SortedInsert((</span><span class="keyword">void</span><span>&nbsp;*)</span><span class="keyword">thread</span><span>,</span><span class="keyword">thread</span><span>-&gt;getPriority());&nbsp;&nbsp;</span></span></li><li><span class="comment">//readyList-&gt;Append((void&nbsp;*)thread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//假如就绪队列</span><span>&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">&nbsp;&nbsp;&nbsp;&nbsp;readyList-&gt;SortedInsert((void *)thread,thread-&gt;getPriority());&nbsp;&nbsp;&nbsp;&nbsp; //readyList-&gt;Append((void *)thread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//假如就绪队列</pre><br /><p>4.修改测试文件</p><p></p><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7330514#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="keyword">void</span><span>&nbsp;&nbsp;</span></span></li><li><span>PrintPriority(</span><span class="datatypes">int</span><span>&nbsp;tid)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i=0;i!=3;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;printf(</span><span class="string">&quot;***&nbsp;tid:%d&nbsp;looped&nbsp;%d&nbsp;times,&nbsp;priority:%d&#92;n&quot;</span><span>,tid,i,currentThread-&gt;getPriority());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;currentThread-&gt;Yield();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span class="keyword">void</span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>TestPriority()&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;6;&nbsp;i!=0;i--)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;Thread*&nbsp;t&nbsp;=&nbsp;Thread::getInstance(</span><span class="string">&quot;thread&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;t-&gt;setPriority(i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;</span><span class="keyword">if</span><span>(t!=NULL)&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t-&gt;Fork(PrintPriority,t-&gt;getTid());&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">void PrintPriority(int tid) &#123;&nbsp;&nbsp; for(int i=0;i!=3;i++)&nbsp;&nbsp; &#123;&nbsp;&nbsp; printf(&quot;*** tid:%d looped %d times, priority:%d&#92;n&quot;,tid,i,currentThread-&gt;getPriority());&nbsp;&nbsp; currentThread-&gt;Yield();&nbsp;&nbsp; &#125; &#125; void TestPriority() &#123; &nbsp; for(int i = 6; i!=0;i--) &nbsp; &#123; &nbsp; Thread* t = Thread::getInstance(&quot;thread&quot;); &nbsp; t-&gt;setPriority(i); &nbsp; if(t!=NULL) &nbsp;&nbsp; &nbsp;&nbsp; t-&gt;Fork(PrintPriority,t-&gt;getTid()); &nbsp; &#125; &#125;</pre><br /><p></p><p>测试结果如图：</p><p><img class="insertimage" src="attachment.php?fid=1454" border="0" width="847" height="472" /></p>
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4316</link>
<title><![CDATA[[nachos] 用条件变量和信号量解决生产者和消费者问题 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:26:19 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4316</guid> 
<description>
<![CDATA[ 
	用条件变量解决生产者和消费者问题（只有一个缓冲区）：<br /><br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="preprocessor">#define&nbsp;MAX&nbsp;100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//最大操作次数 </span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;</span><span class="datatypes">int</span><span>&nbsp;buffer&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//用来记录缓冲区中是否为空,只有一个缓冲区 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>Lock*&nbsp;mutex;&nbsp;&nbsp;</span></li><li><span>Condition*&nbsp;condc;&nbsp;&nbsp;</span></li><li class="alt"><span>Condition*&nbsp;condp;&nbsp;&nbsp;</span></li><li><span class="comment">//生产者 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">void</span><span>&nbsp;Producer(</span><span class="datatypes">int</span><span>&nbsp;tid)&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;1;i&nbsp;&lt;&nbsp;MAX;i++)&nbsp;&nbsp;</span></li><li><span>&nbsp;&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex-&gt;Acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//加锁 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(buffer&nbsp;!=&nbsp;0)&nbsp;condp-&gt;Wait(mutex);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//如果缓冲区值不为0，缓冲区满，等待消费者清空 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//将缓冲区中值设为i </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;tid=&nbsp;%d,Produce&nbsp;a&nbsp;new&nbsp;item.&nbsp;i&nbsp;=&nbsp;%d&#92;n&quot;</span><span>,tid,i);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;condc-&gt;Signal(mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//向消费者发送信号 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//解锁 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li><li class="alt"><span class="comment">//消费者 </span><span>&nbsp;&nbsp;</span></li><li><span class="keyword">void</span><span>&nbsp;Consumer(</span><span class="datatypes">int</span><span>&nbsp;tid)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;MAX;&nbsp;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex-&gt;Acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//加锁 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">while</span><span>(buffer&nbsp;==&nbsp;0)&nbsp;condc-&gt;Wait(mutex);&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//当缓冲区值为0时，缓冲区为空，等待生产者 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//将缓冲区置为空 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;tid&nbsp;=&nbsp;%d,Consume&nbsp;a&nbsp;item.&nbsp;i&nbsp;=&nbsp;%d&#92;n&quot;</span><span>,tid,i);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;condp-&gt;Signal(mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//向生产者发送信号 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//解锁 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&#125;&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">void</span><span>&nbsp;TestPC()&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;mutex&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Lock(</span><span class="string">&quot;mutex&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;condc&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Condition(</span><span class="string">&quot;condc&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;condp&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Condition(</span><span class="string">&quot;condp&quot;</span><span>);&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;*tp&nbsp;=&nbsp;Thread::getInstance(</span><span class="string">&quot;producer&nbsp;thread&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tp&nbsp;!=&nbsp;NULL)&nbsp;tp-&gt;Fork(Producer,tp-&gt;getTid());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//创建生产者线程 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;*tc&nbsp;=&nbsp;Thread::getInstance(</span><span class="string">&quot;consumer&nbsp;thread&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tc&nbsp;!=&nbsp;NULL)&nbsp;tc-&gt;Fork(Consumer,tc-&gt;getTid());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//创建消费者线程 </span><span>&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">#define MAX 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//最大操作次数&nbsp;&nbsp;int buffer = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用来记录缓冲区中是否为空,只有一个缓冲区 Lock* mutex; Condition* condc; Condition* condp; //生产者 void Producer(int tid) &#123;&nbsp;&nbsp;for(int i = 1;i &lt; MAX;i++)&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp; mutex-&gt;Acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加锁&nbsp;&nbsp;&nbsp;&nbsp; while(buffer != 0) condp-&gt;Wait(mutex);&nbsp;&nbsp;&nbsp;&nbsp;//如果缓冲区值不为0，缓冲区满，等待消费者清空&nbsp;&nbsp;&nbsp;&nbsp; buffer = i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将缓冲区中值设为i&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;tid= %d,Produce a new item. i = %d&#92;n&quot;,tid,i);&nbsp;&nbsp;&nbsp;&nbsp; condc-&gt;Signal(mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//向消费者发送信号&nbsp;&nbsp;&nbsp;&nbsp; mutex-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//解锁&nbsp;&nbsp;&#125; &#125; //消费者 void Consumer(int tid) &#123;&nbsp;&nbsp;for(int i = 1; i &lt; MAX; i++)&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp; mutex-&gt;Acquire();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//加锁&nbsp;&nbsp;&nbsp;&nbsp; while(buffer == 0) condc-&gt;Wait(mutex);&nbsp;&nbsp;&nbsp;&nbsp;//当缓冲区值为0时，缓冲区为空，等待生产者&nbsp;&nbsp;&nbsp;&nbsp; buffer = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//将缓冲区置为空&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;tid = %d,Consume a item. i = %d&#92;n&quot;,tid,i);&nbsp;&nbsp;&nbsp;&nbsp; condp-&gt;Signal(mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//向生产者发送信号&nbsp;&nbsp;&nbsp;&nbsp; mutex-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//解锁&nbsp;&nbsp;&#125; &#125;&nbsp;&nbsp;void TestPC() &#123;&nbsp;&nbsp;&nbsp;&nbsp; mutex = new Lock(&quot;mutex&quot;);&nbsp;&nbsp;&nbsp;&nbsp; condc = new Condition(&quot;condc&quot;);&nbsp;&nbsp;&nbsp;&nbsp; condp = new Condition(&quot;condp&quot;);&nbsp;&nbsp;&nbsp;&nbsp; Thread *tp = Thread::getInstance(&quot;producer thread&quot;);&nbsp;&nbsp;&nbsp;&nbsp; if(tp != NULL) tp-&gt;Fork(Producer,tp-&gt;getTid());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建生产者线程&nbsp;&nbsp;&nbsp;&nbsp; Thread *tc = Thread::getInstance(&quot;consumer thread&quot;);&nbsp;&nbsp;&nbsp;&nbsp; if(tc != NULL) tc-&gt;Fork(Consumer,tc-&gt;getTid());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//创建消费者线程 &#125;</pre><p>结果如下：</p><p><img class="insertimage" src="attachment.php?fid=1452" border="0" width="654" height="468" /><br /></p><br />利用信号量实现生产者于消费者问题，默认缓存区空间为10.List队列用来存放生产的产品。<br /><div class="dp-highlighter bg_cpp"><div class="bar"><div class="tools"><strong>[cpp]</strong> <a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="view plain" class="ViewSource">view plain</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="copy" class="CopyToClipboard">copy</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="print" class="PrintSource">print</a><a href="http://blog.csdn.net/ymyss4/article/details/7327102#" title="?" class="About">?</a></div></div><ol class="dp-cpp"><li class="alt"><span><span class="preprocessor">#define&nbsp;MAXITEMS&nbsp;10 </span><span>&nbsp;&nbsp;</span></span></li><li><span>List*&nbsp;list;&nbsp;&nbsp;</span></li><li class="alt"><span>Semaphore*&nbsp;smutex;&nbsp;&nbsp;</span></li><li><span>Semaphore*&nbsp;full;&nbsp;&nbsp;</span></li><li class="alt"><span>Semaphore*&nbsp;empty;&nbsp;&nbsp;</span></li><li><span class="keyword">void</span><span>&nbsp;Producer1(</span><span class="datatypes">int</span><span>&nbsp;tid)&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>*&nbsp;item;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>&nbsp;flag&nbsp;=&nbsp;1;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;30;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;item&nbsp;=&nbsp;&amp;flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//生产一项 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;tid&nbsp;=&nbsp;%d,&nbsp;Produce&nbsp;a&nbsp;new&nbsp;item,&nbsp;item&nbsp;=%d&#92;n&quot;</span><span>,tid,(*item));&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;empty-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//empty&nbsp;-&nbsp;1 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;smutex-&gt;P();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;list-&gt;Append(item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//放入共享区域 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;smutex-&gt;V();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;full-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//full&nbsp;+&nbsp;1 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li><li class="alt"><span class="keyword">void</span><span>&nbsp;Consumer1(</span><span class="datatypes">int</span><span>&nbsp;tid)&nbsp;&nbsp;</span></li><li><span>&#123;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="datatypes">int</span><span>*&nbsp;item;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">for</span><span>(</span><span class="datatypes">int</span><span>&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;30;i++)&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;full-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//full&nbsp;-&nbsp;1 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smutex-&gt;P();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item&nbsp;=&nbsp;(</span><span class="datatypes">int</span><span>*)list-&gt;Remove();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//从共享区域中移除 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smutex-&gt;V();&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//empty&nbsp;+&nbsp;1 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;*item&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//消费一项 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;printf(</span><span class="string">&quot;tid&nbsp;=&nbsp;%d,&nbsp;Consume&nbsp;a&nbsp;item,&nbsp;item&nbsp;=%d&#92;n&quot;</span><span>,tid,*item);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#125;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&#125;&nbsp;&nbsp;</span></li><li><span class="keyword">void</span><span>&nbsp;TestPC1()&nbsp;&nbsp;</span></li><li class="alt"><span>&#123;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;List;&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;smutex&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Semaphore(</span><span class="string">&quot;mutex&quot;</span><span>,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//互斥信号量 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Semaphore(</span><span class="string">&quot;empty&quot;</span><span>,MAXITEMS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//记录空间中空余数 </span><span>&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;full&nbsp;=&nbsp;</span><span class="keyword">new</span><span>&nbsp;Semaphore(</span><span class="string">&quot;full&quot;</span><span>,0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">//记录空间中存放数目 </span><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;*tp&nbsp;=&nbsp;Thread::getInstance(</span><span class="string">&quot;producer&nbsp;thread&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tp&nbsp;!=&nbsp;NULL)&nbsp;tp-&gt;Fork(Producer1,tp-&gt;getTid());&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread&nbsp;*tc&nbsp;=&nbsp;Thread::getInstance(</span><span class="string">&quot;consumer&nbsp;thread&quot;</span><span>);&nbsp;&nbsp;</span></li><li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">if</span><span>(tc&nbsp;!=&nbsp;NULL)&nbsp;tc-&gt;Fork(Consumer1,tc-&gt;getTid());&nbsp;&nbsp;</span></li><li><span>&#125;&nbsp;&nbsp;</span></li></ol></div><pre class="cpp" style="display: none">#define MAXITEMS 10 List* list; Semaphore* smutex; Semaphore* full; Semaphore* empty; void Producer1(int tid) &#123;&nbsp;&nbsp;&nbsp;&nbsp; int* item;&nbsp;&nbsp;&nbsp;&nbsp; int flag = 1;&nbsp;&nbsp;&nbsp;&nbsp; for(int i = 0;i &lt; 30;i++)&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item = &amp;flag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生产一项&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;tid = %d, Produce a new item, item =%d&#92;n&quot;,tid,(*item));&nbsp;&nbsp;&nbsp;&nbsp; empty-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//empty - 1&nbsp;&nbsp;&nbsp;&nbsp; smutex-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp; list-&gt;Append(item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//放入共享区域&nbsp;&nbsp;&nbsp;&nbsp; smutex-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp; full-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//full + 1&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp; &#125; void Consumer1(int tid) &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int* item;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i = 0;i &lt; 30;i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#123;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//full - 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smutex-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; item = (int*)list-&gt;Remove();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从共享区域中移除&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; smutex-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//empty + 1&nbsp;&nbsp;&nbsp;&nbsp; *item = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//消费一项&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;tid = %d, Consume a item, item =%d&#92;n&quot;,tid,*item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#125;&nbsp;&nbsp;&#125; void TestPC1() &#123; &nbsp;&nbsp; &nbsp;list = new List; &nbsp;&nbsp; &nbsp;smutex = new Semaphore(&quot;mutex&quot;,1);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//互斥信号量 &nbsp;&nbsp; &nbsp;empty = new Semaphore(&quot;empty&quot;,MAXITEMS);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//记录空间中空余数 &nbsp;&nbsp; &nbsp;full = new Semaphore(&quot;full&quot;,0);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//记录空间中存放数目 &nbsp;&nbsp;&nbsp; &nbsp;Thread *tp = Thread::getInstance(&quot;producer thread&quot;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tp != NULL) tp-&gt;Fork(Producer1,tp-&gt;getTid()); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread *tc = Thread::getInstance(&quot;consumer thread&quot;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(tc != NULL) tc-&gt;Fork(Consumer1,tc-&gt;getTid()); &#125; </pre><br />结果如下：<img class="insertimage" src="attachment.php?fid=1453" border="0" width="659" height="456" /><br />
]]>
</description>
</item><item>
<link>http://i.renjihe.com/blog/read.php?4315</link>
<title><![CDATA[[nachos] 实现锁和条件变量 ]]></title> 
<author>renjihe1988 &lt;admin@yourname.com&gt;</author>
<category><![CDATA[源码分析]]></category>
<pubDate>Thu, 17 Jan 2013 02:24:20 +0000</pubDate> 
<guid>http://i.renjihe.com/blog/read.php?4315</guid> 
<description>
<![CDATA[ 
	<div id="article_content" class="article_content">实现锁和条件变量，这个基本都是在参考别人的代码，然后自己慢慢理解.突然觉得自己好弱阿，不但写不出代码，看别人写的都要看半天才明白....打击颇大，要继续加油了.不然以后只好去中关村卖电脑了.<br /><br />1.实现锁<br />锁和信号量的区别在于锁只有两个状态，0或者1，同一时间只能有1个线程进入临界区，所以也叫互斥量，还有一个区别时，为锁添加了占用锁的当前线程属性。<br />修改synch.h文件，为Lock添加两个私有属性，拥有锁的线程和互斥信号量.<br /><br />&nbsp;&nbsp;&nbsp; Thread* holder;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 拥有锁的线程<br />&nbsp;&nbsp;&nbsp; Semaphore* lock;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 互斥信号<br /><br />实现方法<br />在构造函数中初始化该变量.信号量只能有两个状态BUSY 和 FREE <br />&nbsp;&nbsp; &nbsp;holder = NULL;<br />&nbsp;&nbsp; &nbsp;lock = new Semaphore(name,1);<br /><br />加锁和解锁的操作都是原子的，必须屏蔽中断.执行P操作,并设置当前占用线程<br />加锁操作<br />void Lock::Acquire() <br />&#123;<br />&nbsp;&nbsp; &nbsp;IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);&nbsp; // disable interrupts&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;lock-&gt;P();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // procure the semaphore<br />&nbsp;&nbsp;&nbsp; holder = currentThread;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp;&nbsp;&nbsp; (void) interrupt-&gt;SetLevel(oldLevel); // re-enable interrupts<br />&#125;<br />解锁操作，当前占用锁的进程为空，释放锁<br />void Lock::Release() <br />&#123;<br />&nbsp;&nbsp; &nbsp; &nbsp; IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);&nbsp; // disable interrupts<br />&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ASSERT(currentThread == holder);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; holder = NULL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; lock-&gt;V();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp; &nbsp;(void) interrupt-&gt;SetLevel(oldLevel);<br />&#125;<br /><br />2.实现条件变量<br />条件变量通常和锁一起使用，所有对条件变量的操作必须保证当前线程占有互斥锁。<br />所以在条件变量中声明一个锁和一个等待该条件变量的队列。<br />&nbsp;&nbsp;&nbsp; List* queue;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//等待条件变量的线程队列<br />&nbsp;&nbsp;&nbsp; Lock* lock;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//用来判断锁是否被当线程占用<br />构造函数初始化：<br />&nbsp;&nbsp;&nbsp; queue = new List;<br />&nbsp;&nbsp;&nbsp; lock = NULL;<br />当执行Wait操作时，当他不能获得期待的一个条件变量时，线程进入等待状态，原子性的调用并解锁它锁持有的互斥量，<br />当另一个线程向它发送信号时，它可以继续执行。<br /><br />void Condition::Wait(Lock* conditionLock) <br />&#123; <br />&nbsp;&nbsp;&nbsp; IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);<br /><br />&nbsp;&nbsp;&nbsp; ASSERT(conditionLock-&gt;isHeldByCurrentThread());&nbsp; <br />&nbsp;&nbsp;&nbsp; if(queue-&gt;IsEmpty()) &#123;<br />&nbsp;&nbsp; &nbsp;lock = conditionLock;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当等待队列为空时，绑定该条件变量和互斥锁。<br />&nbsp;&nbsp;&nbsp; &#125; <br />&nbsp;&nbsp;&nbsp; ASSERT(lock == conditionLock); <br />&nbsp;&nbsp;&nbsp; queue-&gt;Append(currentThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; //当前线程添加到该条件变量的等待队列中<br />&nbsp;&nbsp;&nbsp; conditionLock-&gt;Release();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //释放当前锁，使得其他线程可以进入临界区<br />&nbsp;&nbsp;&nbsp; currentThread-&gt;Sleep();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //当前线程进入等待状态<br />&nbsp;&nbsp;&nbsp; conditionLock-&gt;Acquire();&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //当其他线程发送一个信号后，当前线程wake up，并获得锁<br />&nbsp;&nbsp;&nbsp; (void) interrupt-&gt;SetLevel(oldLevel);<br />&#125;<br /><br />//发送信号，从等待队列中获得一个线程并启动<br />void Condition::Signal(Lock* conditionLock) <br />&#123; <br />&nbsp;&nbsp;&nbsp; Thread *nextThread;<br />&nbsp;&nbsp;&nbsp; IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);<br /><br />&nbsp;&nbsp;&nbsp; ASSERT(conditionLock-&gt;isHeldByCurrentThread());<br />&nbsp;&nbsp;&nbsp; if(!queue-&gt;IsEmpty()) &#123;<br />&nbsp;&nbsp; &nbsp;ASSERT(lock == conditionLock);<br />&nbsp;&nbsp; &nbsp;nextThread = (Thread *)queue-&gt;Remove();<br />&nbsp;&nbsp; &nbsp;scheduler-&gt;ReadyToRun(nextThread);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; &#125; <br />&nbsp;&nbsp;&nbsp; (void) interrupt-&gt;SetLevel(oldLevel);<br />&#125;<br /><br />//广播，使等待队列中每一个线程都启动<br />void Condition::Broadcast(Lock* conditionLock) <br />&#123; <br />&nbsp;&nbsp;&nbsp; Thread *nextThread;<br />&nbsp;&nbsp;&nbsp; IntStatus oldLevel = interrupt-&gt;SetLevel(IntOff);<br /><br />&nbsp;&nbsp;&nbsp; ASSERT(conditionLock-&gt;isHeldByCurrentThread());<br />&nbsp;&nbsp;&nbsp; if(!queue-&gt;IsEmpty()) &#123;<br />&nbsp;&nbsp; &nbsp;ASSERT(lock == conditionLock);<br />&nbsp;&nbsp; &nbsp;while(nextThread = (Thread *)queue-&gt;Remove()) &#123;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; scheduler-&gt;ReadyToRun(nextThread, 0);&nbsp; <br />&nbsp;&nbsp; &nbsp;&#125;<br />&nbsp;&nbsp;&nbsp; &#125; <br />&nbsp;&nbsp;&nbsp; (void) interrupt-&gt;SetLevel(oldLevel);<br />&#125;<br /></div>
]]>
</description>
</item>
</channel>
</rss>